[["index.html", "Автоматизированный сбор больших данных в экономико-социологических исследованиях Intro", " Автоматизированный сбор больших данных в экономико-социологических исследованиях Ph.A.Upravitelev 2023-11-03 Intro "],["overview.html", "Введение Запись занятия Data culture Обо мне Contacts MM invite link Syllabus R intro Синтаксис Окружение и подсказки Дополнительные материалы Домашнее задание", " Введение Запись занятия Запись занятия 9 сентября: Data culture Проект Data Culture направлен на то, чтобы у студентов всех программ бакалавриата Высшей школы экономики появилось понимание возможностей современных технологий в области Data Science. https://www.hse.ru/dataculture/ Обо мне продуктовый аналитик в Pixonic продуктовый аналитик в GameInsight аналитик в Консультант+ аспирант СПбГУ (когнитивная психология) Contacts @konhis в https://mm.upravitelev.info/ (основное средство коммуникации) upravitelev@gmail.com (дополнительное средство коммуникации) +7-965-425-5919 (для экстренных случаев) MM invite link Все взаимодействие по курсу будем вести в Mattermost (аналог Slack), это мессенджер для команд, очень популярен в IT и среди датасаентистов. https://mm.upravitelev.info/signup_user_complete/?id=cfm9gfrwstg3jfkybb9t65eo6e Syllabus Основы синтаксиса R. Виды источников данных. Импорт данных из разных типов файлов данныx - SPSS, Excel, *.csv и прочих. Методы сбора удаленных данных. Скрапинг полуструктурированных сайтов. Изучим XPath и как извлекать данные из html-кода страницы сайтов. Попутно научимся писать циклы и функции. Удаленные базы данных и API: простейшие API — что такое, зачем, как читать документацию. Работа с API VK и погодного сервиса. Анализ и представление результатов исследования: много времени будем уделять визуализациям. R intro Short history 1976: S language 1991-1993: R language by Ross Ihaka and Robert Gentleman 2000: stable beta 2011: RStudio 2011: Oracle R Enterprise 2015: Microsoft bought Revolution R 2017: Just-in-time compilations 2018: Speed improvements R ecosystem R Foundation https://www.r-project.org/foundation/ The Comprehensive R Archive Network: https://cran.r-project.org/ RStudio &amp; Hadley Wickham community R + RStudio R: https://cran.r-project.org/ (нужно установить самым первым) RStudio: https://www.rstudio.com/products/rstudio/download/ (после установки R) Альтернативные IDE https://colab.research.google.com/#create=true&amp;language=r (создает colab-ноутбук с R-ядром) https://posit.cloud/ (онлайн-версия RStudio) Style guide http://style.tidyverse.org/index.html Синтаксис Структура выражения result &lt;- sqrt(x = 4) sqrt() - функция. sqrt - название функции, в () указываются аргументы, к которым будет применяться функция с таким названием. x - обозначение аргумента функции (в разных функциях аргументы могут называться по-разному) 4 - значение, которое мы передаем в аргумент функции (к коротому будет применена функция) &lt;- - знак присваивания result - объект, в который мы записываем результат выполнения функции. Название объектов может быть разным (лучше придерживаться style guide при нейминге) Вывод на печать Прямое указание: print(result) ## [1] 2 Можно просто вызвать сам объект: result ## [1] 2 Присваивание Оператор &lt;- - это оператор присваивания. Если до этого объект не был создан, то таким образом мы создадим объект x, в котором содержится значение 5. Если до этого объект существовал, то ему будет присвоено новое значение. x &lt;- 5 print(x) ## [1] 5 Когда значение или результат функции записываем в объект, ничего не печатается. result &lt;- sqrt(x = 4) Если нет присвоения, а только простой вызов функции, то результат будет напечатан, как если это был какой-то объект. sqrt(x = 4) ## [1] 2 Операторы присвоения &lt;- (основной оператор) = (не рекомендуется, если только очень хочется) -&gt; (существует, но использовать крайне не рекомендуется) &lt;&lt;-, -&gt;&gt; (надо понимать, когда использовать, встречаются редко, лучше использовать assign()) Арифметические операторы В R помимо оператора присвоения есть другие операторы, в частности, арифметические операторы, операторы сравнения или логического выбора. Операторы сравнения или логические операторы обычно используются при необходимости указать какие-то условия для выбора элементов вектора или таблицы, а также в конструкциях if/else. Сложение: + Вычитание: - Умножение: * Деление: / Возведение в степень: ^, ** Остаток от деления: %% (5 %% 2 дает 1) Неполное частное деления: %/% (5 %/% 2 дает 2) Операторы сравнения тождество (равенство): == не равно: != больше/меньше или равно: &gt;=, &lt;= пропущено ли: is.na() (проверяет, является ли значение пропущенным, NA) Логические операторы И: &amp;, &amp;&amp; ИЛИ: |, || НЕ (Обратно): ! (TRUE превращает в FALSE и наоборот) Комментарии и кавычки #: строка, которая идет после этого знака, считается комментарием и не выполняется. Используется для того, чтобы прокомментировать код или скрыть от выполнения часть кода. '', \"\": использутся для создания строковых объектов, можно сочетать одной строке, они не взаимозаменяемы ``:обратные апострофы, используются в редких случаях, обычно в RMarkdown, инфиксных операторах или кириллических названиях объектов. Окружение и подсказки Полезные функции для работы с окружением При работе с R: install.packages('pkg') - установить пакет pkg или список пакетов. Делается однократно при настройке R library('pkg') - подключение установленного пакета - делается при каждом новом запуске сессии, если этот пакет планируется использовать getwd() - узнать адрес рабочей папки setwd() - никогда не использовать! Это мешает при работе с несколькими коллегами, может вызвать сбои при каких-то изменениях в структуре папок, да и в целом дурной тон. Лучше использовать проекты в RStudio, которые формируют отдельную папку под каждый проект. ls() - возвращает список созданных объектов рабочего окружения rm() - удалить какой-нибудь объект rm(list = ls()) - удалить все объекты рабочего окружения. Использовать только в консоли, никогда не использовать в скриптах, которые могут быть использованы другими людьми. help help(), ? (например, ?round)или ??. Проще всего выделить функцию и нажать F1 на клавиатуре. cheatsheets: https://www.rstudio.com/resources/cheatsheets/ google it! stackoverflow Стандартные ошибки в синтаксисе пропущенная / лишняя запятая пропущенная / лишняя / другого типа скобка Object not found опечатки (пропуск буквы, удвоение буквы, разный регистр, c кириллическая) no object / file / function / package Дополнительные материалы textbook.rintro.ru – мой учебник по основам R Курсы на data.camp. Они, как и все онлайн-курсы, несколько дробные и избыточные, но базам конструкций научить могут. На русском языке есть курс на степике. Вполне нормальный, особенно в первых частях. Еще есть курс Тони Антонова, он посложнее, но в чем-то получше и поосновательнее курса Карпова и Иванчея. Мороз Г. А. , Поздняков И. С. - Наука о данных в R для программы Цифровых гуманитарных исследований Селезнёв А. - Язык R для пользователей Excel Long J., Teetor P. - R cookbook Bryan J. - STAT 545 Data wrangling, exploration, and analysis with R Почему не надо использовать setwd() Домашнее задание Организационное / MM Вся коммуникация по курсу будет идти в mattermost. Для того, чтобы войти, перейдите по ссылке: https://mm.upravitelev.info/signup_user_complete/?id=cfm9gfrwstg3jfkybb9t65eo6e Вам предложат, какую версию вы хотите, веб-версию (в браузере) или мобильное приложение. Я лично использую обе, веб как основная. После этого вам предложат форму регистрации, в которой надо будет указать имя (фио или username как в телеграме, я предпочитаю указывать его), email (на него приходят уведомления о непрочитанных сообщения) и пароль. После этого вы окажетесь в основном окне мессенджера. По умолчанию это будет канал Town Square. Вверху справа расположена кнопка редактирования профиля (картинка с первыми буквами имени). Отредактируйте профиль: необходимо указать имя и фамилию (латиницей, в виде Name Family name), по возможности поставьте свою фотографию на аватарку. Слева расположен список каналов и пользователей. Вверху слева есть форма поиска каналов, найдите канал welcome и зайдите в него. В канале welcome напишите несколько слов о себе: тему своей магистерской (если уже известна), какой опыт работы с R и вообще языками программирования, какие ожидания от курса. R Установка R и RStudio установите язык R (https://cran.r-project.org/) установите Rstudio (RStudio: https://www.rstudio.com/products/rstudio/download/) Или воспользуйтесь онлайн-вариантами (Colab / Posit Cloud) RStudio Если используете RStudio (или VS Code / Pycharm / Posit Cloud) – создайте новый проект. При желании – изучите глобальные настройки и настройки проекта в меню Tools. Создайте папку practice. В ней предлагаю хранить скрипты с домашками. В дальнейшем появятся папки seminars, data, lib и другие. Если чувствуете в себе силы, создайте папку practice с помощью кода (надо погуглить соответствующую функцию). Тем, кто использует Jupyter Notebook / Jupyter Lab рекомендую создать отдельную папку по курсу и в ней также создать папку practice. Операторы и создание векторов Задание необязательное, но настоятельно рекомендую прорешать всем, кто ни разу не сталкивался с R или давно все забыл и не уверен в своих знаниях. Если решение какого-то задания вызвало у вас сомнения, напишите мне об этом в личке в mm. При работе используйте гайд по стилю оформления кода. Старайтесь, чтобы код был максимально простым. Если каждое упражнение занимает больше одной-двух строк — скорее всего вы что-то делаете не так. В проекте создайте новый скрипт, назовите его 2023-09-12.R (RStudio предлагает назвать файл при сохранении, а расширение предлагает по умолчанию) в папке practice. Новый скрипт можно создать в меню File &gt; New script, кнопкой вверху слева, комбинацией ctrl+shift+n. Или же в панели внизу справа, где перечислены файлы проекта. Дальнейшие задачи выполняйте в этом скрипте. Создайте объект x со значением 5. Создайте объект y, который равен 3 * x. Выведите его на печать. Проверьте, что значение выражения x - y не равно 84. Запишите в объект alarm результат сравнения, больше ли x чем y. Выведите объект на печать. Симулируйте выпадение какой-либо грани двенадцатигранного кубика (одно значение). Вам потребуется функция sample(). Симулируйте выпадение десяти бросков восьмигранного кубика. Задача решается также с помощью функции sample(). Найдите длину меньшего катета прямоугольного треугольника с катетом длиной 4 и гипотенузой длиной 8, и округлите длину до третьего знака. Вам потребуются оператор возведения в степень и функции sqrt() и round(). На всякий случай напомню, квадрат гипотенузы равен сумме квадратов катетов. "],["vectors.html", "Векторы Запись занятия Векторы Выбор элемента вектора Проверка на NA Домашнее задание", " Векторы Запись занятия Запись занятия 16 сентября: Векторы Простой набор значений одного атомарного типа. Атомарные типы данных numeric (integer для целых и double как аналог numeric). Используется для числовых значений. Некоторые функций, в частности, median() на вход требуют объекты типа numeric. character. Используется для строковых значений. Любой набор знаков, заключенный в кавычки, в R воспринимается как строковое значение. logical. Значения TRUE/FALSE. Создание векторов Чаще всего векторы создаются с помощью функции c() (c от combine). Например: x &lt;- c(1, 3, 5) print(x) ## [1] 1 3 5 Простую неименованную последовательность атомарного типа можно задать также другими командами, наиболее часто используемые из них: seq() — создание последовательности значений в указанном интервале, с заданным шагом (seq от sequence). Например: x &lt;- seq(from = 10, to = 2, by = -2) print(x) ## [1] 10 8 6 4 2 Первые два аргумента задают первое и последнее значения последовательности, а аргумент by - шаг последовательности (по умолчанию равен единице). Знак - для значения аргумента by маркирует, что последовательность убывающая. : — аналог функции seq(), используется для создания последовательности целых чисел, где последующее отличается от предыдущего на 1. Так выражение 5:1 тождественно выражению seq(5, 1, -1). rep() — повтор какого-либо элемента заданное число раз. В качестве элемента может выступать практически любой объект R (в зависимости от осмысленности в целом подобного выражения). Аргументы times или each задают, какое количество раз повторять весь объект или каждый элемент объекта соответственно: x &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) rep(x, times = 2) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; rep(x, each = 2) ## [1] &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; Если значения аргументов задавать позиционно, то первый аргумент — это итерируемый объект, а второй аргумент — аргумент times: rep(x, 2) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; sample() — создание последовательности случайно выбранных значений из какого-то заданного вектора значений. Первый аргумент задает выборку, из которой необходимо извлечь подвыборку, второй аргумент (size) определяет объем извлекаемой выборки. Аргумент replace определяет, выборка извлекается с возвращением элементов или нет: sample(x = 1:5, size = 5, replace = FALSE) ## [1] 5 1 4 3 2 sample(x = 1:5, size = 5, replace = TRUE) ## [1] 1 5 3 2 5 Приведение типов R используется достаточно простая система автоматического преобразования атомарных типов по логике от “самого строгого к самому гибкому”, то есть по цепочке logical -&gt; integer -&gt; numeric -&gt; complex -&gt; character (тип raw не включается в эту систему). Такое преобразование позволяет использовать конструкции вида sum(5 == 5), потому что логический результат сравнения (TRUE) будет преобразован в целое числовое значение (1, так как TRUE преобразовывается в 1, а FALSE - в 0), и, следовательно, можно вычислить количество верных утверждений. Подобные процедуры крайне часто используются когда, например, надо посчитать количество определенных значений в векторе значений (или в колонке в таблице). Вообще, для избежания неожиданных результатов, рекомендуется избегать неявных преобразований и контролировать типы самостоятельно. Примеры приведений типов, все приводится к самому общему: # к строке c(&#39;a&#39;, 3.6, &#39;b&#39;, 5.1, TRUE) ## [1] &quot;a&quot; &quot;3.6&quot; &quot;b&quot; &quot;5.1&quot; &quot;TRUE&quot; # к numeric c(TRUE, 3.6, 2) ## [1] 1.0 3.6 2.0 Выбор элемента вектора Выбор элементов векторов указывается с помощью оператора [ по следующей схеме: x[&lt;condition&gt;]. Это читается как 'элементы вектора x, которые удовлетворяют условию &lt;condition&gt;'. В качестве условия может быть номер элемента в последовательности (индекс), так и какое-то логическое условие. При использовании оператора [ в &lt;condition&gt; может быть передан вектор значений (или логическое выражение, возвращающее вектор значений). Выбор по номеру позиции Простой вариант выбора определенных элементов последовательности - по номеру в последовательности (по индексу, индекс начинается с 1). Например, в последовательности 4, 3, 2 на третьем месте находится значение 2. В коде выбор третьего элемента этой последовательности выглядит вот так: x &lt;- c(4, 3, 2) x[3] ## [1] 2 В список номеров последовательности также можно передавать не только единичное значение, но и вектор значений номеров последовательности, который мы хотим извлечь. Например: x &lt;- c(4, 3, 2, 1) x[c(2, 4)] ## [1] 3 1 Выбор по значению Также возможен выбор элементов вектора, которые удовлетворяют условию. Например, те, которые больше 10, или все, которые равны 3, или все четные. Логика такого выделения следующая: каждый элемент последовательности сравнивается с условием, и если сравнение верное (5 == 5, TRUE), то этот элемент возвращается как подходящий под условие. Фактически метка TRUE здесь является указателем элемента, который надо вернуть, аналогично номеру позиции при выделении по номеру позиции. Например: # создаем вектор 8 случайных значений из массива от 1 до 10 x &lt;- sample(1:10, 8) x ## [1] 10 6 5 4 1 8 2 7 # сравниваем каждое значение с 5, смотрим результат сравнения x_cond &lt;- x &gt; 5 x_cond ## [1] TRUE TRUE FALSE FALSE FALSE TRUE FALSE TRUE # делаем выбор по условию, с указанием вектора, удовлетворяет элемент условию или нет x[x_cond] ## [1] 10 6 8 7 # аналогично, но без создания отдельного вектора x[x &gt; 5] ## [1] 10 6 8 7 Проверка на NA В R есть несколько инструментов для работы с пропущенными или отсутствующими значениями. NA — not avaliable. Ситуация, когда значение пропущено. Например, для какой-то строки в колонке таблицы нет значения. NaN, Inf — not a number и infinite соответственно. Появляются при некорректных с математической точки зрения операциях (например, 0/0 и `1/0’ соответственно). NULL — объект и тип, используется в редких случаях, когда надо создать пустой объект (например x &lt;- NULL, но это плохая практика, для этого есть более корректные способы). Чаще нужен, когда надо удалить колонку в табличке. Для того, чтобы проверить, есть ли пропущенные значения в векторе, используется функция is.na(). Эта функция проверяет, есть ли значение у каждого элемента вектора (является NA или нет) и отдает вектор логических значений, где TRUE означает, что у соответствующего элемента в проверяемом векторе нет значения (он пропущен). # делаем вектор с одним NA-значением x &lt;- c(1, 3, NA, 5) # проверяем каждый элемент на то, пропущен он или нет # видим, что для третьего элемента стоит TRUE, то есть пропущен is.na(x) ## [1] FALSE FALSE TRUE FALSE Функцию is.na() можно точно также использовать для ивзлечения элементов вектора. Например, если мы хотим вернуть все не-пропущенные значения, нам надо воспользоваться оператор логического отрицания !. Этот оператор превращает TRUE в FALSE и наоборот: # смотрим, как работает оператор ! !TRUE ## [1] FALSE # пробуем извлечь все непропущенные значения из x x[!is.na(x)] ## [1] 1 3 5 Домашнее задание Из вектора month.name (уже есть в базовом R, не надо создавать) извлеките пятый элемент. Из вектора month.name извлеките все элементы кроме пятого. Из вектора month.name извлеките первый, пятый и последний элементы. ** Создайте вектор vec из первых семи элементов вектора letters (уже есть в базовом R, не надо создавать), перемешанных в случайном порядке. Примените к нему функцию order(). Проинтерпретируйте результат. *** Отсортируйте вектор vec с использованием order() и без использования sort() Сравните каждый элемент вектора vec &lt;- letters[1:5] с буквой c (равен или нет) и запишите в отдельный векторindices. Выведите indices на печать. Примените indices для выбора элементов вектора vec (vec[indices]). Проинтерпретируйте результат. Из вектора month.name извлеките каждый третий элемент (вам поможет материал первого занятия). Из вектора vec &lt;- sample(10, 8) выберите все элементы, значения которых больше либо равны 5. Из вектора vec &lt;- sample(100, 8) выберите максимальное значение (элемент с максимальным значением). *** Решите предыдущее задание с помощью функции which.max(). Прочитайте справку по функции и найдите “подводный камень”, который потенциально может привести к ошибкам. Попробуйте представить ситуацию, когда может возникнуть такая ошибка (необязательно при работе с векторами, например, при работе с таблицами). Из вектора vec &lt;- sample(100, 8) выберите максимальное и минимальное значения. "],["lists.html", "Списки и таблицы Запись занятия 23 сентября Векторы Векторизованные операции Recycling Изменение элементов объектов Списки Структура объектов Таблицы data.table Создание data.table-таблиц Основная формула dt-синтаксиса Создание data.table-таблиц Выбор строки Дополнительные материалы Домашнее задание", " Списки и таблицы Запись занятия 23 сентября Векторы Поиск по вхождению в массив Нередко встречаются ситуации, когда необходимо выбрать значения вектора, которые присутствуют в другом векторе. Например, из списка группы студентов выбрать тех, кто указан в списке недопущенных к сессии. Для этого используется выражение x %in% y. Оператор %in% проверяет, встречается ли каждый элемент вектора х в векторе y. Как и в сравнении по условию, в результате получается логический вектор, который можно использовать для выделения элементов. Выделенные элементы можно записать в отдельный объект. Например: x &lt;- c(1, 5, 2) y &lt;- seq(0, 10, 2) # сравниваем элементы списков x %in% y ## [1] FALSE FALSE TRUE # выделяем те элементы списка х, которые есть в у x[x %in% y] ## [1] 2 # записываем результат в отдельный объект z &lt;- x[x %in% y] str(z) ## num 2 Поиск по строке Для поиска по строковым записям (например, найти пользователя по ФИО, когда известно только имя) используют функцию grep() или grepl(). Первая функция возвращает номера элементов (или строк), в которых нашлось искомое строковое значение. Вторая функция возвращает результат проверки кадого элемента, включает ли он в себя искомый набор символов. # вектор строковых значений month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; # ищем значения, в которых есть буква r grep(&#39;r&#39;, month.name) ## [1] 1 2 3 4 9 10 11 12 grepl(&#39;r&#39;, month.name) ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE Первый аргумент — это паттерн регулярного выражения (если не используется аргумент fixed = TRUE): vec &lt;- c(&#39;user.1&#39;, &#39;user2&#39;) # в регэкспах точка -- служебный символ, его надо экранировать двумя слэшами vec[grep(&#39;\\\\.&#39;, vec)] ## [1] &quot;user.1&quot; # или указывать, что ищем именно точку, а не регэксп vec[grep(&#39;.&#39;, vec, fixed = TRUE)] ## [1] &quot;user.1&quot; Векторизованные операции Векторизация — наверное, одна из самых примечательных и важных особенностей R как языка программирования и инструмента работы с данными. Фраза векторизованная функция означает, что операции производятся сразу над каждым элементом вектора. То есть там, где в других языках программирования (например, в Python) необходимо писать цикл или лямбда-функцию, в R можно просто передать вектор в аргументы функции. Например, функция round(), если в качестве аргумента использовать вектор значений, округлит до нужного знака каждый элемент вектора: x &lt;- rnorm(5, 0, 1) x ## [1] 0.48938855 -0.66226451 -0.09512536 -0.19306256 -0.31374637 round(x, 3) ## [1] 0.489 -0.662 -0.095 -0.193 -0.314 В какой-то мере к векторизованным операциям можно отнести и простые арифметические операции над векторами. В частности, если мы попробуем сложить или умножить векторы одинаковой длины, то произойдет попарные сумма или произведение элементов векторов: # создаем векторы x &lt;- c(1, 5) y &lt;- c(7, 9) # смотрим значения векторов x ## [1] 1 5 y ## [1] 7 9 # сумма векторов x + y ## [1] 8 14 # произведение векторов x * y ## [1] 7 45 Recycling В том случае, когда в операции используется два вектора разной длины, используется правило ресайклинга (recycling). То есть короткий вектор начинает использоваться с начала, и так до тех пор, пока длины векторов не сойдутся. Например, мы хотим перемножить два вектора разной длины: x &lt;- 1:5 x ## [1] 1 2 3 4 5 y &lt;- c(3, 5, 7) y ## [1] 3 5 7 При перемножении операция элементы каждого вектора берутся попарно. Так как в векторе y всего три элемента, а в векторе x — пять, то элементы вектора y начинают использоваться повторно начиная с самого первого: x * y ## Warning in x * y: longer object length is not a multiple of shorter object ## length ## [1] 3 10 21 12 25 При этом интерпретатор R нам выдаст предупреждение, что длины не совпадают: Warning message: In x * y : longer object length is not a multiple of shorter object length Если использовать два вектора кратной длины (например, 2 и 4 элемента), то короткий вектор будет переиспользован, но предупреждения не будет: x &lt;- c(1, 5) y &lt;- c(1, 2, 3, 4) x * y ## [1] 1 10 3 20 Если учесть, что в R нет скаляров и x &lt;- 5 это создание вектора из одного элемента (единичного вектора), то умножение вектора на какое-то значение — то же самое умножение векторов с переиспользованием короткого вектора. Изменение элементов объектов В задачах на изменение значения элемента векторов, списков или таблиц используется следующая логика - указывается элемент объекта, с которым надо произвести какое-то действие, и этому элементу присваивается новое значение. Например, у нас есть вектор из 10 значений в случайном порядке от 1 до 10, и мы хотим возвести в квадрат третий элемент: # задаем зерно для псевдослучайной генерации set.seed(1234) # создаем вектор x &lt;- sample(10) str(x) ## int [1:10] 10 6 5 4 1 8 2 7 9 3 # возводим в квадрат третий элемент: x[3] &lt;- x[3] ^ 2 str(x) ## num [1:10] 10 6 25 4 1 8 2 7 9 3 Создание новых элементов или удаление уже существующих производятся аналогично - указывается индекс элемента (или его название, если применимо), и присваивается какое-то значение. Для создания элемента - любой объект, если он не нарушает уже существующую структуру (например, в таблице на пять строк нельзя создать колонку с шестью значениями), если в векторе создавать значение иного типа, чем был, то все значения будут преобразованы к более общему по правилам преобразования. # меняем 9 элемент вектора на &#39;x&#39;, текстовый x[9] &lt;- &#39;x&#39; str(x) ## chr [1:10] &quot;10&quot; &quot;6&quot; &quot;25&quot; &quot;4&quot; &quot;1&quot; &quot;8&quot; &quot;2&quot; &quot;7&quot; &quot;x&quot; &quot;3&quot; Для удаления элемента вектора можно просто сделать переприсвоение этому объекту тех же значений, за исключением того, которое требуется удалить: # удалим 3 значение вектора x x &lt;- x[-3] str(x) ## chr [1:9] &quot;10&quot; &quot;6&quot; &quot;4&quot; &quot;1&quot; &quot;8&quot; &quot;2&quot; &quot;7&quot; &quot;x&quot; &quot;3&quot; Списки Список элементов разных типов - векторов, таблиц, атомарных типов, других листов, функций и так далее. Длина и тип объекта в списке значения не имеет. Создание списков Для создания списка используется команда list(), где в аргументах через запятую перечисляются все элементы, которые необходимо включить в лист. Например: x &lt;- seq(from = 13, to = 0, by = -3) y &lt;- rep(x = &#39;c&#39;, times = 3) z &lt;- TRUE my_list &lt;- list(x, y, z) str(my_list) ## List of 3 ## $ : num [1:5] 13 10 7 4 1 ## $ : chr [1:3] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## $ : logi TRUE Именованные списки Помимо простого объединения объектов в списки и последующим вызовом элементов по номеру в списке, можно создавать именованные списки, где каждые элементы будут иметь заданное название. Например, x &lt;- seq(from = 13, to = 0, by = -3) y &lt;- rep(x = &#39;c&#39;, times = 3) z &lt;- TRUE my_list &lt;- list(seq_example = x, rep_example = y, atomic_example = z) print(my_list) ## $seq_example ## [1] 13 10 7 4 1 ## ## $rep_example ## [1] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## ## $atomic_example ## [1] TRUE Выбор элемента списка Выбор элементов списка также использует выбор по номеру элемента. Следует учитывать, что для списков несколько различается поведение операторов [ и [[. Так, оператор [ позволяет выделить элемент списка в виде отдельного списка: # создадим список my_list &lt;- list(seq_example = seq(from = 13, to = 0, by = -3), rep_example = rep(x = &#39;c&#39;, times = 3), atomic_example = TRUE) str(my_list) ## List of 3 ## $ seq_example : num [1:5] 13 10 7 4 1 ## $ rep_example : chr [1:3] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## $ atomic_example: logi TRUE # выберем первый элемент списка first_element &lt;- my_list[1] str(first_element) ## List of 1 ## $ seq_example: num [1:5] 13 10 7 4 1 Оператор [[ позволяет вызвать значения вызываемых элементов списка. Так, my_list[[1]] вызовет не первый элемент в виде списка, а значения первого элемента в виде вектора (как они и были заданы): # выберем значения первого элемента списка first_element_values &lt;- my_list[[1]] str(first_element_values) ## num [1:5] 13 10 7 4 1 Также для именованных списков можно использовать выделение по имени элемента. Для указания элемента списка используется оператор $ и конструкция вида list_name$element_name. Например: # смотрим на список my_list ## $seq_example ## [1] 13 10 7 4 1 ## ## $rep_example ## [1] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## ## $atomic_example ## [1] TRUE # выбираем элемент seq_example str(my_list$seq_example) ## num [1:5] 13 10 7 4 1 Структура объектов Нередко при работе с разными объектами необходимо получить сводную информацию об объекте - класс объекта, иерархию элементов объекта, первые значения каждого элемента и так далее. Для этих целей используется функция str() (от structure), которая выводит каждый элемент объекта в виде вектора значений. Например, при просмотре структуры таблицы iris мы получаем класс объекта (data.frame), количество строк и столбцов, название колонок, тип элементов и первые десять значений каждой колонки: str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... При просмотре структуры списка, который в качестве одного из элементов содержит другой список, точно также отображается каждый элемент списка, его тип, в том числе и типы и элементы вложенного списка. Вложенный список дополнительно выделен точками и отступом: x &lt;- list(e1 = 1:5, e2 = letters[1:5], e3 = list(e31 = rnorm(5), e32 = runif(5))) str(x) ## List of 3 ## $ e1: int [1:5] 1 2 3 4 5 ## $ e2: chr [1:5] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ e3:List of 2 ## ..$ e31: num [1:5] 0.983 -0.622 -0.732 -0.517 -1.751 ## ..$ e32: num [1:5] 0.8106 0.5257 0.9147 0.8313 0.0458 Таблицы Таблица — это набор наблюдений по строкам и пространство признаков этих наблюдений в виде набора колонок. Базовый тип для табли в R - data.frame. На уровне структуры data.frame — это все те же списки, в которых могут храниться разные по типу объекты, однако с требованием равенства длины объектов. Важно: все значения одной колонки могут быть только одного типа (потому что это, по сути, векторы), а не как в Excel, OpenOffice или каком другом табличном процессоре. data.frame vs data.table vs dplyr Несмотря на то, что базовый тип таблиц это data.frame, в настоящее время используются варианты надстроек над этим типом: формат data.table или формат tibble из пактов data.table и dplyr соответственно. Различить их можно по элементам синтаксиса. В частности, data.frame почти всегда использует оператор $ (my_table$my_var), в data.table активно используется оператор :=, а в tibble - оператор %&gt;%. Пример создания таблицы и выбора строки по условию в data.frame: # создаем таблицу set.seed(1234) df &lt;- data.frame( var1 = sample(letters, 5), var2 = sample(1:5, 5) ) # смотрим результат print(df) ## var1 var2 ## 1 p 1 ## 2 v 5 ## 3 e 2 ## 4 l 3 ## 5 o 4 # обращаемся к значениям первой колонки df$var1 ## [1] &quot;p&quot; &quot;v&quot; &quot;e&quot; &quot;l&quot; &quot;o&quot; # выводим все строки, где в колонке var2 значения меньше или равны 3 df[df$var2 &lt;= 3, ] ## var1 var2 ## 1 p 1 ## 3 e 2 ## 4 l 3 Аналогичные операции в tibble-формате: set.seed(1234) library(dplyr) dp &lt;- tibble( var1 = sample(letters, 5), var2 = sample(1:5, 5) ) dp %&gt;% filter(var2 &lt;= 3) ## # A tibble: 3 × 2 ## var1 var2 ## &lt;chr&gt; &lt;int&gt; ## 1 p 1 ## 2 e 2 ## 3 l 3 data.table Преимущества data.table высокая скорость IO / манипуляций (бенчмарки) параллелизация вычислений по умолчанию опирается только на base R лаконичность выражений бережные апдейты забота об обратной совместимости Установка и подключение пакета # устанавливаем пакет (однократно) install.packages(&#39;data.table&#39;) # подключаем пакет (при каждой сессии) library(data.table) Создание data.table-таблиц Создать data.table можно следующим образом (синтаксис немного напоминает создание именованного списка, как и для всех форматов таблиц): # подключаем пакет, если не был подключен ранее library(data.table) ## ## Attaching package: &#39;data.table&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## between, first, last # создаем датасет dt1 &lt;- data.table( month_names = month.name, month_abb = month.abb, month_ord = seq_len(length(month.abb)), is_winter = grepl(&#39;Jan|Dec|Feb&#39;, month.abb) ) print(dt1) ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Основная формула dt-синтаксиса Общая формула data.table выглядит как dataset[выбор строк, операции над колонками, группировка]. То есть, указание, какие строки необходимо выделить, осуществляется в первой части (до первой запятой в синтаксисе data.table). Если нет необходимости выделять какие-то строки, перед первой запятой ничего не ставится. Параметр группировки (как и прочие параметры, кроме i и j - опциональны). Также можно провести параллели с синтаксисом SQL-запроса. В терминах SQL data.table-выражения выглядят как таблица[where, select, group by]. Создание data.table-таблиц Создать data.table можно следующим образом (синтаксис немного напоминает создание именованного списка, как и для всех форматов таблиц): # подключаем пакет, если не был подключен ранее library(data.table) # создаем датасет dt1 &lt;- data.table( month_names = month.name, month_abb = month.abb, month_ord = seq_len(length(month.abb)), is_winter = grepl(&#39;Jan|Dec|Feb&#39;, month.abb) ) print(dt1) ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Выбор строки Выбор строк в data.table осуществляется аналогично выбору элементов в векторе: по номеру строки или по какому-то условию. При выборе по номеру строки также можно указать вектор номеров строк, которые необходимо вернуть. При выборке строки по условию проверяется, удовлетворяет ли условию каждый элемент строки в определенной колонке, и если удовлетворяет, выделяется вся строка. # выбор по одному номеру строки dt1[1, ] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE # выбор по нескольким номерам строк # сначала создаем вектор номеров строк my_rows &lt;- c(2, 5, 8) # выводим строки, которые мы указали в векторе dt1[my_rows] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE # или, аналогично, сразу указываем, какие строки хотим выделить dt1[c(2, 5, 8)] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE Выбор по условию: мы сразу указываем название колонки, к значениям которых будем применять условие-фильтр. Писать в стиле dt1[dt1$month_ord &lt;= 3] избыточно, data.table понимает просто название колонки. # выводим все строки, в которых в колонке month_ord значения меньше или равны 3 dt1[month_ord &lt;= 3] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE Дополнительные материалы Про пакеты и их установку Получение информации об объекте Моя серия вебинаров по data.table. Есть как запись, так и конспект. На занятиях мы будем рассматривать лишь половину или треть материала вебинаров. Базовые операции одновременно в data.table и dplyr-синтаксисе. Много полезных приемов, и, в целом, наглядно. Смотрите блоки по data.table, dplyr синтаксис можно игнорировать или смотреть для общего развития (это весьма часто используемый синтаксис в академии). Перевод документации data.table от Андрея Огурцова. Полезно для понимания разных нюансов работы data.table Продвинутый data.table для желающих, много неочевидных нюансов и трюков. Экзотические возможности и ключевые слова, для совсем экстремалов. Заметка важна в первую очередь внутренними ссылками на разные релевантные и поясняющие ресурсы. Интересный сайт, где каждой конструкции в pandas дана аналогичная конструкция в data.table. Некоторые конструкции, правда, избыточны или переусложнены, но в целом сопоставление адекватное. Домашнее задание векторы Умножьте каждый элемент вектора vec &lt;- sample(10) на 2. Вычислите корень из каждого элемента вектора vec. Округлите значения до второго знака. В принципе для этого достаточно выражения длиной в 16 символов. выполните выражение paste('blabla', 1:3, letters [1:2], month.abb[1:4]). Разберитесь, почему получился такой результат. списки Код ниже создает иллюстрирует дисперсионный анализ. Прочитайте справки по iris и aov. Выполните выражения. # aov_stats &lt;- aov(Sepal.Length ~ Species, iris) aov_stats_summary &lt;- summary(aov_stats) Выведите на печать объект aov_stats_summary. Выведите на печать и проанализируйте структуру объекта. ***Выведите на печать уровень значимости (Pr(&gt;F)) таблицы. импорт данных подключите библиотеку data.table (установите, если не была установлена) скачайте файл titanic3.csv: https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv. с помощью команды titanic &lt;- fread('titanic3.csv') импортируйте файл в рабочее окружение. Прочитайте справку по функции fread() и попробуйте импортировать данные без явного сохранения на диск (не сработает с файлом в слаке). ** попробуйте написать код, в котором сначала происходит сохранение файла на диск, а потом чтение файла в рабочее окружение R (чтобы не руками сохранять, а кодом). посмотрите с помощью команды class() объекта. Если он отличается от data.table — преобразуйте в data.table с помощью функции as.data.table() работа со строками выберите случайным образом 5 строк из таблицы titanic выберите те строки, где возраст пассажира меньше 1 (младенцы) выберите те строки, где возраст пассажира в диапазоне 20 до 50 лет выберите строки по выжившим младенцам (survived) выберите пассажирок, которые имеют титул lady "],["data.table-pt1.html", "data.table pt1 Запись занятия Разбор домашней работы Основная формула dt-синтаксиса Создание data.table-таблиц Выбор строки Работа с колонками .SD (Advanced) Полезные ссылки Домашнее задание", " data.table pt1 Запись занятия Запись занятия 30 сентября: Разбор домашней работы списки Код ниже создает иллюстрирует дисперсионный анализ. Прочитайте справки по iris и aov. Выполните выражения. # aov_stats &lt;- aov(Sepal.Length ~ Species, iris) aov_stats_summary &lt;- summary(aov_stats) Выведите на печать объект aov_stats_summary. Выведите на печать и проанализируйте структуру объекта. ***Выведите на печать уровень значимости (Pr(&gt;F)) Решение. В списке aov_stat_summary неименованный подсписок. Этот подсписок является таблицей (data.frame). Соответственно, сначала нам надо обратиться к неименованному подсписку списка с помощью [[, а потом обратиться к первой строчке пятой колонки. Либо использовать то, что таблицы – это тоже списки, и обратиться к значению в синтаксисе списков, а не колонок. # смотрим структуру объекта str(aov_stats_summary) ## List of 1 ## $ :Classes &#39;anova&#39; and &#39;data.frame&#39;: 2 obs. of 5 variables: ## ..$ Df : num [1:2] 2 147 ## ..$ Sum Sq : num [1:2] 63.2 39 ## ..$ Mean Sq: num [1:2] 31.606 0.265 ## ..$ F value: num [1:2] 119 NA ## ..$ Pr(&gt;F) : num [1:2] 1.67e-31 NA ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;summary.aov&quot; &quot;listof&quot; # используем синтаксис списков aov_stats_summary[[1]]$`Pr(&gt;F)`[1] ## [1] 1.669669e-31 # используем синтаксис data.frame -- первая строка, пятая колонка aov_stats_summary[[1]][1, 5] ## [1] 1.669669e-31 # так как мы умеем работать только с data.table # конвертируем в data.table и извлекаем значение аналогично data.frame library(data.table) aov_stats &lt;- as.data.table(aov_stats_summary[[1]]) str(aov_stats) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 2 obs. of 5 variables: ## $ Df : num 2 147 ## $ Sum Sq : num 63.2 39 ## $ Mean Sq: num 31.606 0.265 ## $ F value: num 119 NA ## $ Pr(&gt;F) : num 1.67e-31 NA ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; # по номеру колонки aov_stats[1, 5] ## Pr(&gt;F) ## 1: 1.669669e-31 # по названию колонки aov_stats[1, `Pr(&gt;F)`] ## [1] 1.669669e-31 таблицы. импорт данных подключите библиотеку data.table (установите, если не была установлена) скачайте файл titanic3.csv: https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv. с помощью команды titanic &lt;- fread('titanic3.csv') импортируйте файл в рабочее окружение. Прочитайте справку по функции fread() и попробуйте импортировать данные без явного сохранения на диск (не сработает с файлом в слаке). # можно импортироватьс разу по ссылке titanic &lt;- fread(&#39;https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv&#39;) ** попробуйте написать код, в котором сначала происходит сохранение файла на диск, а потом чтение файла в рабочее окружение R (чтобы не руками сохранять, а кодом). # можно сохранить объект по ссылка на диск download.file( &#39;https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv&#39;, &#39;titanic_new.csv&#39; ) # и потом прочитать с диска titanic &lt;- fread(&#39;titanic_new.csv&#39;) посмотрите с помощью команды class() объекта. Если он отличается от data.table — преобразуйте в data.table с помощью функции as.data.table() # fread сразу читает в data.table class(titanic) ## [1] &quot;data.table&quot; &quot;data.frame&quot; работа со строками # выберите те строки, где возраст пассажира меньше 1 (младенцы) titanic[age &lt; 1] ## pclass survived name sex age sibsp ## 1: 1 1 Allison, Master. Hudson Trevor male 0.92 1 ## 2: 2 1 Caldwell, Master. Alden Gates male 0.83 0 ## 3: 2 1 Hamalainen, Master. Viljo male 0.67 1 ## 4: 2 1 Richards, Master. George Sibley male 0.83 1 ## 5: 2 1 West, Miss. Barbara J female 0.92 1 ## 6: 3 1 Aks, Master. Philip Frank male 0.83 0 ## 7: 3 1 Baclini, Miss. Eugenie female 0.75 2 ## 8: 3 1 Baclini, Miss. Helene Barbara female 0.75 2 ## 9: 3 0 Danbom, Master. Gilbert Sigvard Emanuel male 0.33 0 ## 10: 3 1 Dean, Miss. Elizabeth Gladys &quot;&quot;Millvina&quot;&quot; female 0.17 1 ## 11: 3 0 Peacock, Master. Alfred Edward male 0.75 1 ## 12: 3 1 Thomas, Master. Assad Alexander male 0.42 0 ## parch ticket fare cabin embarked boat body ## 1: 2 113781 151.5500 C22 C26 S 11 NA ## 2: 2 248738 29.0000 S 13 NA ## 3: 1 250649 14.5000 S 4 NA ## 4: 1 29106 18.7500 S 4 NA ## 5: 2 C.A. 34651 27.7500 S 10 NA ## 6: 1 392091 9.3500 S 11 NA ## 7: 1 2666 19.2583 C C NA ## 8: 1 2666 19.2583 C C NA ## 9: 2 347080 14.4000 S NA ## 10: 2 C.A. 2315 20.5750 S 10 NA ## 11: 1 SOTON/O.Q. 3101315 13.7750 S NA ## 12: 1 2625 8.5167 C 16 NA ## home.dest ## 1: Montreal, PQ / Chesterville, ON ## 2: Bangkok, Thailand / Roseville, IL ## 3: Detroit, MI ## 4: Cornwall / Akron, OH ## 5: Bournmouth, England ## 6: London, England Norfolk, VA ## 7: Syria New York, NY ## 8: Syria New York, NY ## 9: Stanton, IA ## 10: Devon, England Wichita, KS ## 11: ## 12: # выберите те строки, где возраст пассажира в диапазоне 20 до 50 лет titanic[age &gt;= 20 &amp; age &lt;= 50] ## pclass survived name sex ## 1: 1 1 Allen, Miss. Elisabeth Walton female ## 2: 1 0 Allison, Mr. Hudson Joshua Creighton male ## 3: 1 0 Allison, Mrs. Hudson J C (Bessie Waldo Daniels) female ## 4: 1 1 Anderson, Mr. Harry male ## 5: 1 0 Andrews, Mr. Thomas Jr male ## --- ## 722: 3 0 Yasbeck, Mr. Antoni male ## 723: 3 0 Youseff, Mr. Gerious male ## 724: 3 0 Zakarian, Mr. Mapriededer male ## 725: 3 0 Zakarian, Mr. Ortin male ## 726: 3 0 Zimmerman, Mr. Leo male ## age sibsp parch ticket fare cabin embarked boat body ## 1: 29.0 0 0 24160 211.3375 B5 S 2 NA ## 2: 30.0 1 2 113781 151.5500 C22 C26 S 135 ## 3: 25.0 1 2 113781 151.5500 C22 C26 S NA ## 4: 48.0 0 0 19952 26.5500 E12 S 3 NA ## 5: 39.0 0 0 112050 0.0000 A36 S NA ## --- ## 722: 27.0 1 0 2659 14.4542 C C NA ## 723: 45.5 0 0 2628 7.2250 C 312 ## 724: 26.5 0 0 2656 7.2250 C 304 ## 725: 27.0 0 0 2670 7.2250 C NA ## 726: 29.0 0 0 315082 7.8750 S NA ## home.dest ## 1: St Louis, MO ## 2: Montreal, PQ / Chesterville, ON ## 3: Montreal, PQ / Chesterville, ON ## 4: New York, NY ## 5: Belfast, NI ## --- ## 722: ## 723: ## 724: ## 725: ## 726: # выберите строки по выжившим младенцам (survived) titanic[age &lt; 1 &amp; survived == 1] ## pclass survived name sex age sibsp ## 1: 1 1 Allison, Master. Hudson Trevor male 0.92 1 ## 2: 2 1 Caldwell, Master. Alden Gates male 0.83 0 ## 3: 2 1 Hamalainen, Master. Viljo male 0.67 1 ## 4: 2 1 Richards, Master. George Sibley male 0.83 1 ## 5: 2 1 West, Miss. Barbara J female 0.92 1 ## 6: 3 1 Aks, Master. Philip Frank male 0.83 0 ## 7: 3 1 Baclini, Miss. Eugenie female 0.75 2 ## 8: 3 1 Baclini, Miss. Helene Barbara female 0.75 2 ## 9: 3 1 Dean, Miss. Elizabeth Gladys &quot;&quot;Millvina&quot;&quot; female 0.17 1 ## 10: 3 1 Thomas, Master. Assad Alexander male 0.42 0 ## parch ticket fare cabin embarked boat body ## 1: 2 113781 151.5500 C22 C26 S 11 NA ## 2: 2 248738 29.0000 S 13 NA ## 3: 1 250649 14.5000 S 4 NA ## 4: 1 29106 18.7500 S 4 NA ## 5: 2 C.A. 34651 27.7500 S 10 NA ## 6: 1 392091 9.3500 S 11 NA ## 7: 1 2666 19.2583 C C NA ## 8: 1 2666 19.2583 C C NA ## 9: 2 C.A. 2315 20.5750 S 10 NA ## 10: 1 2625 8.5167 C 16 NA ## home.dest ## 1: Montreal, PQ / Chesterville, ON ## 2: Bangkok, Thailand / Roseville, IL ## 3: Detroit, MI ## 4: Cornwall / Akron, OH ## 5: Bournmouth, England ## 6: London, England Norfolk, VA ## 7: Syria New York, NY ## 8: Syria New York, NY ## 9: Devon, England Wichita, KS ## 10: # выберите пассажирок, которые имеют титул lady titanic[grep(&#39;lady&#39;, name, ignore.case = TRUE)] ## pclass survived ## 1: 1 1 ## 2: 1 1 ## 3: 3 1 ## 4: 3 0 ## name sex ## 1: Cherry, Miss. Gladys female ## 2: Duff Gordon, Lady. (Lucille Christiana Sutherland) (&quot;&quot;Mrs Morgan&quot;&quot;) female ## 3: Dean, Miss. Elizabeth Gladys &quot;&quot;Millvina&quot;&quot; female ## 4: Sage, Miss. Constance Gladys female ## age sibsp parch ticket fare cabin embarked boat body ## 1: 30.00 0 0 110152 86.500 B77 S 8 NA ## 2: 48.00 1 0 11755 39.600 A16 C 1 NA ## 3: 0.17 1 2 C.A. 2315 20.575 S 10 NA ## 4: NA 8 2 CA. 2343 69.550 S NA ## home.dest ## 1: London, England ## 2: London / Paris ## 3: Devon, England Wichita, KS ## 4: titanic[grep(&#39;Lady&#39;, name)] ## pclass survived ## 1: 1 1 ## name sex ## 1: Duff Gordon, Lady. (Lucille Christiana Sutherland) (&quot;&quot;Mrs Morgan&quot;&quot;) female ## age sibsp parch ticket fare cabin embarked boat body home.dest ## 1: 48 1 0 11755 39.6 A16 C 1 NA London / Paris # альтернативнй вариант, когда учитываем пробел (&#39; &#39; или &#39;\\\\s&#39;) titanic[grep(&#39;\\\\slady&#39;, name, ignore.case = TRUE)] ## pclass survived ## 1: 1 1 ## name sex ## 1: Duff Gordon, Lady. (Lucille Christiana Sutherland) (&quot;&quot;Mrs Morgan&quot;&quot;) female ## age sibsp parch ticket fare cabin embarked boat body home.dest ## 1: 48 1 0 11755 39.6 A16 C 1 NA London / Paris Основная формула dt-синтаксиса Общая формула data.table выглядит как dataset[выбор строк, операции над колонками, группировка]. То есть, указание, какие строки необходимо выделить, осуществляется в первой части (до первой запятой в синтаксисе data.table). Если нет необходимости выделять какие-то строки, перед первой запятой ничего не ставится. Параметр группировки (как и прочие параметры, кроме i и j - опциональны). Также можно провести параллели с синтаксисом SQL-запроса. В терминах SQL data.table-выражения выглядят как таблица[where, select, group by]. Создание data.table-таблиц Создать data.table можно следующим образом (синтаксис немного напоминает создание именованного списка, как и для всех форматов таблиц): # подключаем пакет, если не был подключен ранее library(data.table) # создаем датасет dt1 &lt;- data.table( month_names = month.name, month_abb = month.abb, month_ord = seq_len(length(month.abb)), is_winter = grepl(&#39;Jan|Dec|Feb&#39;, month.abb) ) print(dt1) ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Выбор строки Выбор строк в data.table осуществляется аналогично выбору элементов в векторе: по номеру строки или по какому-то условию. При выборе по номеру строки также можно указать вектор номеров строк, которые необходимо вернуть. При выборке строки по условию проверяется, удовлетворяет ли условию каждый элемент строки в определенной колонке, и если удовлетворяет, выделяется вся строка. # выбор по одному номеру строки dt1[1, ] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE # выбор по нескольким номерам строк # сначала создаем вектор номеров строк my_rows &lt;- c(2, 5, 8) # выводим строки, которые мы указали в векторе dt1[my_rows] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE # или, аналогично, сразу указываем, какие строки хотим выделить dt1[c(2, 5, 8)] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE Выбор по условию: мы сразу указываем название колонки, к значениям которых будем применять условие-фильтр. Писать в стиле dt1[dt1$month_ord &lt;= 3] избыточно, data.table понимает просто название колонки. # выводим все строки, в которых в колонке month_ord значения меньше или равны 3 dt1[month_ord &lt;= 3] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE Работа с колонками Обращение к колонке В синтаксисе data.table все операции над колонками производятся после первой запятой. Выделение колонок также относится к операциям над колонками. Для выделения одной или нескольких колонок необходимо просто указать лист (список) с названиями колонки или колонок. Если указать название колонки, то будут возвращены значения из этой колонки. Если название обернуть в list(), то будет возвращена таблица, с которой будет одна эта колонка: dt1[, month_names] ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; dt1[, list(month_names)] ## month_names ## 1: January ## 2: February ## 3: March ## 4: April ## 5: May ## 6: June ## 7: July ## 8: August ## 9: September ## 10: October ## 11: November ## 12: December Если посмотреть структуру, то оба объекта будут различаться - вектор строковых значений и таблица соответственно: str(dt1[, month_names]) ## chr [1:12] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; &quot;July&quot; ... str(dt1[, list(month_names)]) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 12 obs. of 1 variable: ## $ month_names: chr &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; Выбор нескольких колонок Если мы хотим на основе большой таблицы создать новую таблицу, с какими-то определенными колонками, мы их можем также перечислить в list(): dt1[, list(month_names, month_abb)] ## month_names month_abb ## 1: January Jan ## 2: February Feb ## 3: March Mar ## 4: April Apr ## 5: May May ## 6: June Jun ## 7: July Jul ## 8: August Aug ## 9: September Sep ## 10: October Oct ## 11: November Nov ## 12: December Dec При таком выделении можно сразу переименовывать колонки. Строго говоря, создается таблица с новой колонкой с требуемым именем, в которую записывается значения колонки, которую надо переименовать. Например: # выделяем в отдельную таблицу колонку month_names, month_abb # колонку month_names переименовываем в new_m_names dt3 &lt;- dt1[, list(new_m_names = month_names, month_abb)] print(dt3) ## new_m_names month_abb ## 1: January Jan ## 2: February Feb ## 3: March Mar ## 4: April Apr ## 5: May May ## 6: June Jun ## 7: July Jul ## 8: August Aug ## 9: September Sep ## 10: October Oct ## 11: November Nov ## 12: December Dec Cоздание колонок Создать новую колонку в синтаксисе data.table можно с помощью оператора :=. Это точно такая же операция над колонками, как и все прочие, просто происходит создание новой колонки: dt1[, new_col := 12:1] dt1 ## month_names month_abb month_ord is_winter new_col ## 1: January Jan 1 TRUE 12 ## 2: February Feb 2 TRUE 11 ## 3: March Mar 3 FALSE 10 ## 4: April Apr 4 FALSE 9 ## 5: May May 5 FALSE 8 ## 6: June Jun 6 FALSE 7 ## 7: July Jul 7 FALSE 6 ## 8: August Aug 8 FALSE 5 ## 9: September Sep 9 FALSE 4 ## 10: October Oct 10 FALSE 3 ## 11: November Nov 11 FALSE 2 ## 12: December Dec 12 TRUE 1 Модификация колонок Оператор := позволяет изменять объект на месте, поэтому мы можем просто колонке присвоить новое значение. Фактически мы на основе старой колонки создаем вектор новых значений и записываем его в в колонку с тем же названием. dt1[, new_col := new_col + 5] dt1 ## month_names month_abb month_ord is_winter new_col ## 1: January Jan 1 TRUE 17 ## 2: February Feb 2 TRUE 16 ## 3: March Mar 3 FALSE 15 ## 4: April Apr 4 FALSE 14 ## 5: May May 5 FALSE 13 ## 6: June Jun 6 FALSE 12 ## 7: July Jul 7 FALSE 11 ## 8: August Aug 8 FALSE 10 ## 9: September Sep 9 FALSE 9 ## 10: October Oct 10 FALSE 8 ## 11: November Nov 11 FALSE 7 ## 12: December Dec 12 TRUE 6 Можно совмещать фильтрацию по строкам и модификацию колонок. Например, для всех строк, где в колонке month_ord значения меньше или равны 5, в колонке new_col проставляем NA: dt1[month_ord &lt;= 5, new_col := NA] dt1 ## month_names month_abb month_ord is_winter new_col ## 1: January Jan 1 TRUE NA ## 2: February Feb 2 TRUE NA ## 3: March Mar 3 FALSE NA ## 4: April Apr 4 FALSE NA ## 5: May May 5 FALSE NA ## 6: June Jun 6 FALSE 12 ## 7: July Jul 7 FALSE 11 ## 8: August Aug 8 FALSE 10 ## 9: September Sep 9 FALSE 9 ## 10: October Oct 10 FALSE 8 ## 11: November Nov 11 FALSE 7 ## 12: December Dec 12 TRUE 6 Удаление колонок Удаление колонок осуществляется схожим образом, просто колонке присваивается значение NULL ## удаление колонок dt1[, new_col := NULL] dt1 ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Вычисления по одной колонке Так как каждая колонка в табличке — это вектор, к ним можно применять все функции, которые могут быть применены к векторам: # при создании новой колонки dt1[, month_ord_sqrt := sqrt(month_ord)] dt1[, new_col_1 := rnorm(.N)] # сэмпл из стандартного нормального распределения dt1[, new_col_2 := runif(.N)] # сэмпл из равномерного распределения # просто при вычислении какого-то значения # вычисление общей длины таблицы dt1[, .N] ## [1] 12 # вычисление среднего значения по какой-то колонке dt1[, mean(new_col_2)] ## [1] 0.5663848 Группировка по нескольким полям Часто возникает необходимость вычислений сразу по нескольким полям. dt2 &lt;- dt1[, list( # всего строк n_rows = .N, # среднее по колонке new_col_1 new_col_1_mn = mean(new_col_1), # медиана по колонке new_col_2 new_col_2_md = median(new_col_2) )] # в результате получаем вторую табличку dt2 ## n_rows new_col_1_mn new_col_2_md ## 1: 12 0.02757375 0.5668681 .SD (Advanced) Также можно выделить колонки таблицы data.table c помощью конструкций .SD и .SDcols. .SD служит ярлыком-указателем на колонки с которыми надо провести какое-то действие, а .SDcols - собственно вектор названий колонок или порядковых номеров колонок в таблице. Если .SDcols не указано, то подразумеваются все колонки таблицы. Оборачивать в list() конструкцию .SD не нужно. Например: # смотрим содержание таблицы dt1[1:5] ## month_names month_abb month_ord is_winter month_ord_sqrt new_col_1 ## 1: January Jan 1 TRUE 1.000000 0.2599800 ## 2: February Feb 2 TRUE 1.414214 0.3075039 ## 3: March Mar 3 FALSE 1.732051 -1.0775026 ## 4: April Apr 4 FALSE 2.000000 0.5020076 ## 5: May May 5 FALSE 2.236068 0.9266806 ## new_col_2 ## 1: 0.85740699 ## 2: 0.12818869 ## 3: 0.04750889 ## 4: 0.97161685 ## 5: 0.98815041 # выделяем первую и третью колонки датасета dt1[1:5, .SD, .SDcols = c(1, 3)] ## month_names month_ord ## 1: January 1 ## 2: February 2 ## 3: March 3 ## 4: April 4 ## 5: May 5 # выделяем эти же колонки по названиям dt1[1:5, .SD, .SDcols = c(&#39;month_names&#39;, &#39;month_abb&#39;, &#39;month_ord&#39;)] ## month_names month_abb month_ord ## 1: January Jan 1 ## 2: February Feb 2 ## 3: March Mar 3 ## 4: April Apr 4 ## 5: May May 5 # выделяем эти же колонки по названиям, но паттерном &#39;month&#39; и использованием grep dt1[1:5, .SD, .SDcols = grep(&#39;month&#39;, names(dt1))] ## month_names month_abb month_ord month_ord_sqrt ## 1: January Jan 1 1.000000 ## 2: February Feb 2 1.414214 ## 3: March Mar 3 1.732051 ## 4: April Apr 4 2.000000 ## 5: May May 5 2.236068 # выделяем эти же колонки по названиям, но паттерном &#39;month&#39; и функцией patterns из пакета data.table dt1[1:5, .SD, .SDcols = patterns(&#39;month&#39;)] ## month_names month_abb month_ord month_ord_sqrt ## 1: January Jan 1 1.000000 ## 2: February Feb 2 1.414214 ## 3: March Mar 3 1.732051 ## 4: April Apr 4 2.000000 ## 5: May May 5 2.236068 .SD используется в большом количестве операций. Например, когда надо провести какую-то одну операцию над сразу несколькими колонками. Например, если мы хотим узнать, какого типа данные лежат в указанных колонках (пример искусственный, в реальности проще воспользоваться str()): dt1[, lapply(.SD, class), .SDcols = c(&#39;month_names&#39;, &#39;month_ord&#39;, &#39;is_winter&#39;)] ## month_names month_ord is_winter ## 1: character integer logical Полезные ссылки Моя серия вебинаров по data.table. Есть как запись, так и конспект. На занятиях мы будем рассматривать лишь половину или треть материала вебинаров. Базовые операции одновременно в data.table и dplyr-синтаксисе. Много полезных приемов, и, в целом, наглядно. Смотрите блоки по data.table, dplyr синтаксис можно игнорировать или смотреть для общего развития (это весьма часто используемый синтаксис в академии). Перевод документации data.table от Андрея Огурцова. Полезно для понимания разных нюансов работы data.table Продвинутый data.table для желающих, много неочевидных нюансов и трюков. Экзотические возможности и ключевые слова, для совсем экстремалов. Заметка важна в первую очередь внутренними ссылками на разные релевантные и поясняющие ресурсы. Интересный сайт, где каждой конструкции в pandas дана аналогичная конструкция в data.table. Некоторые конструкции, правда, избыточны или переусложнены, но в целом сопоставление адекватное. Домашнее задание работа с колонками посчитайте средний возраст пассажиров в датасете titanic аналогично, посчитайте summary() по возрасту женщин выделите в отдельный датасет всех погибших пассажиров, оставьте для них только значения пола, возраста и класса билета (pclass), переменную pclass переименуйте в class ** cделайте это с помощью .SD-синтаксиса и функции setnames() в полученном датасете посчитайте количество пассажиров, их средний и медианный возраст, разброс по возрасту (sd()) *в датасете titanic попробуйте построить логистическую регрессию (lm или glm, обязательно прочитайте справку), которая бы предсказывала вероятность выживания пассажира (survived). Возьмите все переменные как предиктор (формула будет survived ~ .). До решения следующего задания не смотрите на результат. ** Попробуйте выбрать те предикторы, которые вам субъективно кажутся наиболее влияющими на вероятность выживания пассажира. Постройте регрессию по ним. Возможно, вам потребуется синтаксис формул. *** Сравните две модели – и просто по статистикам, и кодом (одна из полезных ссылок, остальные при необходимости погуглите сами) для тех, кто любит посложнее Создайте датасет: несколько пользователей по 5 сессий на каждого пользователя. поле логина, тип – дата и время (таймстамп), все логины в интервале 1-9 сентября. В юникс-формате или просто дата и время, на ваше усмотрение. для каждой сессии создайте случайную длину сессии (достаточно просто вектор длиной со всю таблицу, без учета пользователей) в секундах. Длина сессии должна варьировать в пределах 120 - 600 секунд посчитайте количество пользователей, среднее количество сессий на пользователя, среднюю длину сессий. Без учета вариативности внутри пользователя, overall по всему датасету. Подсказки: датасет лучше создавать в несколько шагов есть полезная функция expand.grid() для генерации времени поможет функция as.POSIXct(), плюс есть немного справочных материалов в учебнике: раз, два ## uid sid login_ts session_length ## 1: user_1 1 2023-09-01 13:07:45 289 ## 2: user_1 2 2023-09-01 15:24:06 510 ## 3: user_1 3 2023-09-02 05:25:24 181 ## 4: user_1 4 2023-09-02 08:26:00 253 ## 5: user_1 5 2023-09-02 12:44:03 473 ## 6: user_2 1 2023-09-04 10:34:49 364 Статистики: ## n_users total_sessions session_per_user session_length_mn ## 1: 3 15 5 356.6 "],["data.table-pt2.html", "data.table pt2 Запись занятия Разбор домашней работы Применение функций Применение функций Агрегации Манипуляции с таблицами Домашнее задание", " data.table pt2 Запись занятия Запись занятия 7 октября: Разбор домашней работы работа с колонками выделите в отдельный датасет всех погибших пассажиров, оставьте для них только значения пола, возраста и класса билета (pclass), переменную pclass переименуйте в class library(data.table) titanic &lt;- fread(&#39;https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv&#39;) titanic_not_survived &lt;- titanic[survived == 0, list(sex, age, class = pclass)] str(titanic_not_survived) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 809 obs. of 3 variables: ## $ sex : chr &quot;female&quot; &quot;male&quot; &quot;female&quot; &quot;male&quot; ... ## $ age : num 2 30 25 39 71 47 NA 24 36 25 ... ## $ class: int 1 1 1 1 1 1 1 1 1 1 ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; в полученном датасете посчитайте количество пассажиров, их средний и медианный возраст, разброс по возрасту (sd()) titanic_not_survived[, list( n_rows = .N, age_mn = mean(age, na.rm = TRUE), age_md = median(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE))] ## n_rows age_mn age_md age_sd ## 1: 809 30.54536 28 13.92255 *в датасете titanic попробуйте построить логистическую регрессию, которая бы предсказывала вероятность выживания пассажира (survived). lm_fit &lt;- glm(survived ~ sex + age + pclass + fare, data = titanic, family = &#39;binomial&#39;) summary(lm_fit) ## ## Call: ## glm(formula = survived ~ sex + age + pclass + fare, family = &quot;binomial&quot;, ## data = titanic) ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 4.5009747 0.4616310 9.750 &lt; 2e-16 *** ## sexmale -2.4899900 0.1669830 -14.912 &lt; 2e-16 *** ## age -0.0336871 0.0062977 -5.349 8.84e-08 *** ## pclass -1.1079840 0.1284987 -8.623 &lt; 2e-16 *** ## fare 0.0006614 0.0017242 0.384 0.701 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 1413.57 on 1044 degrees of freedom ## Residual deviance: 982.81 on 1040 degrees of freedom ## (264 observations deleted due to missingness) ## AIC: 992.81 ## ## Number of Fisher Scoring iterations: 4 для тех, кто любит посложнее Создайте датасет: несколько пользователей по 5 сессий на каждого пользователя. поле логина, тип – дата и время (таймстамп), все логины в интервале 1-9 сентября. В юникс-формате или просто дата и время, на ваше усмотрение. для каждой сессии создайте случайную длину сессии (достаточно просто вектор длиной со всю таблицу, без учета пользователей) в секундах. Длина сессии должна варьировать в пределах 120 - 600 секунд посчитайте количество пользователей, среднее количество сессий на пользователя, среднюю длину сессий. Без учета вариативности внутри пользователя, overall по всему датасету. Подсказки: датасет лучше создавать в несколько шагов есть полезная функция expand.grid() для генерации времени поможет функция as.POSIXct(), плюс есть немного справочных материалов в учебнике: раз, два my_dt &lt;- expand.grid( paste0(&#39;user_&#39;, 1:3), 1:5 ) my_dt &lt;- as.data.table(my_dt) setnames(my_dt, c(&#39;uid&#39;, &#39;sid&#39;)) setkey(my_dt, &#39;uid&#39;) time_seq &lt;- seq(as.POSIXct(&quot;2023-09-01 00:00:00&quot;), as.POSIXct(&quot;2023-09-09 23:59:59&quot;), by = &quot;s&quot;) my_dt[, login_ts := sort(sample(time_seq, .N))] my_dt[, session_length := sample(120:600, .N)] head(my_dt) ## uid sid login_ts session_length ## 1: user_1 1 2023-09-02 03:05:11 568 ## 2: user_1 2 2023-09-02 12:45:43 385 ## 3: user_1 3 2023-09-03 09:01:06 366 ## 4: user_1 4 2023-09-03 10:34:47 134 ## 5: user_1 5 2023-09-03 13:37:23 485 ## 6: user_2 1 2023-09-04 00:24:21 305 Применение функций dataset library(data.table) # импортируем по ссылке sw &lt;- fread(&#39;http://bit.ly/39aOUne&#39;) # смотрим структуру объекта str(sw) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 77 obs. of 6 variables: ## $ name : chr &quot;Luke Skywalker&quot; &quot;C-3PO&quot; &quot;Darth Vader&quot; &quot;Owen Lars&quot; ... ## $ height : int 172 167 202 178 165 97 183 188 163 183 ... ## $ mass : num 77 75 136 120 75 32 84 84 NA NA ... ## $ skin_color : chr &quot;fair&quot; &quot;gold&quot; &quot;white&quot; &quot;light&quot; ... ## $ gender : chr &quot;male&quot; &quot;n/a&quot; &quot;male&quot; &quot;male&quot; ... ## $ planet_name: chr &quot;Tatooine&quot; &quot;Tatooine&quot; &quot;Tatooine&quot; &quot;Tatooine&quot; ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; Применение функций Количество строк и значений: .N, uniqueN В data.table есть пара полезных функций, которые позволяет быстро и лаконично считать количество значений и количество уникальных значений. Считаем количество строк в табличке - для этого используется функция .N (в data.table есть еще несколько функций, которые начинаются с ., но мы их почти не будем касаться). sw[, .N] ## [1] 77 Функция uniqueN() считает количество уникальных значений. Аналогична сочетанию двух функций length() + unique(), просто короче и быстрее. sw[, uniqueN(planet_name)] ## [1] 48 Ветвления: ifelse / fifelse В R есть два вида ветвлений с использованием if. Первое - стандартная для многих языков конструкция if {} else{}, она используется при создании функций и т.д. Для работы с таблицами полезнее функция ifelse() или ее быстрый аналог в data.table - fifelse (f от fast). В первом аргументе функции мы указываем проверку, в результате которой можно будет сказать TRUE или FALSE. Вторым аргументом - что должно быть возвращено, если результат проверки будет TRUE (логическое утверждение из первого аргумента истинно). Третий аргумент - что должно быть возвращено, если утверждение из первого аргумента ложно. Например, мы проверяем, истинно ли, что 5 тождественно 3. Так как 5 не равно трем, результатом сравнения 5 == 3 будет FALSE (утверждение ложно), соответственно, результатом ifelse() будет 'значение если неверно'. 5 == 3 ## [1] FALSE ifelse(5 == 3, &#39;значение если верно&#39;, &#39;значение если неверно&#39;) ## [1] &quot;значение если неверно&quot; Ключевое отличие ifelse() от классического if {} else{} в том, что эта функция векторизована. То есть, если в первом аргументе сравнивать вектор с каким-то значением, то проверка будет применяться к каждому элементу вектора. Соответственно, и результатов ifelse будет столько же, сколько элементов в векторе. my_vec &lt;- c(5, 3, 9) ifelse(my_vec == 3, &#39;значение если верно&#39;, &#39;значение если неверно&#39;) ## [1] &quot;значение если неверно&quot; &quot;значение если верно&quot; &quot;значение если неверно&quot; Все это позволяет использовать ifelse/fifelse для операций над колонками - например, в примере мы проверяем с помощью функции grepl, встречается ли в значениях ячеек в колонке skin_color слово grey. И если встречается - то в новую колонку будет проставлено значение grey, а если не всречается - no grey. sw[, new := fifelse(grepl(&#39;grey&#39;, skin_color), &#39;grey&#39;, &#39;no grey&#39;)] sw[1:10, list(name, skin_color, new)] ## name skin_color new ## 1: Luke Skywalker fair no grey ## 2: C-3PO gold no grey ## 3: Darth Vader white no grey ## 4: Owen Lars light no grey ## 5: Beru Whitesun lars light no grey ## 6: R5-D4 white, red no grey ## 7: Biggs Darklighter light no grey ## 8: Anakin Skywalker fair no grey ## 9: Shmi Skywalker fair no grey ## 10: Cliegg Lars fair no grey Агрегации В синтаксисе data.table есть конструкция by, которая отвечает за примененим операций над колонками отдельно для каждой группы (общая структура выглядит следующим образом: dataset[выбор строк, операции над колонками, группировка]). Общая логика группировки стандартная - split - apply - combine. То есть, датасет разделяется на блоки по значениям группирующей переменной, к колонкам каждого сабсета применяется какое-то выражение, и результат обратно собирается в таблицу. Результатом группировки в data.table всегда будет таблица. Вычисления по одной колонке Можно использовать группировку при применении функции к таблице, но удобнее результат операции с колонкой оборачивать в list(), так как это дает возможность переименовать колонку. В примере ниже мы считаем количество уникальных значений в колонке name для каждой группы по значениям колонки gender: sw[, uniqueN(name), by = gender] ## gender V1 ## 1: male 57 ## 2: n/a 3 ## 3: female 16 ## 4: hermaphrodite 1 sw[, list(n_chars = uniqueN(name)), by = gender] ## gender n_chars ## 1: male 57 ## 2: n/a 3 ## 3: female 16 ## 4: hermaphrodite 1 Вычисления по нескольким колонкам Можно выполнять операции сразу с несколькими колонками: sw[, list( n_chars = uniqueN(name), mass_md = median(mass, na.rm = TRUE) ), by = gender] ## gender n_chars mass_md ## 1: male 57 80.0 ## 2: n/a 3 32.0 ## 3: female 16 52.5 ## 4: hermaphrodite 1 NA Группировка по нескольким полям Часто возникает необходимость группировки сразу по нескольким полям - для этого колонки групп также указываются через список. В выражении ниже мы сначала фильтруем датасет и оставляем только строки, где в колонке gender есть значения male и female, после чего в группах по полу и цвету кожи считаем количество персонажей. Результат агрегации записываем в новый объект и выводим на печать только первые 5 строк (просто чтобы сократить вывод). sw_grps &lt;- sw[gender %in% c(&#39;male&#39;, &#39;female&#39;), list(n_chars = uniqueN(name)), by = list(gender, skin_color)] sw_grps[1:5] ## gender skin_color n_chars ## 1: male fair 12 ## 2: male white 2 ## 3: male light 4 ## 4: female light 5 ## 5: female fair 3 Манипуляции с таблицами rbind() Функция rbind()(от row bind) используется для объединение двух или более таблиц по строкам. То есть, в результате получается таблица с таким же количеством колонок, но с увеличенным числом строк - по количеству строк в объединяемых таблицах. Нередко в объединяемых таблицах отсутствует какая-нибудь колонка или колонки перепутаны. В таких случаях необходимо использовать аргументы use.names = TRUE (проверка названий колонок при объединение) и fill = TRUE (создание колонки с NA-значениями). Обратите внимание, это работает только с data.table-объектами. # создаем первую таблицу dt1 &lt;- data.table(tb = &#39;table_1&#39;, col1 = sample(9, 3), col3 = &#39;only in table1&#39;, col2 = sample(letters, 3)) # создаем вторую таблицу dt2 &lt;- data.table(tb = &#39;table_2&#39;, col4 = &#39;only in table2&#39;, col1 = sample(9, 3), col2 = sample(letters, 3)) # объединяем по строкам rbind(dt1, dt2, fill = TRUE) ## tb col1 col3 col2 col4 ## 1: table_1 3 only in table1 d &lt;NA&gt; ## 2: table_1 7 only in table1 r &lt;NA&gt; ## 3: table_1 9 only in table1 k &lt;NA&gt; ## 4: table_2 7 &lt;NA&gt; f only in table2 ## 5: table_2 9 &lt;NA&gt; w only in table2 ## 6: table_2 3 &lt;NA&gt; o only in table2 cbind() Функция cbind() (от columns bind) используется для объединения нескольких векторов или таблиц равной длины. В результате получается объединённая таблица такой же длины, как каждый из объединяемых векторов. При объединении таблиц — с таким же количеством строк, как в каждой из объединяемых таблиц, и с суммарным количеством колонок. При использовании cbind() в работе с таблицами необходимо помнить, что это буквально “склейка” таблиц независимо от порядка наблюдений по строкам. В противном случае можно получить наблюдение, где часть колонок описывает характеристики этого наблюдения, а другая часть — каких-то других наблюдений. Другой нюанс, который также необходимо учитывать: при объединении таблиц названия колонок останутся прежними. Так что если в нескольких таблицах встречается, например, колонка col1, то в финальном датасете будет несколько колонок с таким названием — по количеству объединяемых таблиц, в которых она была. В свою очередь, это усложняет задачи выбора колонки по названию и мешает понять, в какой колонке какое содержание. # выведем ранее созданные таблицы print(dt1) ## tb col1 col3 col2 ## 1: table_1 3 only in table1 d ## 2: table_1 7 only in table1 r ## 3: table_1 9 only in table1 k print(dt2) ## tb col4 col1 col2 ## 1: table_2 only in table2 7 f ## 2: table_2 only in table2 9 w ## 3: table_2 only in table2 3 o # создадим колонки-номера строк dt1[, indx := 1:.N] dt2[, indx := 1:.N] # теперь отсортируем вторую таблицу по убыванию dt2 &lt;- dt2[order(-indx)] # таблица получилась, но в строках бардак cbind(dt1, dt2) ## tb col1 col3 col2 indx tb col4 col1 col2 indx ## 1: table_1 3 only in table1 d 1 table_2 only in table2 3 o 3 ## 2: table_1 7 only in table1 r 2 table_2 only in table2 9 w 2 ## 3: table_1 9 only in table1 k 3 table_2 only in table2 7 f 1 В целом, cbind() — весьма редко используемый способ объединения таблиц. Его стоит использовать только тогда, когда есть однозначная уверенность в структуре данных (одинаковое количество строк, разные названия колонок, идентичная сортировка и т. д.), в противном случае это место, в котором очень легко ошибиться, при этом эту ошибку будет очень сложно найти. Домашнее задание level 1 (IATYTD) Импортируйте данные по Star Wars, файл по ссылке: http://bit.ly/39aOUne. Посмотрите структуру объекта. Посчитайте, сколько в таблице строк. level 2 (HNTR) создайте копию колонки mass с названием mass_corrected замените все NA в колонке mass_corrected средним значением по группе, группы выделяются по полу и планете (вам потребуется создать промежуточную колонку) level 3 (HMP) изучите справку по функции ifelse() (или fifelse() в data.table) создайте копию колонки gender, назовите ее gender_2. Замените в ней все n/a и hermaphrodite на other. Посчитайте количество персонажей в зависимости от пола (gender_2): ## gender_2 N ## 1: male 57 ## 2: other 4 ## 3: female 16 выполните предыдущее задание без создания промежуточной колонки gender_2 level 4 (UV) сделайте сводную таблицу planet_chars по персонажам каждой планеты, где в колонках будет количество персонажей, их средний рост и вес (оригинальный и скорректированный). округлите значения до 1 знака после запятой Первые 5 строк результата: ## planet_name n_chars height_mn mass_mn mass_corrected_mn ## 1: Tatooine 10 169.8 85.4 85.8 ## 2: Kamino 3 208.3 83.1 83.1 ## 3: Geonosis 1 183.0 80.0 80.0 ## 4: Utapau 1 206.0 80.0 80.0 ## 5: Kashyyyk 2 231.0 124.0 124.0 level 5 (N) Создайте датасет: несколько пользователей (например, 100), должен быть отдельный параметр user_type с значениями short, medium, long от 1 до 10 сессий на каждого пользователя, случайным образом. создайте поле логина, тип – дата и время (таймстамп), все логины в интервале 1-9 сентября. В юникс-формате или просто дата и время, на ваше усмотрение. создайте колонку session_num, которая будет маркировать номер сессии пользователя для каждой сессии создайте случайную длину сессии в секундах. Длина сессии должна варьировать в пределах 120 - 600 секунд. Длина сессии зависит от параметра user_type: short: множитель к длине сессии из интервала (0, 1] (например, 0.27) medium: множитель к длине сессии из интервала (1, 3] (например, 2.51) long: множитель к длине сессии из интервала (5, 7] (например, 6.1) Посчитайте в датасете: количество пользователей среднее количество сессий на пользователя средний среднюю длину сессий средний интервал между концом одной сессии и началом другой сессии (обратите внимание на функцию shift) Расчеты в группах по user_type и total (без группировки). В итоговой таблице должно быть 4 строки и 5 колонок. "],["data.table-pt3.html", "data.table pt3 Запись занятия Разбор домашней работы Манипуляции с таблицами Соотношение list() и := в операциях над колонками. Домашнее задание", " data.table pt3 Запись занятия Запись занятия 14 октября: Разбор домашней работы level 3 (HMP) изучите справку по функции ifelse() (или fifelse() в data.table) создайте копию колонки gender, назовите ее gender_2. Замените в ней все n/a и hermaphrodite на other. Посчитайте количество персонажей в зависимости от пола (gender_2): library(data.table) sw &lt;- fread(&#39;http://bit.ly/39aOUne&#39;) sw[, gender_2 := gender] sw[gender_2 %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), gender_2 := &#39;other&#39;] sw[, .N, by = gender_2] ## gender_2 N ## 1: male 57 ## 2: other 4 ## 3: female 16 выполните предыдущее задание без создания промежуточной колонки gender_2 # два альтернативных решения # sw[gender %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), gender := &#39;other&#39;] sw[, gender := fifelse(gender %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), &#39;other&#39;, gender)] sw[, .N, by = gender] ## gender N ## 1: male 57 ## 2: other 4 ## 3: female 16 level 4 (UV) сделайте сводную таблицу planet_chars по персонажам каждой планеты, где в колонках будет количество персонажей, их средний рост и вес (оригинальный и скорректированный). округлите значения до 1 знака после запятой Первые 5 строк результата: sw[, mass_corrected := mass] sw[, mass_mean := mean(mass, na.rm = TRUE), by = list(planet_name, gender)] sw[is.na(mass), mass_corrected := mass_mean] planet_chars &lt;- sw[, list( n_chars = .N, height_mn = round(mean(height), 1), mass_mn = round(mean(mass, na.rm = TRUE), 1), mass_corrected_mn = round(mean(mass_corrected, na.rm = TRUE), 1) ), by = planet_name] planet_chars[1:5] ## planet_name n_chars height_mn mass_mn mass_corrected_mn ## 1: Tatooine 10 169.8 85.4 85.8 ## 2: Kamino 3 208.3 83.1 83.1 ## 3: Geonosis 1 183.0 80.0 80.0 ## 4: Utapau 1 206.0 80.0 80.0 ## 5: Kashyyyk 2 231.0 124.0 124.0 Манипуляции с таблицами merge() Одна из самых, наверное, важных операций при работе с таблицами - построчное слияние двух или нескольких таблиц. При использовании функции merge() каждому значению в ключевой колонке первой таблицы сопоставляется строка параметров наблюдения другой таблицы, с таким же значением в ключевой колонке, как и в первой таблице. В других языках программирования, в SQL, в частности, аналогичная функция может называться join. Несмотря на сложность формулировки, выглядит это достаточно просто: # создаем датасет 1, в синтасисе data.table dt1 &lt;- data.table(key_col = c(&#39;r1&#39;, &#39;r2&#39;, &#39;r3&#39;), col_num = seq_len(3)) # создаем датасет 2, в синтасисе data.table dt2 &lt;- data.table(key_col = c(&#39;r3&#39;, &#39;r1&#39;, &#39;r2&#39;), col_char = c(&#39;c&#39;, &#39;a&#39;, &#39;b&#39;)) # сливаем построчно по значениям в колонке key_col merge(x = dt1, y = dt2, by = &#39;key_col&#39;) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c Здесь первая таблица задается аргументом x, вторая таблица - аргументом y, а колонка (или колонки), по значениям которой происходит слияние таблиц, задается аргументом by. Если аргумент by не указан, то слияние происходит по тем колонкам, которые имеют одинаковое название в сливаемых таблицах. Притом, таблицы можно сливать по значениям колонок разными именами, тогда надо отдельно указать, по значениям каких колонок в первой и второй таблице происходит слияние, и для этого вместо общего аргумента by используют аргументы by.x и by.y для первой и второй таблицы соответственно. В первом приближении операция слияния merge() похожа на результат работы функции cbind(). Однако, из-за того, что при слиянии происходит сопоставление по значениям ключевых колонок, в результате получается решается проблема слияния колонок, в которых разный порядок строк. Сравните: cbind(dt1, dt2) ## key_col col_num key_col col_char ## 1: r1 1 r3 c ## 2: r2 2 r1 a ## 3: r3 3 r2 b merge(x = dt1, y = dt2, by = &#39;key_col&#39;) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c Второе существенное отличие от cbind() - обработка ситуаций, когда в таблицах разное количество наблюдений. Например, в первой таблице данные по первой волне опросов, а во второй - данные по тем, кто из принявших участие в первой волне, принял участие и во второй волне, а так же какие-то новые опрошенные респонденты. Разное количество наблюдений в сливаемых таблицах порождает четыре варианта слияния, все они задаются аргументом all с постфикасми. Варианты направлений слияния (мерджа) таблиц: all = FALSE. Значение аргумента по умолчанию, в результате слияния будет таблица с наблюдениями, которые есть и в первой, и во второй таблице. То есть, наблюдения из первой таблицы, которым нет сопоставления из второй таблицы, отбрасываются. В примере с волнами это будет таблица только по тем, кто принял участи и в первой, и во второй волнах опросов: # сливаем так, чтобы оставить только тех, кто был в обеих таблицах, это значение по умолчанию merge(x = dt1, y = dt2, by = &#39;key_col&#39;, all = FALSE) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c all.x = TRUE. Всем наблюдениям из первой таблицы сопоставляются значения из второй. Если во второй таблице нет соответствующих наблюдений, то пропуски заполняются NA-значениями (в нашем примере в колонке col2): merge(x = dt1, y = dt2, by = &#39;key_col&#39;, all.x = TRUE) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c all.y = TRUE. Обратная ситуация, когда всем наблюдениям из второй таблицы сопоставляются значения из первой, и пропущенные значения заполняются NA-значениями (в нашем примере в колонке co12): merge(x = dt1, y = dt2, by = &#39;key_col&#39;, all.y = TRUE) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c all = TRUE. Объединение предыдущих двух вариантов - создается таблица по всему набору уникальных значений из ключевых таблиц, по которым происходит слияние. и если в какой-то из таблиц нет соответствующих наблюдений, то пропуски также заполняются NA-значениями: merge(x = dt1, y = dt2, by = &#39;key_col&#39;, all = TRUE) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c При работе с несколькими таблицами можно столкнуться с ограничением, что базовая функциz merge() работает только с парами таблиц. То есть, если вдруг необходимо слить по одному ключу сразу несколько таблиц (например, не две волны опросов, а пять), то придется строить последовательные цепочки попарных слияний. Alarm! Необходимо помнить, что в ситуациях, когда одному значению ключа в первой таблице соответствует одна строка, а во второй таблице - несколько строк, то в результате слияния таблиц значения из первой таблицы размножатся по количеству строк во второй таблице: Создаем данные: # создаем датасет 1, в синтасисе data.table dt1 &lt;- data.table(key_col = c(&#39;r1&#39;, &#39;r2&#39;, &#39;r3&#39;, &#39;r4&#39;, &#39;r1&#39;), col_num = seq_len(5)) # создаем датасет 2, в синтасисе data.table dt2 &lt;- data.table(key_col = c(&#39;r3&#39;, &#39;r1&#39;, &#39;r2&#39;, &#39;r5&#39;, &#39;r1&#39;, &#39;r1&#39;), col_char = c(&#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;)) Тут мы видим, что в первой таблице есть две строки с key_col = r1, а во второй таблице – три строки. Сливаем и получаем размножение значений из первой таблицы для ключа key_col = r1, значения 1 и 5 из колонки col1 теперь встречается три раза. А значения a, e и f встречаются по два раза: merge(dt1, dt2, by = &#39;key_col&#39;, all.x = TRUE) ## key_col col_num col_char ## 1: r1 1 a ## 2: r1 1 e ## 3: r1 1 f ## 4: r1 5 a ## 5: r1 5 e ## 6: r1 5 f ## 7: r2 2 b ## 8: r3 3 c ## 9: r4 4 &lt;NA&gt; То есть три значения из второй таблицы повторились для каждого значения из первой таблицы. В результате у нас получилось шесть строк. long / wide-форматы данных Обычная форма представления данных в таблицах — когда одна строка является одним наблюдением, а в значениях колонок отражены те или иные характеристики этого наблюдения. Такой формат традиционно называется wide-форматом, потому что при увеличении количества характеристик таблица будет расти вширь, путем увеличения числа колонок. Пример таблицы в wide-формате. # создаем таблицу с идентификатором респондента, его возрастом, ростом и весом dt_wide &lt;- data.table( wave = paste0(&#39;wave_&#39;, rep(1:2, each = 2)), id = paste0(&#39;id_&#39;, rep(1:2)), age = c(45, 68, 47, 69), height = c(163, 142, 164, 140), weight = c(55, 40, 50, 47)) dt_wide ## wave id age height weight ## 1: wave_1 id_1 45 163 55 ## 2: wave_1 id_2 68 142 40 ## 3: wave_2 id_1 47 164 50 ## 4: wave_2 id_2 69 140 47 Тем не менее, нередко встречается другой формат, в котором на одно наблюдение может приходиться несколько строк (по количеству измеренных характеристик этого наблюдения). В таком случае таблица состоит из колонки, в которой содержится какой-то идентификатор объекта, одной или нескольких колонок, в которых содержатся идентификаторы характеристик объекта, и колонки, в которой содержатся значения этих характеристик. Такой формат называется длинным, long-форматом данных, потому что при увеличении количества измеряемых характеристик таблица будет расти в длину увеличением строк. # создаем таблицу с идентификатором респондента, его возрастом, ростом и весом dt_long &lt;- data.table( # две волны, по два респондента в каждой wave = paste0(&#39;wave_&#39;, rep(1:2, each = 6)), # на каждого респондента задаем три строки id = paste0(&#39;id_&#39;, rep(rep(1:2, each = 3), 2)), # три характеристики повторяем для четырех респондентов variable = rep(c(&#39;age&#39;, &#39;height&#39;, &#39;weight&#39;), 4), # задаем значения характеристик, с учетом того, как упорядочены первые две колонки value = c(45, 163, 55, 68, 142, 40, 47, 164, 50, 69, 140, 47)) dt_long ## wave id variable value ## 1: wave_1 id_1 age 45 ## 2: wave_1 id_1 height 163 ## 3: wave_1 id_1 weight 55 ## 4: wave_1 id_2 age 68 ## 5: wave_1 id_2 height 142 ## 6: wave_1 id_2 weight 40 ## 7: wave_2 id_1 age 47 ## 8: wave_2 id_1 height 164 ## 9: wave_2 id_1 weight 50 ## 10: wave_2 id_2 age 69 ## 11: wave_2 id_2 height 140 ## 12: wave_2 id_2 weight 47 dcast() Для того, чтобы трансформировать long-формат в wide-формат, используется функция dcast() пакета data.table (либо cast() пакета reshape2). Также можно использовать функцию reshape() из базового набора функций R, однако эта функция достаточно медленная по скорости работы. Для того, чтобы превратить созданную выше таблицу в long-формате в широкий формат, выражение будет выглядеть следующим образом (сама операция называется решейп): dcast(data = dt_long, formula = wave + id ~ variable, value.var = &#39;value&#39;) ## wave id age height weight ## 1: wave_1 id_1 45 163 55 ## 2: wave_1 id_2 68 142 40 ## 3: wave_2 id_1 47 164 50 ## 4: wave_2 id_2 69 140 47 Здесь аргумент data - определяет таблицу, которую мы хотим трансформировать. Аргумент formula задает, что в результирующей таблице будет задавать уникальное наблюдение, и значения какой колонки будут разделены на самостоятельные колонки. Формулу можно прочитать как строки ~ колонки в результирующей таблице. В нашем случае уникальное наблюдение мы задаем парой переменных wave и id, поэтому мы их указываем до тильды через +. Колонки же мы создаем по значениям переменной variable, после тильды. Следует отметить, что ситуация, когда строка задается несколькими переменными через оператор +, весьма частая, а вот в правой части формулы несколько переменных встречаются достаточно редко, обычно все же на колонки раскладывают по значениям одной переменной. Аргумент value.var содержит текстовое название переменной, значения которой будут отражены в результирующей таблице по колонкам для каждого наблюдения. Иногда случаются ситуации, когда необходимо провести сначала агрегацию по одной из колонок, описывающих наблюдение. Например, вычислить средние значения возраста, роста и веса для каждой волны. Это можно сделать в два этапа - сначала провести агрегацию, и потом решейп. Также можно сразу сделать решейп, и воспользоваться дополнительным аргументом fun.aggregate, который сразу, при решейпе, агрегирует данные. Например, если использовать сначала агрегацию, а потом трансформацию в wide-формат: # агрегируем наблюдения по волнам и характеристикам tmp &lt;- dt_long[, list(value = mean(value)), by = list(wave, variable)] tmp ## wave variable value ## 1: wave_1 age 56.5 ## 2: wave_1 height 152.5 ## 3: wave_1 weight 47.5 ## 4: wave_2 age 58.0 ## 5: wave_2 height 152.0 ## 6: wave_2 weight 48.5 # трансформируем в wide-формат. колонки id уже нет в таблице, поэтому удаляем из формулы dcast(data = tmp, formula = wave ~ variable, value.var = &#39;value&#39;) ## wave age height weight ## 1: wave_1 56.5 152.5 47.5 ## 2: wave_2 58.0 152.0 48.5 Аналогично, но с использованием аргумента fun.aggregate. В значения аргумента передаём название функции без кавычек и скобок, в нашем случае это fun.aggregate = mean: dcast(data = tmp, formula = wave ~ variable, value.var = &#39;value&#39;, fun.aggregate = mean) ## wave age height weight ## 1: wave_1 56.5 152.5 47.5 ## 2: wave_2 58.0 152.0 48.5 melt() Обратная трансформация также возможна, из wide-формата в long-формат. Для этого используется функция melt(): melt(data = dt_wide, id.vars = c(&#39;wave&#39;, &#39;id&#39;), measure.vars = c(&#39;age&#39;, &#39;height&#39;, &#39;weight&#39;), variable.name = &#39;variable&#39;, value.name = &#39;value&#39;) ## wave id variable value ## 1: wave_1 id_1 age 45 ## 2: wave_1 id_2 age 68 ## 3: wave_2 id_1 age 47 ## 4: wave_2 id_2 age 69 ## 5: wave_1 id_1 height 163 ## 6: wave_1 id_2 height 142 ## 7: wave_2 id_1 height 164 ## 8: wave_2 id_2 height 140 ## 9: wave_1 id_1 weight 55 ## 10: wave_1 id_2 weight 40 ## 11: wave_2 id_1 weight 50 ## 12: wave_2 id_2 weight 47 Здесь аргумент id.vars задает переменные, которые будут использоваться для уникальной идентификации наблюдения. Аргумент measure.vars определяет те колонки, которые войдут длинную таблицу как значения переменной характеристик наблюдений (когда каждая строка — отдельная характеристика наблюдения, несколько строк на одного пользователя). Аргументы variable.name и value.name задают, соответственно, названия колонок характеристик наблюдения и значений этих характеристик в финальной таблице. Соотношение list() и := в операциях над колонками. На занятии я заметил, что многие путаются в синтаксисе создания новых колонок и в выражении list(). Различие следующее: sw[, new_value := &#39;bla-bla-bla&#39;] sw[1:5] ## name height mass skin_color gender planet_name gender_2 ## 1: Luke Skywalker 172 77 fair male Tatooine male ## 2: C-3PO 167 75 gold other Tatooine other ## 3: Darth Vader 202 136 white male Tatooine male ## 4: Owen Lars 178 120 light male Tatooine male ## 5: Beru Whitesun lars 165 75 light female Tatooine female ## mass_corrected mass_mean new_value ## 1: 77 100.2 bla-bla-bla ## 2: 75 53.5 bla-bla-bla ## 3: 136 100.2 bla-bla-bla ## 4: 120 100.2 bla-bla-bla ## 5: 75 75.0 bla-bla-bla Здесь выражение sw[, new_value := 'bla-bla-bla'] можно прочитать как в таблице sw создай новую колонку new_value и запиши в нее значение 'bla-bla-bla'. Одинарное значение будет размножено по количеству строк. Вместо 'bla-bla-bla' также может быть и какая-нибудь функция, которая создает вектор такой же длины, сколько строк в таблице (если больше или меньше, то выдаст ошибку): # в таблице 77 строк, поэтому можем просто указать 77:1 sw[, new_value2 := 77:1] sw[1:5] ## name height mass skin_color gender planet_name gender_2 ## 1: Luke Skywalker 172 77 fair male Tatooine male ## 2: C-3PO 167 75 gold other Tatooine other ## 3: Darth Vader 202 136 white male Tatooine male ## 4: Owen Lars 178 120 light male Tatooine male ## 5: Beru Whitesun lars 165 75 light female Tatooine female ## mass_corrected mass_mean new_value new_value2 ## 1: 77 100.2 bla-bla-bla 77 ## 2: 75 53.5 bla-bla-bla 76 ## 3: 136 100.2 bla-bla-bla 75 ## 4: 120 100.2 bla-bla-bla 74 ## 5: 75 75.0 bla-bla-bla 73 Выражение sw[, new_value2 := 77:1] можно прочитать как в таблице sw создай новую колонку new_value2 и запиши в нее вектор, который получится в результате выполнения выражения 77:1. Конструкция с list() используется тогда, когда на основе существующей таблицы надо создать новую таблицу. Фактически это создание нового списка на основе колонок таблицы, просто в результате будет таблица и класс data.table: new_dt &lt;- sw[, list(total_users = uniqueN(name), height_mn = mean(height, na.rm = TRUE))] new_dt ## total_users height_mn ## 1: 77 176.2078 Здесь выражение new_dt &lt;- sw[, list(total_users = uniqueN(name), height_mn = mean(height, na.rm = TRUE))] можно прочитать следующим образом: на основе таблицы sw создай таблицу, в которой в колонку total_users запиши количество уникальных значений из колонки name, а в height_mn - среднее значение по колонке height Полученную таблицу запиши в объект new_dt. Надо помнить, что total_users и height_mn - это колонки, которые будут в новой таблице, в sw их нет. Соответственно, использовать := вместе с list() некорректно. Точно также использовать знак = неправильно для создания новых колонок в уже существующей таблице, интерпретатор вернет ошибку. Домашнее задание level 1 (IATYTD) Посчитайте, сколько пользователей (user_pseudo_id) в приложение, с разбивкой по платформам (platform). Датасет: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/installs.csv ## platform n_users ## 1: ANDROID 86112 ## 2: IOS 39484 Проверьте, нет ли дублей в таблице (когда несколько записей на одного пользователя). Подумайте, как можно от них избавиться. level 2 (HNTR) Посчитайте, сколько было платящих пользователей (n_payers), сколько они сделали платежей (n_purchases) и на какую сумму (gross), сколько в среднем сделал платежей каждый пользователь (purchases_per_user), средний размер платежа (purchase_mn) и сколько в среднем заплатил каждый пользователь (ARPPU). Датасет: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/payments_custom.csv ## n_payers gross n_purchases purchases_per_user purchase_mn ARPPU ## 1: 7228 291734.2 35585 4.92 8.2 40.362 level 3 (HMP) Сделайте предыдущее задание, только добавьте разбивку по платформам. Добавьте total (то есть статистику по всей выборке, без разбивки). ## platform n_payers gross n_purchases purchases_per_user purchase_mn ARPPU ## 1: ANDROID 3420 95069 12752 3.73 7.46 27.798 ## 2: IOS 3808 196665 22833 6.00 8.61 51.645 ## 3: All 7228 291734 35585 4.92 8.20 40.362 level 4 (UV) Сделайте предыдущее задание, только добавьте разбивку по полю media_source из таблицы инсталлов (для сопоставления нужен user_pseudo_id). Имейте в виду, в payments все платежи, а нам нужны только по тем пользователям, кто установил приложение (т.е. есть в таблице installs) Пропущенные значения и other в поле media_source перекодируйте в organic. Аналогично, добавьте total. ## media_source n_payers gross n_purchases purchases_per_user purchase_mn ## 1: organic 1329 60673 6742 5.07 9.00 ## 2: unityads_int 273 7783 1176 4.31 6.62 ## 3: applovin_int 1190 51544 6203 5.21 8.31 ## 4: Facebook Ads 54 1051 118 2.19 8.91 ## 5: googleadwords_int 169 5367 643 3.80 8.35 ## 6: All 3015 126418 14882 4.94 8.49 ## ARPPU ## 1: 45.653 ## 2: 28.510 ## 3: 43.314 ## 4: 19.468 ## 5: 31.756 ## 6: 41.930 level 5 (N) Возьмите пользователей, которые пришли в июне. Оставьте только те платежи, которые были сделаны в период первых 30 дней от инсталла (pay_dt - install_dt &lt; 30). Метрика количества дней от инсталла называется лайфтайм (lifetime). Создайте таблицу, в которой будет всего пользователей, установивших приложение, все из монетизационные метрика (из level 2) + доля платящих от общего числа пользователей (conversion) и средний платеж каждого пользователя когорты, независимо, платящий он или нет (ARPU). У меня в результатах почищены данные по инсталлам. ## media_source total_users n_payers gross conversion ARPU ARPPU ## 1: Facebook Ads 1297 53 884.43 0.041 0.68 16.687 ## 2: applovin_int 36714 1115 38133.02 0.030 1.04 34.200 ## 3: googleadwords_int 7767 160 4302.90 0.021 0.55 26.893 ## 4: organic 43070 1000 38867.72 0.023 0.90 38.868 ## 5: unityads_int 21932 263 6099.07 0.012 0.28 23.190 ## n_purchases purchases_per_user purchase_mn ## 1: 101 1.91 8.76 ## 2: 4529 4.06 8.42 ## 3: 509 3.18 8.45 ## 4: 4336 4.34 8.96 ## 5: 969 3.68 6.29 "],["dt-etl.html", "dt + ETL Запись занятия Разбор домашней работы ETL Дополнительная литература Домашнее задание", " dt + ETL Запись занятия Запись занятия 21 октября: Разбор домашней работы level 3 (HMP) создайте копию колонки gender, назовите ее gender_2. Замените в ней все n/a и hermaphrodite на other. Посчитайте количество персонажей в зависимости от пола (gender_2): library(data.table) sw &lt;- fread(&#39;http://bit.ly/39aOUne&#39;) sw[, gender_2 := gender] sw[gender_2 %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), gender_2 := &#39;other&#39;] выполните предыдущее задание без создания промежуточной колонки gender_2 # два альтернативных варианта # sw[gender %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), gender := &#39;other&#39;] sw[, gender := fifelse(gender %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), &#39;other&#39;, gender)] level 4 (UV) сделайте сводную таблицу planet_chars по персонажам каждой планеты, где в колонках будет количество персонажей, их средний рост и вес (оригинальный и скорректированный). округлите значения до 1 знака после запятой Первые 5 строк результата: sw[, mass_corrected := mass] sw[, mass_mean := mean(mass, na.rm = TRUE), by = list(planet_name, gender)] sw[is.na(mass), mass_corrected := mass_mean] planet_chars &lt;- sw[, list( n_chars = uniqueN(name), # или n_chars = .N height_mn = round(mean(height), 1), mass_mn = round(mean(mass, na.rm = TRUE), 1), mass_corrected_mn = round(mean(mass_corrected, na.rm = TRUE), 1) ), by = planet_name] planet_chars[1:5] ## planet_name n_chars height_mn mass_mn mass_corrected_mn ## 1: Tatooine 10 169.8 85.4 85.8 ## 2: Kamino 3 208.3 83.1 83.1 ## 3: Geonosis 1 183.0 80.0 80.0 ## 4: Utapau 1 206.0 80.0 80.0 ## 5: Kashyyyk 2 231.0 124.0 124.0 ETL Чтение и запись текстовых файлов В работе аналитики чаще всего сталкиваются с данными, которые хранятся в простом текстовом формате (txt, разделители строк \\n, \\r или \\n\\r ) и основанном на них табличных форматах csv (с разделителями , или ;) или tsv (\\t). Построчное чтение При работе с текстами проще всего читать файлы построчно - весь текст импортируется как вектор строковых значений, а элементы этого вектора - блоки текста, ограниченные переносами строк. Это удобно при импорте текстов, в которых есть смысловые блоки, как в художественных и поэтических текстах. Точно также построчное чтение может быть использовано для импорта файлов с ошибками или даже, в особо экзотических случаях, для чтения скриптов. Для построчного чтения обычно используется функция readLines() базового пакета или аналогичные ей. С помощью аргументов функции можно указать, сколько необходимо прочитать строк, задать кодировку и что делать, если в файле меньше строк, чем было задано. Прочитаем первые несколько строк текста песни: txt_lines &lt;- readLines(&#39;./data/oxxy_gorgorod.txt&#39;, n = 5) txt_lines ## [1] &quot;####&quot; ## [2] &quot;Незаметно поправь её&quot; ## [3] &quot;Одеяло, за это себя предавая анафеме&quot; ## [4] &quot;Она вышла из пены&quot; ## [5] &quot;Худой отпечаток плеча оставляя на кафеле&quot; Чтение текстовых файлов: read.table() и fread() Для чтения текстовых файлов, которые содержат в табличном формате, в базовом R есть функция read.table() и функции-обертки, которые обращаются к ней, но с другими значениями аргументов по умолчанию (read.csv(), read.csv2, read.delim(), read.delim2()). Табличный формат предполагает наличие строк и колонок в файле, выделенные разделителями строк и полей соответственно, при этом формат файла может быть как txt, так и csv. Несмотря на всю видимую простоту, при импорте табличных форматов можно столкнуться с очень большим количеством нетривиальных проблем. В немалой части это можно назвать следствием их широкой распространенности - практически все современные текстовые процессоры умеют работать с csv-файлами, экспорт из баз данных также нередко делается в csv. Ко всему прочему, текстовые форматы хорошо сжимаются при архивации. К наиболее частым сложностям, которые возникают при импорте текстовых файлов можно отнести следующие: неожиданные разделители (например, экспорт из MS Excel в csv создает файл с разделителем ;) лишние или пропущенные разделители строк или колонок (\\t\\t вместо \\t), что создает разное количество колонок в таблице несоответствие файла расширению или вообще отсутствие расширения нестандартные кодировки, в том числе проблемы их импорта при работе в Windows наличие embedded nuls (\\0) или метки порядка байтов (bite order marks, BOM) наличие символов \"\"\"\", //// и прочих технических символов мета-данные (запись о дате и источнике данных) в первых строках файла Большинство этих нюансов решается при настройке параметров импорта с помощью аргументов функций импорта (т.е., настройки по умолчанию не справляются). В частности, в функциях чтения таблиц можно задать разделители полей и десятичные разделители (sep и dec), кодировку файла и отображения, обработку пустых строк и т.д. Некоторые проблемы, например, импорт данных с embedded nuls постепенно решаются в новых версиях функций и пакетов. Помимо этих аргументов также очень полезны аргументы, которые позволяют прямо указать, сколько строк импортировать (или пропустить от начала), какие типы данных в колонках и какие колонки стоит пропустить, а также - надо ли конвертировать в факторы строковые значения. Из других не очень очевидных нюансов стоит отметить, что функция read.table() удобна, так как обладает большим набором аргументов, а также устойчива к некоторым ошибкам в данных. Однако импорт данных с ее помощью весьма нетороплив, что ощутимо сказывается при импорте больших таблиц. Поэтому лучше использовать аналогичные функции других пакетов, в частности, data.table::fread(), аргументы которой очень похожи на аргументы read.table(). Запись данных в текстовые файлы: write.table() и fwrite() Запись данных в текстовые форматы также может вестись как построчно, так и сразу всей таблицей. Для записи построчно обычно используется функция writeLines(). Запись таблиц происходит аналогичным образом, с помощью функции write.table() или ее аналогом в других пакетах (в частности, более быстрый вариант data.table::fwrite()). С помощью аргументов можно задать как типы разделителей (строк, полей и десятичные разделители), так и кодировку. Обычно рекомендуется выставлять аргумент row.names = FALSE, чтобы в файл не были записаны отдельной колонкой названия (номера) строк. Чтение файлов MS Excel В отличие от простых форматов типа .csv, файлы, созданные в MS Excel импортировать не так просто. Ситуация также осложняется тем, что форматы .xls и .xlsx сильно различаются по внутренней структуре. Часть пакетов, которые обеспечивают взаимодействие с Excel-файлами, требуют установки языка Java (java development kit) в систему и соответствующих R-пакетов (rJava, в частности) - самые часто используемые пакеты тут XLconnect и xlsx. Тем не менее, в большинстве случаев необходим только прочитать файл, и тут могут быть полезны пакеты пакеты openxlsx и readxl, не требующие установки jdk. Пакет openxlsx к тому же умеет еще и записывать файлы в .xlsx, как XLconnect, в том числе и с условным форматированием ячеек. Чтение файлов Пакет readxl, по наблюдениям, чуть быстрее читает файлы, чем openxlsx или пакеты, требующие Java, поэтому рассмотрим здесь его. В целом, функционал пакетов достаточно схож и то, что может readxl, практически всегда можно реализовать и в других пакетах, и наоборот. Основные функции пакета - read_xls() для чтения файлов MS Excel, созданных в версиях до MS Excel 2007, read_xlsx() - для чтения файлов, созданных в более современных версиях, также есть обобщающая функция read_excel(), которая по расширению файла определяет, какую из этих функций надо использовать. Пакет readxl принадлежит к экосистеме tideverse, поэтому импортированные таблицы имеют класс tibble и data.frame. Соответственно, если работать в data.table, необходимо их отдельно преобразовать Вот так выглядит исходный файл в MS Excel: Импортируем файл: library(readxl) # читаем файл path &lt;- &#39;./data/xls_example.xlsx&#39; xlsx_data &lt;- read_xlsx(path) str(xlsx_data) ## tibble [7 × 5] (S3: tbl_df/tbl/data.frame) ## $ company : chr [1:7] &quot;xxx&quot; &quot;xxx&quot; &quot;xxx&quot; &quot;yyy&quot; ... ## $ item_code: num [1:7] 20000559 20000779 13117 40000289 40000274 ... ## $ barcode : num [1:7] 4.60e+12 4.60e+12 4.61e+12 3.57e+12 3.57e+12 ... ## $ amount : num [1:7] 3 4 2 6 2 1 9 ## $ price : num [1:7] 480.3 26.9 353.8 207.6 174.8 ... xlsx_data ## # A tibble: 7 × 5 ## company item_code barcode amount price ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 xxx 20000559 4601026307584 3 480. ## 2 xxx 20000779 4603182002259 4 27.0 ## 3 xxx 13117 4607072020156 2 354. ## 4 yyy 40000289 3574661287522 6 208. ## 5 yyy 40000274 3574661287539 2 175. ## 6 zzz 10000581 4602196002682 1 537. ## 7 zzz 20000458 4601026308567 9 371. При импорте можно указать тип колонок. Делается это с помощью аргумента col_types, в который необходимо передать вектор такой же длины, сколько колонок, состоящий из значений logical, numeric, date, text или list. К сожалению, в отличие от схожего аргумента colClasses в функциях импорта csv/xlsx-файлов (read.table(), read.csv(), data.table::fread(), openxlsx::read.xlsx и проч.), в readxl названия типов не соответствуют названиям атомарных типов данных в R. Если для col_types указать NULL или guess, то тип будет выбран на основе анализа минимум 1000 строк (или всех строк, если датасет меньше 1000 строк). Также можно указать вектор типов длиной не по количеству колонок, а только из одного значения, то все колонки будут импортированы в этом типе. Значение skip указывает, что эту колонку не надо импортировать. # читаем файл с указанием типа text для всех колонок xlsx_data &lt;- read_xlsx(path, col_types = &#39;text&#39;) xlsx_data ## # A tibble: 7 × 5 ## company item_code barcode amount price ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 xxx 20000559 4601026307584 3 480.26 ## 2 xxx 20000779 4603182002259 4 26.95 ## 3 xxx 13117 4607072020156 2 353.76 ## 4 yyy 40000289 3574661287522 6 207.55 ## 5 yyy 40000274 3574661287539 2 174.81 ## 6 zzz 10000581 4602196002682 1 537.46 ## 7 zzz 20000458 4601026308567 9 370.7 Частичное чтение файла Большинство xlsx-файлов содержит несколько непустых листов. По умолчанию функции импорта читают только первый лист, остальные же игнорируются. Пакеты типа XLConnect могут читать весь файл в отдельный объект. Для чтения названий листов xlsx-файла можно воспользоваться функцией readxl::excel_sheets() и полученный вектор потом циклом или через lapply() передать в функцию импорта: # читаем список листов файла sheets &lt;- readxl::excel_sheets(path) sheets ## [1] &quot;Sheet1&quot; &quot;Sheet2&quot; # читаем все листы в список и смотрим структуру file_str &lt;- lapply(sheets, function(x) read_xlsx(path, sheet = x)) str(file_str) ## List of 2 ## $ : tibble [7 × 5] (S3: tbl_df/tbl/data.frame) ## ..$ company : chr [1:7] &quot;xxx&quot; &quot;xxx&quot; &quot;xxx&quot; &quot;yyy&quot; ... ## ..$ item_code: num [1:7] 20000559 20000779 13117 40000289 40000274 ... ## ..$ barcode : num [1:7] 4.60e+12 4.60e+12 4.61e+12 3.57e+12 3.57e+12 ... ## ..$ amount : num [1:7] 3 4 2 6 2 1 9 ## ..$ price : num [1:7] 480.3 26.9 353.8 207.6 174.8 ... ## $ : tibble [3 × 2] (S3: tbl_df/tbl/data.frame) ## ..$ company: chr [1:3] &quot;xxx&quot; &quot;yyy&quot; &quot;zzz&quot; ## ..$ items : num [1:3] 198 256 32 В некоторых случаях требуется импортировать только определенный диапазон ячеек со всего листа - например, когда на созданном вручную листе есть и таблица с данными, и графики, и дополнительные материалы. Для чтения определенной ячейки или диапазона ячеек используют аргумент range, в котором в строковом виде указывают диапазон ячеек в Excel-координатах (буквы для колонок и цифры для строк). К сожалению, на данный момент нельзя указать сразу несколько диапазонов. Во-вторых, в прочитанном диапазоне, если не указать обратное, первая строка будет по умолчанию интерпретироваться как строка заголовка. В результате приходится либо прямо задавать названия колонок, либо указывать, что заголовка нет: read_xlsx(path, range = &#39;A5:B6&#39;, col_names = c(&#39;company&#39;, &#39;item_code&#39;)) ## # A tibble: 2 × 2 ## company item_code ## &lt;chr&gt; &lt;dbl&gt; ## 1 yyy 40000289 ## 2 yyy 40000274 Чтение файлов SPSS Для импорта файлов SPSS (.sav) обычно используют функции какого-либо из двух пакетов - foreign::read.spss(), который идет в базовом наборе пакетов R, а так же haven::read_spss(), авторства Хэдли Викхэма. Исходный файл имеет такую структуру (скриншот из SPSS Output): Функции read_sav() и read_spss() пакета haven обладают схожим с foreign::read.spss() функционалом при меньшем количестве настроек. При этом эти функции несколько быстрее, а так же не имеют проблем с длинными строками. В результате импорта получается tibble-таблица (так как haven принадлежит экосистеме tidyverse). library(haven) spss_data &lt;- read_sav(&#39;./data/spss_example.sav&#39;) spss_data ## # A tibble: 6 × 3 ## var1 var2 var3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt; ## 1 3 4 1 [среднее] ## 2 4 5 NA ## 3 3 5 99 [отказ от ответа] ## 4 3 5 1 [среднее] ## 5 4 4 4 ## 6 3 5 999 [отказ от ответа] Функция не имеет настроек, как импортировать значения, для которых заданы метки, и в таблице представлены числовые значения. При необходимости получить значения метки переменных или значений необходимо идти в атрибуты колонок таблицы: str(spss_data) ## tibble [6 × 3] (S3: tbl_df/tbl/data.frame) ## $ var1: num [1:6] 3 4 3 3 4 3 ## ..- attr(*, &quot;label&quot;)= chr &quot;Практичный&quot; ## ..- attr(*, &quot;format.spss&quot;)= chr &quot;F8.2&quot; ## $ var2: num [1:6] 4 5 5 5 4 5 ## ..- attr(*, &quot;label&quot;)= chr &quot;Порядочный&quot; ## ..- attr(*, &quot;format.spss&quot;)= chr &quot;F8.2&quot; ## $ var3: dbl+lbl [1:6] 1, NA, 99, 1, 4, 999 ## ..@ label : chr &quot;Образование&quot; ## ..@ format.spss: chr &quot;F8.2&quot; ## ..@ labels : Named num [1:4] 1 2 99 999 ## .. ..- attr(*, &quot;names&quot;)= chr [1:4] &quot;среднее&quot; &quot;высшее&quot; &quot;отказ от ответа&quot; &quot;отказ от ответа&quot; Пакет haven импортирует данные в свой формат, однако полученный объект можно преобразовать в data.table: library(data.table) setDT(spss_data) class(spss_data) ## [1] &quot;data.table&quot; &quot;data.frame&quot; У нас есть колонка var3, для которой в SPSS были заданы метки. В полученном формате метки хранятся в атрибутах колонки — это что-то вроде мета-информации. Посмотрим все атрибуты колонки с помощью функции attributes() (иногда это проще делать через синтаксис списков и оператор $): # смотрим атрибуты вектора-колонки var3 attributes(spss_data[, var3]) ## $label ## [1] &quot;Образование&quot; ## ## $format.spss ## [1] &quot;F8.2&quot; ## ## $class ## [1] &quot;haven_labelled&quot; &quot;vctrs_vctr&quot; &quot;double&quot; ## ## $labels ## среднее высшее отказ от ответа отказ от ответа ## 1 2 99 999 # через синтаксис списков attributes(spss_data$var3) ## $label ## [1] &quot;Образование&quot; ## ## $format.spss ## [1] &quot;F8.2&quot; ## ## $class ## [1] &quot;haven_labelled&quot; &quot;vctrs_vctr&quot; &quot;double&quot; ## ## $labels ## среднее высшее отказ от ответа отказ от ответа ## 1 2 99 999 Мы видим четыре атрибута — метку переменной ($label), SPSS-формат данных ($format.spss), обозначение, что переменная в SPSS имеет метки значений ($class) и собственно вектор меток, которые используются для значений этой колонки ($labels). Для того, чтобы сохранить метки значений (а не сами значения), можно создать новую колонку и в нее записать с результат применения функции as_factor пакета haven — эта функция извлекает и сопоставляет значения и их метки. spss_data[, var4 := as_factor(var3)] spss_data ## var1 var2 var3 var4 ## 1: 3 4 1 среднее ## 2: 4 5 NA &lt;NA&gt; ## 3: 3 5 99 отказ от ответа ## 4: 3 5 1 среднее ## 5: 4 4 4 4 ## 6: 3 5 999 отказ от ответа Как мы видим, для значений 1, 99, 999 были проставлены метки, и они оказались в новой переменной, а не атрибутом. Для значения 4 метки не было, поэтому оно было записано именно значением. Дополнительная литература глава моего учебника по R, где разбираются процессы ввода/вывода данных. Домашнее задание level 1 (IATYTD) У вас есть xlsx-файл по популяции и видам пингвинов. Импортируйте данные из этого файла в R. При работе постарайтесь обойтись только средствами R, не открывая файл в Excel. Проверьте, что вы импортировали все листы. При необходимости, импортируйте оставшиеся и соберите все в одну таблицу. Проверьте класс объекта и при необходимости преобразуйте в data.table. Посчитайте количество пингвинов каждого типа (колонка Species). ## Species N ## 1: Adelie Penguin (Pygoscelis adeliae) 152 ## 2: Gentoo penguin (Pygoscelis papua) 124 ## 3: Chinstrap penguin (Pygoscelis antarctica) 68 level 2 (HNTR) У вас есть данные Tate Gallery по художникам и их произведениям. Импортируйте датасеты по художникам, ссылки на файлы ниже. А лучше воспользуйтесь функцией download.file() (не забудьте прочитать справку по функции и ее аргументам) для того, чтобы сохранить эти файлы на диск и потом загружать их уже с диска, а не из интернета. url_artwork &lt;- &#39;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-01-12/artwork.csv&#39; url_artists &lt;- &quot;https://github.com/tategallery/collection/raw/master/artist_data.csv&quot; С помощью функции setnames() пакета data.table (или names() из базового пакета, если вам так удобнее) переименуйте в файле по художникам колонки yearOfBirth в year_of_birth, колонки yearOFDeath, placeOfBirth и placeOfDeath аналогично. посчитайте, сколько художников из списка живы в настоящий момент. посчитайте, сколько среди живущих в настоящий момент художников мужчин и сколько женщин. ## [1] 1304 ## gender N ## 1: Female 297 ## 2: Male 944 ## 3: 63 level 3 (HMP) подумайте и покажите решение, как можно узнать структуру файла artwork, однако полностью импортировать вы его не можете (предположим, что он настолько большой, что повесит систему намертво). импортируйте только те колонки, которые позволят вам идентифицировать художника, название работы и ее формат (колонка medium). посчитайте, сколько в галерее работ от художников-мужчин и сколько от женщин. Отдельной колонкой выведите статистики по живущим на данный момент художникам. ## gender n_works n_works_alive ## 1: Male 2791 878 ## 2: 49 28 ## 3: Female 492 274 ## 4: &lt;NA&gt; 4 4 посчитайте, сколько работ разных форматов сделали художницы, умершие до 1800 года (каждый формат – отдельная колонка, форматы даны в колонке medium). Вам потребуется функция dcast(). ## artist Graphite and ink on paper Oil paint on canvas ## 1: Beale, Mary 0 1 ## 2: Sanders, Ann 0 0 ## 3: Spencer, Lady 1 0 ## Oil paint on paper Watercolour on paper ## 1: 2 0 ## 2: 0 1 ## 3: 0 0 level 4 (UV) Импортируйте файл txt_example.txt. Перед импортом можете скачать файл и импортировать его локально (это рекомендация, не более). ## КодПодр КодНом ## 1 69500044 ЛН-008560521 ## 2 69500044 ЛН-745621 ## 3 69500300 69506432458 ## 4 69500346 695089466518 ## 5 69500268 69504851543 ## 6 69500009 69506584554 ## 7 69500058 ЛН-86600383 ## 8 69500147 ЛН-41200521 ## 9 69500147 ЛН-05860521 ## 10 69500268 ЛН-00000927 ## Наименование ## 1 БАНЕОЦИН ПОР. 10Г ## 2 БАНЕОЦИН ПОР. 10Г ## 3 НИМЕСАН ТАБЛ. 100МГ N20 ## 4 ЦИННАРИЗИН ТАБЛ. 25МГ N50 АВЕКСИМА ## 5 ФИТОСЕДАН СБОР УСПОКОИТЕЛЬНЫЙ №2 Ф/П 2Г N20 КРАСНОГОРСК ## 6 БАНДАЖ КОМПРЕС. ПОДДЕРЖИВ. ПОЯСНИЧНО-КРЕСТЦОВЫЙ С ОВЕЧЬИМ МЕХОМ БКД-УНГА, р.6 ## 7 АЛЛОХОЛ ТАБЛ.П.О. N10 ФАРМСТАНДАРТ ## 8 БАНЕОЦИН ПОР. 10Г ## 9 БАНЕОЦИН ПОР. 10Г ## 10 КВАМАТЕЛ ТАБЛ.П.О. 20МГ N28 ## Производитель Упак Месяц ## 1 САНДОЗ ГмбХ - Австрия 4 5 ## 2 САНДОЗ ГмбХ - Австрия 4 5 ## 3 Шрея Лайф Саенсиз Пвт. Лтд 1 5 ## 4 Анжеро-Судженский ХФЗ,ООО 3 5 ## 5 КРАСНОГОРСКЛЕКСР-ВА 1 5 ## 6 ТОНУС - ЭЛАСТ 1 5 ## 7 ФАРМСТАНДАРТ 10 5 ## 8 САНДОЗ ГмбХ - Австрия 4 5 ## 9 САНДОЗ ГмбХ - Австрия 4 5 ## 10 Гедеон Рихтер 2 5 level 5 (N) Импортируйте файл extr’version.xls. Решение должно уметь импортировать не только этот конкретный файл, но и другие файлы с такими особенностями. Перед импортом надо скачать файл и импортировать его локально (read_excel не умеет импортировать по ссылке). print(x) ## Название товара ## 1: Солпадеин, тбл №12 ## 2: Соль д/ванн &quot;Доктор Сольморей&quot; с эвкалипт. пакет 500мг ## 3: Соль д/ванн 500г Противопростудная эвкалипт ## 4: Соль д/ванн Elite с пеной , 500г морская ## 5: Соль д/ванн Elite, 500г ромашка ## 6: СОЛЬ Д/ВАНН Д/ВСЕЙ СЕМЬИ ПРОТИВОПРОСТ 500ГР ## 7: Соль д/ванн Для всей семьи 500г антистресс ромашка ## 8: Соль д/ванн Мертвое море 500г натуральная ## 9: Соль д/ванн морская природная, 1кг ## 10: Соль д/ванн морская, 1кг ## 11: Соль д/ванн, 500г мелисса ## 12: Соль д/ванн, 500г розмарин ## 13: Соль морская, 1кг ## 14: Сонапакс, држ 100мг №60 ## 15: Сонапакс, држ 25мг №60 ## 16: Сонизин, капс с модиф.высвобожд.0.4мг №30 ## 17: Сонник, капс. 0.3г №36 ## 18: Сонные,тбл №30 ## 19: Сопелка наклейка на одежду при простуде и насмор №4 ## 20: Сопелка, пластырь д/инг №10 ## 21: Сопелка, пластырь №4 ## 22: Сорбифер дурулес, тбл п/о №30 ## 23: Сорбифер дурулес, тбл п/о №50 ## 24: Соска молочная латексная 2 шт. ## 25: Соска к рожку круглая (латекс) Х-отверстие ## 26: Соска к рожку круглая 0-6 мес. (латекс) ## 27: Соска к рожку круглая 6-12 мес. (латекс) смесь ## 28: Соска Курносики латекс №2 (поток средний) с 6+мес(арт 12124) ## 29: Соска Курносики силикон. большая сред.отвер №2 ## 30: Соска латекс. анатомич. д/пюре, арт.11204 ## 31: Соска латекс. мой малыш с 6-12 мес.круглая арт.11112 ## 32: Соска Мой малыш к рожку анатом. (латекс мелк.отв) 6-12 мес ## 33: Соска сил. Мой Малыш анатом 6-12м (сред.отв) 12212 ## 34: Соска сил. станд. (12032) х2 ## 35: Соска сил. станд. (12032) х2 ## 36: Соска силик. классич. для всех типов питания 6+ ## 37: Соска силик. стандартная №2 (арт. 12032) ## Название товара ## Фирма-производитель Страна ## 1: GlaxoSmithKline Dungarvan Ltd (Ирландия) Ирландия ## 2: Амида Косметик ООО Россия ## 3: Негоциант ТД Россия ## 4: Негоциант ТД Россия ## 5: Негоциант ТД Россия ## 6: НЕГОЦИАН ООО Россия ## 7: Негоциант ТД Россия ## 8: Фитокосметик ООО Россия ## 9: УралМедПром Россия ## 10: Илецксоль Россия ## 11: Линстек Инхим (г.С-Петербург) Россия ## 12: УралМедПром Россия ## 13: УралМедПром Россия ## 14: Jelfa Pharmaceutical Company S.A. Польша ## 15: Jelfa Pharmaceutical Company S.A. Польша ## 16: Gedeon Richter Румыния ## 17: ВИС ООО Россия ## 18: Леовит нутрио (г.Москва) Россия ## 19: Bouty S.p.A. Италия ## 20: Bouty S.p.A. Италия ## 21: Bouty S.p.A. Италия ## 22: Egis Pharmaceuticals Plc Венгрия ## 23: Egis Pharmaceuticals Plc Венгрия ## 24: АМТ Трейд ООО (г.Москва) Россия ## 25: Неизвестный производитель Германия ## 26: Неизвестный производитель Германия ## 27: Неизвестный производитель Германия ## 28: Yelowcare Ltd Китай ## 29: Мир детства Таиланд ## 30: NIP GmbH Германия ## 31: NIP GmbH Германия ## 32: NIP GmbH Германия ## 33: Нюрнберг Гуми, Georgensgmund Германия ## 34: Мир детства Россия ## 35: Мир детства Россия ## 36: Мир детства Таиланд ## 37: Мир детства Таиланд ## Фирма-производитель Страна ## Вид товара Поставщик Кол-во Сумма закупки с НДС ## 1: Лекарственные средства АЛЬФА-РИТМ ООО 8 882,6 ## 2: АЛЬФА-РИТМ ООО 2 66,60 ## 3: АЛЬФА-РИТМ ООО 2 54,40 ## 4: АЛЬФА-РИТМ ООО 1 29,40 ## 5: АЛЬФА-РИТМ ООО 1 66,70 ## 6: АЛЬФА-РИТМ ООО 2 54,40 ## 7: АЛЬФА-РИТМ ООО 3 81,60 ## 8: АЛЬФА-РИТМ ООО 6 244,80 ## 9: Парафармацевтика АЛЬФА-РИТМ ООО 45 1284,50 ## 10: Парафармацевтика АЛЬФА-РИТМ ООО 5 231,00 ## 11: Парафармацевтика АЛЬФА-РИТМ ООО 1 27,20 ## 12: Парафармацевтика АЛЬФА-РИТМ ООО 1 24,30 ## 13: АЛЬФА-РИТМ ООО 5 149,50 ## 14: Лекарственные средства АЛЬФА-РИТМ ООО 19 4599,20 ## 15: Лекарственные средства АЛЬФА-РИТМ ООО 26 10301,25 ## 16: Лекарственные средства АЛЬФА-РИТМ ООО 1 386,60 ## 17: Биологически активные добавки АЛЬФА-РИТМ ООО 1 266,50 ## 18: Биологически активные добавки АЛЬФА-РИТМ ООО 12 1649,00 ## 19: АЛЬФА-РИТМ ООО 3 417,60 ## 20: Изделия медицинского назначения АЛЬФА-РИТМ ООО 12 4433,90 ## 21: Изделия медицинского назначения АЛЬФА-РИТМ ООО 33 5385,60 ## 22: Лекарственные средства АЛЬФА-РИТМ ООО 18 5770,60 ## 23: Лекарственные средства АЛЬФА-РИТМ ООО 23 9764,30 ## 24: АЛЬФА-РИТМ ООО 35 485,50 ## 25: АЛЬФА-РИТМ ООО 2 61,40 ## 26: АЛЬФА-РИТМ ООО 4 101,60 ## 27: АЛЬФА-РИТМ ООО 2 50,80 ## 28: АЛЬФА-РИТМ ООО 1 66,50 ## 29: АЛЬФА-РИТМ ООО 2 127,60 ## 30: Детское питание АЛЬФА-РИТМ ООО 3 113,10 ## 31: АЛЬФА-РИТМ ООО 3 69,90 ## 32: АЛЬФА-РИТМ ООО 2 67,40 ## 33: АЛЬФА-РИТМ ООО 2 65,00 ## 34: АЛЬФА-РИТМ ООО 2 110,00 ## 35: ГК МРТК&quot; ООО 2 111.14 ## 36: АЛЬФА-РИТМ ООО 2 131,4 ## 37: АЛЬФА-РИТМ ООО 2 127,6 ## Вид товара Поставщик Кол-во Сумма закупки с НДС ## Цена закупки с НДС Сумма по продаже Цена продажи ## 1: 110,33 1164.0 145.50 ## 2: 33,30 98.0 49.00 ## 3: 27,20 80.0 40.00 ## 4: 29,40 43.0 43.00 ## 5: 66,70 97.0 97.00 ## 6: 27,20 80.0 40.00 ## 7: 27,20 120.0 40.00 ## 8: 40,80 360.0 60.00 ## 9: 28,54 1835.0 40.78 ## 10: 46,20 335.0 67.00 ## 11: 27,20 40.0 40.00 ## 12: 24,30 36.0 36.00 ## 13: 29,90 220.0 44.00 ## 14: 242,06 5383.0 283.32 ## 15: 396,20 12020.0 462.31 ## 16: 386,60 447.9 447.90 ## 17: 266,50 374.0 374.00 ## 18: 137,42 2304.0 192.00 ## 19: 139,20 606.0 202.00 ## 20: 369,49 5528.0 460.67 ## 21: 163,20 7881.0 238.82 ## 22: 320,59 7155.0 397.50 ## 23: 424,53 12236.0 532.00 ## 24: 13,87 700.0 20.00 ## 25: 30,70 92.0 46.00 ## 26: 25,40 152.0 38.00 ## 27: 25,40 76.0 38.00 ## 28: 66,50 98.0 98.00 ## 29: 63,80 188.0 94.00 ## 30: 37,70 165.0 55.00 ## 31: 23,30 105.0 35.00 ## 32: 33,70 100.0 50.00 ## 33: 32,50 96.0 48.00 ## 34: 55,00 164.0 82.00 ## 35: 55.57 164.0 82.00 ## 36: 65,7 194.0 97.00 ## 37: 63,8 188.0 94.00 ## Цена закупки с НДС Сумма по продаже Цена продажи "],["hw-1.html", "HW 1 Общие замечания Задание 1. Дома в Игре престолов. Задание 2. Агрессивность персонажей в книгах о Гарри Поттере. Задание 3. Динамика среднегодовой температуры в период 1750-2015", " HW 1 Общие замечания Срок сдачи работы: 26 ноября 2023 включительно. Домашнее задание должно быть выполнено в виде R-скрипта или Rmd-скрипта c чанками, кому что удобнее. Свой файл с кодом решения назовите по структуре mar231_hw1_&lt;ваша фамилия латиницей&gt;.Rmd или mar231_hw1_&lt;ваша фамилия латиницей&gt;.R и пришлите в личных сообщениях в mattermost Старайтесь комментировать каждую значимую строчку кода (т. е., в которой происходит сложное или не очень прозрачное преобразование). Комментарии нужны, в первую очередь, для того, чтобы вы могли продемонстрировать, что понимаете, что и зачем делаете. Если некоторые операции однозначны и очевидны, комментарии можно опустить. В частности, при подключении пакетов можно ограничиться одним комментарием ко всем командам подключения пакетов. Если используете какое-то выражение или функцию, которое нагуглили, объясните, зачем и приложите ссылку. Соблюдайте гайд по стилю оформления кода и/или используйте автоформатирование RStudio (ctr+shift+A на выделенном коде для Win/*nix). Отсутствие комментариев, неопрятность и/или нечитаемость кода, несоблюдение конвенций гайда по стилю — на все это я буду обращать внимание и, в случае существенных помарок, снижать оценку на один балл. Выполняйте задание самостоятельно. Если у меня возникнут затруднения в объективной оценке, то договоримся о созвоне и я попрошу прокомментировать то или иное решение, или же дам небольшое задание из аналогичных, чтобы сравнить стиль решения. Если при выполнении задания все же возникнут какие-то вопросы - можете спросить меня (все вопросы в mattermost: либо в личке, либо в канале ~random). Не гарантирую, что отвечу максимально подробно, но дать минимальную подсказку или прояснить неясность задания постараюсь. Все задания основаны на уже пройденных нами материалах, ничего запредельно сложного для вас быть не должно. Некоторые моменты могут потребовать гугления, но это минимально. Функции, примеры и алгоритмы можно найти на сайте в материалах. Если вы не знаете, как подступиться к задаче — попробуйте ее разложить на подзадачи, цепочку операций. Для того, чтобы не писать полный адрес к файлам данных, файлы должны лежать в той же папке, что и R/Rmd-файл, который использует эти файлы. Тогда импортировать можно без указание пути, просто через указание названия файла и его расширения. Например, my_fun_import('file_to_import.csv'). Я рассчитываю, что вы будете использовать в работе какой-то один стиль синтаксиса - data.table (которому я вас учил), либо data.frame / tidyverse — если вы в них чувствуете себя комфортно. Пожалуйста, если вы не планируете использовать data.table, сообщите мне это заранее. Если вы увереннее чувствуете себя в Python, можете выполнить задание в нем (также скажите об этом заранее). Но тогда будьте готовы к тому, что я могу попросить созвониться и прокомментировать какие-нибудь выражения из вашего решения. Пожалуйста, избегайте зоопарка пакетов и стилей. Чем меньше используется пакетов и чем согласованнее по стилю и лаконичнее код – тем лучше. Задание 1. Дома в Игре престолов. импорт данных Импортируйте датасет по персонажам Game of Thrones (ссылка на файл: https://gitlab.com/hse_mar/mar221s/-/raw/master/data/character-predictions_pose.csv). Назовите таблицу got_chars чистка данных Замените пустое название Дома (house == ’’) на Unknown. Удалите строки, в которых возраст отрицательный (age &lt; 0). график численности кланов Создайте из got_chars объект got_chars_bar, где будет статистика по количеству людей в клане, а также по количеству мужчин и женщин. Нарисуйте в ggplot2 или plotly барчарт по количеству членов в клане, возьмите первые 10 домов по численности, включая 'Unknown'. Для того, чтобы на графике бары были отсортированы, сначала надо отсортировать датасет по убыванию по количеству членов в клане. После этого выполнить это выражение: # делаем название клана в две строки got_chars_bar[, house := gsub(&#39;\\\\s+&#39;, &#39;&lt;br&gt;&#39;, house)] # задаем сортировку домов got_chars_bar[, house := factor(house, levels = house)] Если рисуете в plotly - добавьте ховер (hover) с информацией о названии клана, количестве членов в клане, количестве мужчин и количестве женщин в клане. Если используете ggplot2 — добавьте какую-нибудь тему не по умолчанию и заголовки графика и осей. Дополнительно: удалите кнопки plotly (Zoom/Autoscale и т.д.). Выполнение этого пункта на оценку не влияет. Задание 2. Агрессивность персонажей в книгах о Гарри Поттере. Импортируйте файл aggressive_actions.xlsx. Вам потребуются данные с листа DataSet. Объект с данными с листа назовите actions. По возможности напишите код так, чтобы исключить ручное скачивание файла на диск и потом импорт в R, т.е. сделать все средствами R. В датасете есть орфографическая ошибка, Ron Wealsey вместо Ron Weasley. Исправьте это. Отсортируйте по убыванию колонки tot, и возьмите первые 15 строк. Выполните следующие два выражения. Попробуйте проинтерпретировать смысл этих действий, что значат аргументы функций (на оценку наличие/корректность интерпретации не влияет). actions[, names_ordered := gsub(&#39;\\\\s+&#39;, &#39;\\n&#39;, name)] actions[, names_ordered := factor(names_ordered, levels = names_ordered)] Воспроизведите график ниже. Цвет заливки - grey90, цвет контура - grey85. Каждый бар должен быть подписан (количество действий), значение должно размещаться на области бара, чуть ниже, но не касаясь верхней границы бара, цвет текстовых меток - grey30. Выделите цветом darkred метку количества действий персонажей Золотого Трио (Harry, Hermione Granger, Ron Weasley). Выделите цветом darkblue метку количества действий тварей (creature == 1). Заголовок в две линии (вспомните про разделители линий в операционных системах, мы про это в ETL-блоке говорили), ориентация по центру. Добавьте на график и отформатируйте caption. Содержание подписи - ваша фамилия, курс и тип графика, по аналогии с mar231_hw1_upravitelev: barchart. Параметры подписи: face = \"italic\", color = 'grey60', смещения задайте самостоятельно. Задание 3. Динамика среднегодовой температуры в период 1750-2015 Импортируйте файл global_temperature.csv: https://gitlab.com/hse_mar/mar221s/-/raw/master/data/global_temperature.csv. По возможности исключите ручное скачивание файла на диск. Создайте из даты dt переменную года (назовите ее year). Для этого можно воспользоваться функцией year() пакета data.table, или же любым другим методом на ваше усмотрение. Подсчитайте среднюю температуру в год (колонка температуры LandAverageTemperature). У вас должен получиться файл с колонками year и temp_mn, где temp_mn - средняя температура за год. Воспроизведите график среднегодовой температуры. Добавьте линии трендов (методы loess и lm). Прозрачность диапазона равна 0.1, цвета - darkred и darkblue. Ваш график не должен вводить в заблуждение по поводу величины вариации между разными годами. Корректное выполнение этого задания в plotly — плюс 1 балл к оценке (можно без caption, только график и линии трендов). Функцией ggplotly() пользоваться нельзя. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
