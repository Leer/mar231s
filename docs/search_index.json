[["index.html", "Автоматизированный сбор больших данных в экономико-социологических исследованиях Intro", " Автоматизированный сбор больших данных в экономико-социологических исследованиях Ph.A.Upravitelev 2023-09-21 Intro "],["overview.html", "Введение Запись занятия Data culture Обо мне Contacts MM invite link Syllabus R intro Синтаксис Окружение и подсказки Дополнительные материалы Домашнее задание", " Введение Запись занятия Запись занятия 9 сентября: Data culture Проект Data Culture направлен на то, чтобы у студентов всех программ бакалавриата Высшей школы экономики появилось понимание возможностей современных технологий в области Data Science. https://www.hse.ru/dataculture/ Обо мне продуктовый аналитик в Pixonic продуктовый аналитик в GameInsight аналитик в Консультант+ аспирант СПбГУ (когнитивная психология) Contacts @konhis в https://mm.upravitelev.info/ (основное средство коммуникации) upravitelev@gmail.com (дополнительное средство коммуникации) +7-965-425-5919 (для экстренных случаев) MM invite link Все взаимодействие по курсу будем вести в Mattermost (аналог Slack), это мессенджер для команд, очень популярен в IT и среди датасаентистов. https://mm.upravitelev.info/signup_user_complete/?id=cfm9gfrwstg3jfkybb9t65eo6e Syllabus Основы синтаксиса R. Виды источников данных. Импорт данных из разных типов файлов данныx - SPSS, Excel, *.csv и прочих. Методы сбора удаленных данных. Скрапинг полуструктурированных сайтов. Изучим XPath и как извлекать данные из html-кода страницы сайтов. Попутно научимся писать циклы и функции. Удаленные базы данных и API: простейшие API — что такое, зачем, как читать документацию. Работа с API VK и погодного сервиса. Анализ и представление результатов исследования: много времени будем уделять визуализациям. R intro Short history 1976: S language 1991-1993: R language by Ross Ihaka and Robert Gentleman 2000: stable beta 2011: RStudio 2011: Oracle R Enterprise 2015: Microsoft bought Revolution R 2017: Just-in-time compilations 2018: Speed improvements R ecosystem R Foundation https://www.r-project.org/foundation/ The Comprehensive R Archive Network: https://cran.r-project.org/ RStudio &amp; Hadley Wickham community R + RStudio R: https://cran.r-project.org/ (нужно установить самым первым) RStudio: https://www.rstudio.com/products/rstudio/download/ (после установки R) Альтернативные IDE https://colab.research.google.com/#create=true&amp;language=r (создает colab-ноутбук с R-ядром) https://posit.cloud/ (онлайн-версия RStudio) Style guide http://style.tidyverse.org/index.html Синтаксис Структура выражения result &lt;- sqrt(x = 4) sqrt() - функция. sqrt - название функции, в () указываются аргументы, к которым будет применяться функция с таким названием. x - обозначение аргумента функции (в разных функциях аргументы могут называться по-разному) 4 - значение, которое мы передаем в аргумент функции (к коротому будет применена функция) &lt;- - знак присваивания result - объект, в который мы записываем результат выполнения функции. Название объектов может быть разным (лучше придерживаться style guide при нейминге) Вывод на печать Прямое указание: print(result) ## [1] 2 Можно просто вызвать сам объект: result ## [1] 2 Присваивание Оператор &lt;- - это оператор присваивания. Если до этого объект не был создан, то таким образом мы создадим объект x, в котором содержится значение 5. Если до этого объект существовал, то ему будет присвоено новое значение. x &lt;- 5 print(x) ## [1] 5 Когда значение или результат функции записываем в объект, ничего не печатается. result &lt;- sqrt(x = 4) Если нет присвоения, а только простой вызов функции, то результат будет напечатан, как если это был какой-то объект. sqrt(x = 4) ## [1] 2 Операторы присвоения &lt;- (основной оператор) = (не рекомендуется, если только очень хочется) -&gt; (существует, но использовать крайне не рекомендуется) &lt;&lt;-, -&gt;&gt; (надо понимать, когда использовать, встречаются редко, лучше использовать assign()) Арифметические операторы В R помимо оператора присвоения есть другие операторы, в частности, арифметические операторы, операторы сравнения или логического выбора. Операторы сравнения или логические операторы обычно используются при необходимости указать какие-то условия для выбора элементов вектора или таблицы, а также в конструкциях if/else. Сложение: + Вычитание: - Умножение: * Деление: / Возведение в степень: ^, ** Остаток от деления: %% (5 %% 2 дает 1) Неполное частное деления: %/% (5 %/% 2 дает 2) Операторы сравнения тождество (равенство): == не равно: != больше/меньше или равно: &gt;=, &lt;= пропущено ли: is.na() (проверяет, является ли значение пропущенным, NA) Логические операторы И: &amp;, &amp;&amp; ИЛИ: |, || НЕ (Обратно): ! (TRUE превращает в FALSE и наоборот) Комментарии и кавычки #: строка, которая идет после этого знака, считается комментарием и не выполняется. Используется для того, чтобы прокомментировать код или скрыть от выполнения часть кода. '', \"\": использутся для создания строковых объектов, можно сочетать одной строке, они не взаимозаменяемы ``:обратные апострофы, используются в редких случаях, обычно в RMarkdown, инфиксных операторах или кириллических названиях объектов. Окружение и подсказки Полезные функции для работы с окружением При работе с R: install.packages('pkg') - установить пакет pkg или список пакетов. Делается однократно при настройке R library('pkg') - подключение установленного пакета - делается при каждом новом запуске сессии, если этот пакет планируется использовать getwd() - узнать адрес рабочей папки setwd() - никогда не использовать! Это мешает при работе с несколькими коллегами, может вызвать сбои при каких-то изменениях в структуре папок, да и в целом дурной тон. Лучше использовать проекты в RStudio, которые формируют отдельную папку под каждый проект. ls() - возвращает список созданных объектов рабочего окружения rm() - удалить какой-нибудь объект rm(list = ls()) - удалить все объекты рабочего окружения. Использовать только в консоли, никогда не использовать в скриптах, которые могут быть использованы другими людьми. help help(), ? (например, ?round)или ??. Проще всего выделить функцию и нажать F1 на клавиатуре. cheatsheets: https://www.rstudio.com/resources/cheatsheets/ google it! stackoverflow Стандартные ошибки в синтаксисе пропущенная / лишняя запятая пропущенная / лишняя / другого типа скобка Object not found опечатки (пропуск буквы, удвоение буквы, разный регистр, c кириллическая) no object / file / function / package Дополнительные материалы textbook.rintro.ru – мой учебник по основам R Курсы на data.camp. Они, как и все онлайн-курсы, несколько дробные и избыточные, но базам конструкций научить могут. На русском языке есть курс на степике. Вполне нормальный, особенно в первых частях. Еще есть курс Тони Антонова, он посложнее, но в чем-то получше и поосновательнее курса Карпова и Иванчея. Мороз Г. А. , Поздняков И. С. - Наука о данных в R для программы Цифровых гуманитарных исследований Селезнёв А. - Язык R для пользователей Excel Long J., Teetor P. - R cookbook Bryan J. - STAT 545 Data wrangling, exploration, and analysis with R Почему не надо использовать setwd() Домашнее задание Организационное / MM Вся коммуникация по курсу будет идти в mattermost. Для того, чтобы войти, перейдите по ссылке: https://mm.upravitelev.info/signup_user_complete/?id=cfm9gfrwstg3jfkybb9t65eo6e Вам предложат, какую версию вы хотите, веб-версию (в браузере) или мобильное приложение. Я лично использую обе, веб как основная. После этого вам предложат форму регистрации, в которой надо будет указать имя (фио или username как в телеграме, я предпочитаю указывать его), email (на него приходят уведомления о непрочитанных сообщения) и пароль. После этого вы окажетесь в основном окне мессенджера. По умолчанию это будет канал Town Square. Вверху справа расположена кнопка редактирования профиля (картинка с первыми буквами имени). Отредактируйте профиль: необходимо указать имя и фамилию (латиницей, в виде Name Family name), по возможности поставьте свою фотографию на аватарку. Слева расположен список каналов и пользователей. Вверху слева есть форма поиска каналов, найдите канал welcome и зайдите в него. В канале welcome напишите несколько слов о себе: тему своей магистерской (если уже известна), какой опыт работы с R и вообще языками программирования, какие ожидания от курса. R Установка R и RStudio установите язык R (https://cran.r-project.org/) установите Rstudio (RStudio: https://www.rstudio.com/products/rstudio/download/) Или воспользуйтесь онлайн-вариантами (Colab / Posit Cloud) RStudio Если используете RStudio (или VS Code / Pycharm / Posit Cloud) – создайте новый проект. При желании – изучите глобальные настройки и настройки проекта в меню Tools. Создайте папку practice. В ней предлагаю хранить скрипты с домашками. В дальнейшем появятся папки seminars, data, lib и другие. Если чувствуете в себе силы, создайте папку practice с помощью кода (надо погуглить соответствующую функцию). Тем, кто использует Jupyter Notebook / Jupyter Lab рекомендую создать отдельную папку по курсу и в ней также создать папку practice. Операторы и создание векторов Задание необязательное, но настоятельно рекомендую прорешать всем, кто ни разу не сталкивался с R или давно все забыл и не уверен в своих знаниях. Если решение какого-то задания вызвало у вас сомнения, напишите мне об этом в личке в mm. При работе используйте гайд по стилю оформления кода. Старайтесь, чтобы код был максимально простым. Если каждое упражнение занимает больше одной-двух строк — скорее всего вы что-то делаете не так. В проекте создайте новый скрипт, назовите его 2023-09-12.R (RStudio предлагает назвать файл при сохранении, а расширение предлагает по умолчанию) в папке practice. Новый скрипт можно создать в меню File &gt; New script, кнопкой вверху слева, комбинацией ctrl+shift+n. Или же в панели внизу справа, где перечислены файлы проекта. Дальнейшие задачи выполняйте в этом скрипте. Создайте объект x со значением 5. Создайте объект y, который равен 3 * x. Выведите его на печать. Проверьте, что значение выражения x - y не равно 84. Запишите в объект alarm результат сравнения, больше ли x чем y. Выведите объект на печать. Симулируйте выпадение какой-либо грани двенадцатигранного кубика (одно значение). Вам потребуется функция sample(). Симулируйте выпадение десяти бросков восьмигранного кубика. Задача решается также с помощью функции sample(). Найдите длину меньшего катета прямоугольного треугольника с катетом длиной 4 и гипотенузой длиной 8, и округлите длину до третьего знака. Вам потребуются оператор возведения в степень и функции sqrt() и round(). На всякий случай напомню, квадрат гипотенузы равен сумме квадратов катетов. "],["vectors.html", "Векторы Запись занятия Векторы Выбор элемента вектора Проверка на NA Домашнее задание", " Векторы Запись занятия Запись занятия 16 сентября: Векторы Простой набор значений одного атомарного типа. Атомарные типы данных numeric (integer для целых и double как аналог numeric). Используется для числовых значений. Некоторые функций, в частности, median() на вход требуют объекты типа numeric. character. Используется для строковых значений. Любой набор знаков, заключенный в кавычки, в R воспринимается как строковое значение. logical. Значения TRUE/FALSE. Создание векторов Чаще всего векторы создаются с помощью функции c() (c от combine). Например: x &lt;- c(1, 3, 5) print(x) ## [1] 1 3 5 Простую неименованную последовательность атомарного типа можно задать также другими командами, наиболее часто используемые из них: seq() — создание последовательности значений в указанном интервале, с заданным шагом (seq от sequence). Например: x &lt;- seq(from = 10, to = 2, by = -2) print(x) ## [1] 10 8 6 4 2 Первые два аргумента задают первое и последнее значения последовательности, а аргумент by - шаг последовательности (по умолчанию равен единице). Знак - для значения аргумента by маркирует, что последовательность убывающая. : — аналог функции seq(), используется для создания последовательности целых чисел, где последующее отличается от предыдущего на 1. Так выражение 5:1 тождественно выражению seq(5, 1, -1). rep() — повтор какого-либо элемента заданное число раз. В качестве элемента может выступать практически любой объект R (в зависимости от осмысленности в целом подобного выражения). Аргументы times или each задают, какое количество раз повторять весь объект или каждый элемент объекта соответственно: x &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) rep(x, times = 2) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; rep(x, each = 2) ## [1] &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; Если значения аргументов задавать позиционно, то первый аргумент — это итерируемый объект, а второй аргумент — аргумент times: rep(x, 2) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; sample() — создание последовательности случайно выбранных значений из какого-то заданного вектора значений. Первый аргумент задает выборку, из которой необходимо извлечь подвыборку, второй аргумент (size) определяет объем извлекаемой выборки. Аргумент replace определяет, выборка извлекается с возвращением элементов или нет: sample(x = 1:5, size = 5, replace = FALSE) ## [1] 2 5 3 1 4 sample(x = 1:5, size = 5, replace = TRUE) ## [1] 4 3 3 2 1 Приведение типов R используется достаточно простая система автоматического преобразования атомарных типов по логике от “самого строгого к самому гибкому”, то есть по цепочке logical -&gt; integer -&gt; numeric -&gt; complex -&gt; character (тип raw не включается в эту систему). Такое преобразование позволяет использовать конструкции вида sum(5 == 5), потому что логический результат сравнения (TRUE) будет преобразован в целое числовое значение (1, так как TRUE преобразовывается в 1, а FALSE - в 0), и, следовательно, можно вычислить количество верных утверждений. Подобные процедуры крайне часто используются когда, например, надо посчитать количество определенных значений в векторе значений (или в колонке в таблице). Вообще, для избежания неожиданных результатов, рекомендуется избегать неявных преобразований и контролировать типы самостоятельно. Примеры приведений типов, все приводится к самому общему: # к строке c(&#39;a&#39;, 3.6, &#39;b&#39;, 5.1, TRUE) ## [1] &quot;a&quot; &quot;3.6&quot; &quot;b&quot; &quot;5.1&quot; &quot;TRUE&quot; # к numeric c(TRUE, 3.6, 2) ## [1] 1.0 3.6 2.0 Выбор элемента вектора Выбор элементов векторов указывается с помощью оператора [ по следующей схеме: x[&lt;condition&gt;]. Это читается как 'элементы вектора x, которые удовлетворяют условию &lt;condition&gt;'. В качестве условия может быть номер элемента в последовательности (индекс), так и какое-то логическое условие. При использовании оператора [ в &lt;condition&gt; может быть передан вектор значений (или логическое выражение, возвращающее вектор значений). Выбор по номеру позиции Простой вариант выбора определенных элементов последовательности - по номеру в последовательности (по индексу, индекс начинается с 1). Например, в последовательности 4, 3, 2 на третьем месте находится значение 2. В коде выбор третьего элемента этой последовательности выглядит вот так: x &lt;- c(4, 3, 2) x[3] ## [1] 2 В список номеров последовательности также можно передавать не только единичное значение, но и вектор значений номеров последовательности, который мы хотим извлечь. Например: x &lt;- c(4, 3, 2, 1) x[c(2, 4)] ## [1] 3 1 Выбор по значению Также возможен выбор элементов вектора, которые удовлетворяют условию. Например, те, которые больше 10, или все, которые равны 3, или все четные. Логика такого выделения следующая: каждый элемент последовательности сравнивается с условием, и если сравнение верное (5 == 5, TRUE), то этот элемент возвращается как подходящий под условие. Фактически метка TRUE здесь является указателем элемента, который надо вернуть, аналогично номеру позиции при выделении по номеру позиции. Например: # создаем вектор 8 случайных значений из массива от 1 до 10 x &lt;- sample(1:10, 8) x ## [1] 10 6 5 4 1 8 2 7 # сравниваем каждое значение с 5, смотрим результат сравнения x_cond &lt;- x &gt; 5 x_cond ## [1] TRUE TRUE FALSE FALSE FALSE TRUE FALSE TRUE # делаем выбор по условию, с указанием вектора, удовлетворяет элемент условию или нет x[x_cond] ## [1] 10 6 8 7 # аналогично, но без создания отдельного вектора x[x &gt; 5] ## [1] 10 6 8 7 Проверка на NA В R есть несколько инструментов для работы с пропущенными или отсутствующими значениями. NA — not avaliable. Ситуация, когда значение пропущено. Например, для какой-то строки в колонке таблицы нет значения. NaN, Inf — not a number и infinite соответственно. Появляются при некорректных с математической точки зрения операциях (например, 0/0 и `1/0’ соответственно). NULL — объект и тип, используется в редких случаях, когда надо создать пустой объект (например x &lt;- NULL, но это плохая практика, для этого есть более корректные способы). Чаще нужен, когда надо удалить колонку в табличке. Для того, чтобы проверить, есть ли пропущенные значения в векторе, используется функция is.na(). Эта функция проверяет, есть ли значение у каждого элемента вектора (является NA или нет) и отдает вектор логических значений, где TRUE означает, что у соответствующего элемента в проверяемом векторе нет значения (он пропущен). # делаем вектор с одним NA-значением x &lt;- c(1, 3, NA, 5) # проверяем каждый элемент на то, пропущен он или нет # видим, что для третьего элемента стоит TRUE, то есть пропущен is.na(x) ## [1] FALSE FALSE TRUE FALSE Функцию is.na() можно точно также использовать для ивзлечения элементов вектора. Например, если мы хотим вернуть все не-пропущенные значения, нам надо воспользоваться оператор логического отрицания !. Этот оператор превращает TRUE в FALSE и наоборот: # смотрим, как работает оператор ! !TRUE ## [1] FALSE # пробуем извлечь все непропущенные значения из x x[!is.na(x)] ## [1] 1 3 5 Домашнее задание Из вектора month.name (уже есть в базовом R, не надо создавать) извлеките пятый элемент. Из вектора month.name извлеките все элементы кроме пятого. Из вектора month.name извлеките первый, пятый и последний элементы. ** Создайте вектор vec из первых семи элементов вектора letters (уже есть в базовом R, не надо создавать), перемешанных в случайном порядке. Примените к нему функцию order(). Проинтерпретируйте результат. *** Отсортируйте вектор vec с использованием order() и без использования sort() Сравните каждый элемент вектора vec &lt;- letters[1:5] с буквой c (равен или нет) и запишите в отдельный векторindices. Выведите indices на печать. Примените indices для выбора элементов вектора vec (vec[indices]). Проинтерпретируйте результат. Из вектора month.name извлеките каждый третий элемент (вам поможет материал первого занятия). Из вектора vec &lt;- sample(10, 8) выберите все элементы, значения которых больше либо равны 5. Из вектора vec &lt;- sample(100, 8) выберите максимальное значение (элемент с максимальным значением). *** Решите предыдущее задание с помощью функции which.max(). Прочитайте справку по функции и найдите “подводный камень”, который потенциально может привести к ошибкам. Попробуйте представить ситуацию, когда может возникнуть такая ошибка (необязательно при работе с векторами, например, при работе с таблицами). Из вектора vec &lt;- sample(100, 8) выберите максимальное и минимальное значения. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
