[["index.html", "Автоматизированный сбор больших данных в экономико-социологических исследованиях Intro", " Автоматизированный сбор больших данных в экономико-социологических исследованиях Ph.A.Upravitelev 2023-10-02 Intro "],["overview.html", "Введение Запись занятия Data culture Обо мне Contacts MM invite link Syllabus R intro Синтаксис Окружение и подсказки Дополнительные материалы Домашнее задание", " Введение Запись занятия Запись занятия 9 сентября: Data culture Проект Data Culture направлен на то, чтобы у студентов всех программ бакалавриата Высшей школы экономики появилось понимание возможностей современных технологий в области Data Science. https://www.hse.ru/dataculture/ Обо мне продуктовый аналитик в Pixonic продуктовый аналитик в GameInsight аналитик в Консультант+ аспирант СПбГУ (когнитивная психология) Contacts @konhis в https://mm.upravitelev.info/ (основное средство коммуникации) upravitelev@gmail.com (дополнительное средство коммуникации) +7-965-425-5919 (для экстренных случаев) MM invite link Все взаимодействие по курсу будем вести в Mattermost (аналог Slack), это мессенджер для команд, очень популярен в IT и среди датасаентистов. https://mm.upravitelev.info/signup_user_complete/?id=cfm9gfrwstg3jfkybb9t65eo6e Syllabus Основы синтаксиса R. Виды источников данных. Импорт данных из разных типов файлов данныx - SPSS, Excel, *.csv и прочих. Методы сбора удаленных данных. Скрапинг полуструктурированных сайтов. Изучим XPath и как извлекать данные из html-кода страницы сайтов. Попутно научимся писать циклы и функции. Удаленные базы данных и API: простейшие API — что такое, зачем, как читать документацию. Работа с API VK и погодного сервиса. Анализ и представление результатов исследования: много времени будем уделять визуализациям. R intro Short history 1976: S language 1991-1993: R language by Ross Ihaka and Robert Gentleman 2000: stable beta 2011: RStudio 2011: Oracle R Enterprise 2015: Microsoft bought Revolution R 2017: Just-in-time compilations 2018: Speed improvements R ecosystem R Foundation https://www.r-project.org/foundation/ The Comprehensive R Archive Network: https://cran.r-project.org/ RStudio &amp; Hadley Wickham community R + RStudio R: https://cran.r-project.org/ (нужно установить самым первым) RStudio: https://www.rstudio.com/products/rstudio/download/ (после установки R) Альтернативные IDE https://colab.research.google.com/#create=true&amp;language=r (создает colab-ноутбук с R-ядром) https://posit.cloud/ (онлайн-версия RStudio) Style guide http://style.tidyverse.org/index.html Синтаксис Структура выражения result &lt;- sqrt(x = 4) sqrt() - функция. sqrt - название функции, в () указываются аргументы, к которым будет применяться функция с таким названием. x - обозначение аргумента функции (в разных функциях аргументы могут называться по-разному) 4 - значение, которое мы передаем в аргумент функции (к коротому будет применена функция) &lt;- - знак присваивания result - объект, в который мы записываем результат выполнения функции. Название объектов может быть разным (лучше придерживаться style guide при нейминге) Вывод на печать Прямое указание: print(result) ## [1] 2 Можно просто вызвать сам объект: result ## [1] 2 Присваивание Оператор &lt;- - это оператор присваивания. Если до этого объект не был создан, то таким образом мы создадим объект x, в котором содержится значение 5. Если до этого объект существовал, то ему будет присвоено новое значение. x &lt;- 5 print(x) ## [1] 5 Когда значение или результат функции записываем в объект, ничего не печатается. result &lt;- sqrt(x = 4) Если нет присвоения, а только простой вызов функции, то результат будет напечатан, как если это был какой-то объект. sqrt(x = 4) ## [1] 2 Операторы присвоения &lt;- (основной оператор) = (не рекомендуется, если только очень хочется) -&gt; (существует, но использовать крайне не рекомендуется) &lt;&lt;-, -&gt;&gt; (надо понимать, когда использовать, встречаются редко, лучше использовать assign()) Арифметические операторы В R помимо оператора присвоения есть другие операторы, в частности, арифметические операторы, операторы сравнения или логического выбора. Операторы сравнения или логические операторы обычно используются при необходимости указать какие-то условия для выбора элементов вектора или таблицы, а также в конструкциях if/else. Сложение: + Вычитание: - Умножение: * Деление: / Возведение в степень: ^, ** Остаток от деления: %% (5 %% 2 дает 1) Неполное частное деления: %/% (5 %/% 2 дает 2) Операторы сравнения тождество (равенство): == не равно: != больше/меньше или равно: &gt;=, &lt;= пропущено ли: is.na() (проверяет, является ли значение пропущенным, NA) Логические операторы И: &amp;, &amp;&amp; ИЛИ: |, || НЕ (Обратно): ! (TRUE превращает в FALSE и наоборот) Комментарии и кавычки #: строка, которая идет после этого знака, считается комментарием и не выполняется. Используется для того, чтобы прокомментировать код или скрыть от выполнения часть кода. '', \"\": использутся для создания строковых объектов, можно сочетать одной строке, они не взаимозаменяемы ``:обратные апострофы, используются в редких случаях, обычно в RMarkdown, инфиксных операторах или кириллических названиях объектов. Окружение и подсказки Полезные функции для работы с окружением При работе с R: install.packages('pkg') - установить пакет pkg или список пакетов. Делается однократно при настройке R library('pkg') - подключение установленного пакета - делается при каждом новом запуске сессии, если этот пакет планируется использовать getwd() - узнать адрес рабочей папки setwd() - никогда не использовать! Это мешает при работе с несколькими коллегами, может вызвать сбои при каких-то изменениях в структуре папок, да и в целом дурной тон. Лучше использовать проекты в RStudio, которые формируют отдельную папку под каждый проект. ls() - возвращает список созданных объектов рабочего окружения rm() - удалить какой-нибудь объект rm(list = ls()) - удалить все объекты рабочего окружения. Использовать только в консоли, никогда не использовать в скриптах, которые могут быть использованы другими людьми. help help(), ? (например, ?round)или ??. Проще всего выделить функцию и нажать F1 на клавиатуре. cheatsheets: https://www.rstudio.com/resources/cheatsheets/ google it! stackoverflow Стандартные ошибки в синтаксисе пропущенная / лишняя запятая пропущенная / лишняя / другого типа скобка Object not found опечатки (пропуск буквы, удвоение буквы, разный регистр, c кириллическая) no object / file / function / package Дополнительные материалы textbook.rintro.ru – мой учебник по основам R Курсы на data.camp. Они, как и все онлайн-курсы, несколько дробные и избыточные, но базам конструкций научить могут. На русском языке есть курс на степике. Вполне нормальный, особенно в первых частях. Еще есть курс Тони Антонова, он посложнее, но в чем-то получше и поосновательнее курса Карпова и Иванчея. Мороз Г. А. , Поздняков И. С. - Наука о данных в R для программы Цифровых гуманитарных исследований Селезнёв А. - Язык R для пользователей Excel Long J., Teetor P. - R cookbook Bryan J. - STAT 545 Data wrangling, exploration, and analysis with R Почему не надо использовать setwd() Домашнее задание Организационное / MM Вся коммуникация по курсу будет идти в mattermost. Для того, чтобы войти, перейдите по ссылке: https://mm.upravitelev.info/signup_user_complete/?id=cfm9gfrwstg3jfkybb9t65eo6e Вам предложат, какую версию вы хотите, веб-версию (в браузере) или мобильное приложение. Я лично использую обе, веб как основная. После этого вам предложат форму регистрации, в которой надо будет указать имя (фио или username как в телеграме, я предпочитаю указывать его), email (на него приходят уведомления о непрочитанных сообщения) и пароль. После этого вы окажетесь в основном окне мессенджера. По умолчанию это будет канал Town Square. Вверху справа расположена кнопка редактирования профиля (картинка с первыми буквами имени). Отредактируйте профиль: необходимо указать имя и фамилию (латиницей, в виде Name Family name), по возможности поставьте свою фотографию на аватарку. Слева расположен список каналов и пользователей. Вверху слева есть форма поиска каналов, найдите канал welcome и зайдите в него. В канале welcome напишите несколько слов о себе: тему своей магистерской (если уже известна), какой опыт работы с R и вообще языками программирования, какие ожидания от курса. R Установка R и RStudio установите язык R (https://cran.r-project.org/) установите Rstudio (RStudio: https://www.rstudio.com/products/rstudio/download/) Или воспользуйтесь онлайн-вариантами (Colab / Posit Cloud) RStudio Если используете RStudio (или VS Code / Pycharm / Posit Cloud) – создайте новый проект. При желании – изучите глобальные настройки и настройки проекта в меню Tools. Создайте папку practice. В ней предлагаю хранить скрипты с домашками. В дальнейшем появятся папки seminars, data, lib и другие. Если чувствуете в себе силы, создайте папку practice с помощью кода (надо погуглить соответствующую функцию). Тем, кто использует Jupyter Notebook / Jupyter Lab рекомендую создать отдельную папку по курсу и в ней также создать папку practice. Операторы и создание векторов Задание необязательное, но настоятельно рекомендую прорешать всем, кто ни разу не сталкивался с R или давно все забыл и не уверен в своих знаниях. Если решение какого-то задания вызвало у вас сомнения, напишите мне об этом в личке в mm. При работе используйте гайд по стилю оформления кода. Старайтесь, чтобы код был максимально простым. Если каждое упражнение занимает больше одной-двух строк — скорее всего вы что-то делаете не так. В проекте создайте новый скрипт, назовите его 2023-09-12.R (RStudio предлагает назвать файл при сохранении, а расширение предлагает по умолчанию) в папке practice. Новый скрипт можно создать в меню File &gt; New script, кнопкой вверху слева, комбинацией ctrl+shift+n. Или же в панели внизу справа, где перечислены файлы проекта. Дальнейшие задачи выполняйте в этом скрипте. Создайте объект x со значением 5. Создайте объект y, который равен 3 * x. Выведите его на печать. Проверьте, что значение выражения x - y не равно 84. Запишите в объект alarm результат сравнения, больше ли x чем y. Выведите объект на печать. Симулируйте выпадение какой-либо грани двенадцатигранного кубика (одно значение). Вам потребуется функция sample(). Симулируйте выпадение десяти бросков восьмигранного кубика. Задача решается также с помощью функции sample(). Найдите длину меньшего катета прямоугольного треугольника с катетом длиной 4 и гипотенузой длиной 8, и округлите длину до третьего знака. Вам потребуются оператор возведения в степень и функции sqrt() и round(). На всякий случай напомню, квадрат гипотенузы равен сумме квадратов катетов. "],["vectors.html", "Векторы Запись занятия Векторы Выбор элемента вектора Проверка на NA Домашнее задание", " Векторы Запись занятия Запись занятия 16 сентября: Векторы Простой набор значений одного атомарного типа. Атомарные типы данных numeric (integer для целых и double как аналог numeric). Используется для числовых значений. Некоторые функций, в частности, median() на вход требуют объекты типа numeric. character. Используется для строковых значений. Любой набор знаков, заключенный в кавычки, в R воспринимается как строковое значение. logical. Значения TRUE/FALSE. Создание векторов Чаще всего векторы создаются с помощью функции c() (c от combine). Например: x &lt;- c(1, 3, 5) print(x) ## [1] 1 3 5 Простую неименованную последовательность атомарного типа можно задать также другими командами, наиболее часто используемые из них: seq() — создание последовательности значений в указанном интервале, с заданным шагом (seq от sequence). Например: x &lt;- seq(from = 10, to = 2, by = -2) print(x) ## [1] 10 8 6 4 2 Первые два аргумента задают первое и последнее значения последовательности, а аргумент by - шаг последовательности (по умолчанию равен единице). Знак - для значения аргумента by маркирует, что последовательность убывающая. : — аналог функции seq(), используется для создания последовательности целых чисел, где последующее отличается от предыдущего на 1. Так выражение 5:1 тождественно выражению seq(5, 1, -1). rep() — повтор какого-либо элемента заданное число раз. В качестве элемента может выступать практически любой объект R (в зависимости от осмысленности в целом подобного выражения). Аргументы times или each задают, какое количество раз повторять весь объект или каждый элемент объекта соответственно: x &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) rep(x, times = 2) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; rep(x, each = 2) ## [1] &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; Если значения аргументов задавать позиционно, то первый аргумент — это итерируемый объект, а второй аргумент — аргумент times: rep(x, 2) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; sample() — создание последовательности случайно выбранных значений из какого-то заданного вектора значений. Первый аргумент задает выборку, из которой необходимо извлечь подвыборку, второй аргумент (size) определяет объем извлекаемой выборки. Аргумент replace определяет, выборка извлекается с возвращением элементов или нет: sample(x = 1:5, size = 5, replace = FALSE) ## [1] 4 5 3 2 1 sample(x = 1:5, size = 5, replace = TRUE) ## [1] 4 2 5 5 5 Приведение типов R используется достаточно простая система автоматического преобразования атомарных типов по логике от “самого строгого к самому гибкому”, то есть по цепочке logical -&gt; integer -&gt; numeric -&gt; complex -&gt; character (тип raw не включается в эту систему). Такое преобразование позволяет использовать конструкции вида sum(5 == 5), потому что логический результат сравнения (TRUE) будет преобразован в целое числовое значение (1, так как TRUE преобразовывается в 1, а FALSE - в 0), и, следовательно, можно вычислить количество верных утверждений. Подобные процедуры крайне часто используются когда, например, надо посчитать количество определенных значений в векторе значений (или в колонке в таблице). Вообще, для избежания неожиданных результатов, рекомендуется избегать неявных преобразований и контролировать типы самостоятельно. Примеры приведений типов, все приводится к самому общему: # к строке c(&#39;a&#39;, 3.6, &#39;b&#39;, 5.1, TRUE) ## [1] &quot;a&quot; &quot;3.6&quot; &quot;b&quot; &quot;5.1&quot; &quot;TRUE&quot; # к numeric c(TRUE, 3.6, 2) ## [1] 1.0 3.6 2.0 Выбор элемента вектора Выбор элементов векторов указывается с помощью оператора [ по следующей схеме: x[&lt;condition&gt;]. Это читается как 'элементы вектора x, которые удовлетворяют условию &lt;condition&gt;'. В качестве условия может быть номер элемента в последовательности (индекс), так и какое-то логическое условие. При использовании оператора [ в &lt;condition&gt; может быть передан вектор значений (или логическое выражение, возвращающее вектор значений). Выбор по номеру позиции Простой вариант выбора определенных элементов последовательности - по номеру в последовательности (по индексу, индекс начинается с 1). Например, в последовательности 4, 3, 2 на третьем месте находится значение 2. В коде выбор третьего элемента этой последовательности выглядит вот так: x &lt;- c(4, 3, 2) x[3] ## [1] 2 В список номеров последовательности также можно передавать не только единичное значение, но и вектор значений номеров последовательности, который мы хотим извлечь. Например: x &lt;- c(4, 3, 2, 1) x[c(2, 4)] ## [1] 3 1 Выбор по значению Также возможен выбор элементов вектора, которые удовлетворяют условию. Например, те, которые больше 10, или все, которые равны 3, или все четные. Логика такого выделения следующая: каждый элемент последовательности сравнивается с условием, и если сравнение верное (5 == 5, TRUE), то этот элемент возвращается как подходящий под условие. Фактически метка TRUE здесь является указателем элемента, который надо вернуть, аналогично номеру позиции при выделении по номеру позиции. Например: # создаем вектор 8 случайных значений из массива от 1 до 10 x &lt;- sample(1:10, 8) x ## [1] 10 6 5 4 1 8 2 7 # сравниваем каждое значение с 5, смотрим результат сравнения x_cond &lt;- x &gt; 5 x_cond ## [1] TRUE TRUE FALSE FALSE FALSE TRUE FALSE TRUE # делаем выбор по условию, с указанием вектора, удовлетворяет элемент условию или нет x[x_cond] ## [1] 10 6 8 7 # аналогично, но без создания отдельного вектора x[x &gt; 5] ## [1] 10 6 8 7 Проверка на NA В R есть несколько инструментов для работы с пропущенными или отсутствующими значениями. NA — not avaliable. Ситуация, когда значение пропущено. Например, для какой-то строки в колонке таблицы нет значения. NaN, Inf — not a number и infinite соответственно. Появляются при некорректных с математической точки зрения операциях (например, 0/0 и `1/0’ соответственно). NULL — объект и тип, используется в редких случаях, когда надо создать пустой объект (например x &lt;- NULL, но это плохая практика, для этого есть более корректные способы). Чаще нужен, когда надо удалить колонку в табличке. Для того, чтобы проверить, есть ли пропущенные значения в векторе, используется функция is.na(). Эта функция проверяет, есть ли значение у каждого элемента вектора (является NA или нет) и отдает вектор логических значений, где TRUE означает, что у соответствующего элемента в проверяемом векторе нет значения (он пропущен). # делаем вектор с одним NA-значением x &lt;- c(1, 3, NA, 5) # проверяем каждый элемент на то, пропущен он или нет # видим, что для третьего элемента стоит TRUE, то есть пропущен is.na(x) ## [1] FALSE FALSE TRUE FALSE Функцию is.na() можно точно также использовать для ивзлечения элементов вектора. Например, если мы хотим вернуть все не-пропущенные значения, нам надо воспользоваться оператор логического отрицания !. Этот оператор превращает TRUE в FALSE и наоборот: # смотрим, как работает оператор ! !TRUE ## [1] FALSE # пробуем извлечь все непропущенные значения из x x[!is.na(x)] ## [1] 1 3 5 Домашнее задание Из вектора month.name (уже есть в базовом R, не надо создавать) извлеките пятый элемент. Из вектора month.name извлеките все элементы кроме пятого. Из вектора month.name извлеките первый, пятый и последний элементы. ** Создайте вектор vec из первых семи элементов вектора letters (уже есть в базовом R, не надо создавать), перемешанных в случайном порядке. Примените к нему функцию order(). Проинтерпретируйте результат. *** Отсортируйте вектор vec с использованием order() и без использования sort() Сравните каждый элемент вектора vec &lt;- letters[1:5] с буквой c (равен или нет) и запишите в отдельный векторindices. Выведите indices на печать. Примените indices для выбора элементов вектора vec (vec[indices]). Проинтерпретируйте результат. Из вектора month.name извлеките каждый третий элемент (вам поможет материал первого занятия). Из вектора vec &lt;- sample(10, 8) выберите все элементы, значения которых больше либо равны 5. Из вектора vec &lt;- sample(100, 8) выберите максимальное значение (элемент с максимальным значением). *** Решите предыдущее задание с помощью функции which.max(). Прочитайте справку по функции и найдите “подводный камень”, который потенциально может привести к ошибкам. Попробуйте представить ситуацию, когда может возникнуть такая ошибка (необязательно при работе с векторами, например, при работе с таблицами). Из вектора vec &lt;- sample(100, 8) выберите максимальное и минимальное значения. "],["lists.html", "Списки и таблицы Запись занятия 23 сентября Векторы Векторизованные операции Recycling Изменение элементов объектов Списки Структура объектов Таблицы data.table Создание data.table-таблиц Основная формула dt-синтаксиса Создание data.table-таблиц Выбор строки Дополнительные материалы Домашнее задание", " Списки и таблицы Запись занятия 23 сентября Векторы Поиск по вхождению в массив Нередко встречаются ситуации, когда необходимо выбрать значения вектора, которые присутствуют в другом векторе. Например, из списка группы студентов выбрать тех, кто указан в списке недопущенных к сессии. Для этого используется выражение x %in% y. Оператор %in% проверяет, встречается ли каждый элемент вектора х в векторе y. Как и в сравнении по условию, в результате получается логический вектор, который можно использовать для выделения элементов. Выделенные элементы можно записать в отдельный объект. Например: x &lt;- c(1, 5, 2) y &lt;- seq(0, 10, 2) # сравниваем элементы списков x %in% y ## [1] FALSE FALSE TRUE # выделяем те элементы списка х, которые есть в у x[x %in% y] ## [1] 2 # записываем результат в отдельный объект z &lt;- x[x %in% y] str(z) ## num 2 Поиск по строке Для поиска по строковым записям (например, найти пользователя по ФИО, когда известно только имя) используют функцию grep() или grepl(). Первая функция возвращает номера элементов (или строк), в которых нашлось искомое строковое значение. Вторая функция возвращает результат проверки кадого элемента, включает ли он в себя искомый набор символов. # вектор строковых значений month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; # ищем значения, в которых есть буква r grep(&#39;r&#39;, month.name) ## [1] 1 2 3 4 9 10 11 12 grepl(&#39;r&#39;, month.name) ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE Первый аргумент — это паттерн регулярного выражения (если не используется аргумент fixed = TRUE): vec &lt;- c(&#39;user.1&#39;, &#39;user2&#39;) # в регэкспах точка -- служебный символ, его надо экранировать двумя слэшами vec[grep(&#39;\\\\.&#39;, vec)] ## [1] &quot;user.1&quot; # или указывать, что ищем именно точку, а не регэксп vec[grep(&#39;.&#39;, vec, fixed = TRUE)] ## [1] &quot;user.1&quot; Векторизованные операции Векторизация — наверное, одна из самых примечательных и важных особенностей R как языка программирования и инструмента работы с данными. Фраза векторизованная функция означает, что операции производятся сразу над каждым элементом вектора. То есть там, где в других языках программирования (например, в Python) необходимо писать цикл или лямбда-функцию, в R можно просто передать вектор в аргументы функции. Например, функция round(), если в качестве аргумента использовать вектор значений, округлит до нужного знака каждый элемент вектора: x &lt;- rnorm(5, 0, 1) x ## [1] 1.9644485 0.6830468 0.8234735 1.1360718 0.4042028 round(x, 3) ## [1] 1.964 0.683 0.823 1.136 0.404 В какой-то мере к векторизованным операциям можно отнести и простые арифметические операции над векторами. В частности, если мы попробуем сложить или умножить векторы одинаковой длины, то произойдет попарные сумма или произведение элементов векторов: # создаем векторы x &lt;- c(1, 5) y &lt;- c(7, 9) # смотрим значения векторов x ## [1] 1 5 y ## [1] 7 9 # сумма векторов x + y ## [1] 8 14 # произведение векторов x * y ## [1] 7 45 Recycling В том случае, когда в операции используется два вектора разной длины, используется правило ресайклинга (recycling). То есть короткий вектор начинает использоваться с начала, и так до тех пор, пока длины векторов не сойдутся. Например, мы хотим перемножить два вектора разной длины: x &lt;- 1:5 x ## [1] 1 2 3 4 5 y &lt;- c(3, 5, 7) y ## [1] 3 5 7 При перемножении операция элементы каждого вектора берутся попарно. Так как в векторе y всего три элемента, а в векторе x — пять, то элементы вектора y начинают использоваться повторно начиная с самого первого: x * y ## Warning in x * y: longer object length is not a multiple of shorter object ## length ## [1] 3 10 21 12 25 При этом интерпретатор R нам выдаст предупреждение, что длины не совпадают: Warning message: In x * y : longer object length is not a multiple of shorter object length Если использовать два вектора кратной длины (например, 2 и 4 элемента), то короткий вектор будет переиспользован, но предупреждения не будет: x &lt;- c(1, 5) y &lt;- c(1, 2, 3, 4) x * y ## [1] 1 10 3 20 Если учесть, что в R нет скаляров и x &lt;- 5 это создание вектора из одного элемента (единичного вектора), то умножение вектора на какое-то значение — то же самое умножение векторов с переиспользованием короткого вектора. Изменение элементов объектов В задачах на изменение значения элемента векторов, списков или таблиц используется следующая логика - указывается элемент объекта, с которым надо произвести какое-то действие, и этому элементу присваивается новое значение. Например, у нас есть вектор из 10 значений в случайном порядке от 1 до 10, и мы хотим возвести в квадрат третий элемент: # задаем зерно для псевдослучайной генерации set.seed(1234) # создаем вектор x &lt;- sample(10) str(x) ## int [1:10] 10 6 5 4 1 8 2 7 9 3 # возводим в квадрат третий элемент: x[3] &lt;- x[3] ^ 2 str(x) ## num [1:10] 10 6 25 4 1 8 2 7 9 3 Создание новых элементов или удаление уже существующих производятся аналогично - указывается индекс элемента (или его название, если применимо), и присваивается какое-то значение. Для создания элемента - любой объект, если он не нарушает уже существующую структуру (например, в таблице на пять строк нельзя создать колонку с шестью значениями), если в векторе создавать значение иного типа, чем был, то все значения будут преобразованы к более общему по правилам преобразования. # меняем 9 элемент вектора на &#39;x&#39;, текстовый x[9] &lt;- &#39;x&#39; str(x) ## chr [1:10] &quot;10&quot; &quot;6&quot; &quot;25&quot; &quot;4&quot; &quot;1&quot; &quot;8&quot; &quot;2&quot; &quot;7&quot; &quot;x&quot; &quot;3&quot; Для удаления элемента вектора можно просто сделать переприсвоение этому объекту тех же значений, за исключением того, которое требуется удалить: # удалим 3 значение вектора x x &lt;- x[-3] str(x) ## chr [1:9] &quot;10&quot; &quot;6&quot; &quot;4&quot; &quot;1&quot; &quot;8&quot; &quot;2&quot; &quot;7&quot; &quot;x&quot; &quot;3&quot; Списки Список элементов разных типов - векторов, таблиц, атомарных типов, других листов, функций и так далее. Длина и тип объекта в списке значения не имеет. Создание списков Для создания списка используется команда list(), где в аргументах через запятую перечисляются все элементы, которые необходимо включить в лист. Например: x &lt;- seq(from = 13, to = 0, by = -3) y &lt;- rep(x = &#39;c&#39;, times = 3) z &lt;- TRUE my_list &lt;- list(x, y, z) str(my_list) ## List of 3 ## $ : num [1:5] 13 10 7 4 1 ## $ : chr [1:3] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## $ : logi TRUE Именованные списки Помимо простого объединения объектов в списки и последующим вызовом элементов по номеру в списке, можно создавать именованные списки, где каждые элементы будут иметь заданное название. Например, x &lt;- seq(from = 13, to = 0, by = -3) y &lt;- rep(x = &#39;c&#39;, times = 3) z &lt;- TRUE my_list &lt;- list(seq_example = x, rep_example = y, atomic_example = z) print(my_list) ## $seq_example ## [1] 13 10 7 4 1 ## ## $rep_example ## [1] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## ## $atomic_example ## [1] TRUE Выбор элемента списка Выбор элементов списка также использует выбор по номеру элемента. Следует учитывать, что для списков несколько различается поведение операторов [ и [[. Так, оператор [ позволяет выделить элемент списка в виде отдельного списка: # создадим список my_list &lt;- list(seq_example = seq(from = 13, to = 0, by = -3), rep_example = rep(x = &#39;c&#39;, times = 3), atomic_example = TRUE) str(my_list) ## List of 3 ## $ seq_example : num [1:5] 13 10 7 4 1 ## $ rep_example : chr [1:3] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## $ atomic_example: logi TRUE # выберем первый элемент списка first_element &lt;- my_list[1] str(first_element) ## List of 1 ## $ seq_example: num [1:5] 13 10 7 4 1 Оператор [[ позволяет вызвать значения вызываемых элементов списка. Так, my_list[[1]] вызовет не первый элемент в виде списка, а значения первого элемента в виде вектора (как они и были заданы): # выберем значения первого элемента списка first_element_values &lt;- my_list[[1]] str(first_element_values) ## num [1:5] 13 10 7 4 1 Также для именованных списков можно использовать выделение по имени элемента. Для указания элемента списка используется оператор $ и конструкция вида list_name$element_name. Например: # смотрим на список my_list ## $seq_example ## [1] 13 10 7 4 1 ## ## $rep_example ## [1] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## ## $atomic_example ## [1] TRUE # выбираем элемент seq_example str(my_list$seq_example) ## num [1:5] 13 10 7 4 1 Структура объектов Нередко при работе с разными объектами необходимо получить сводную информацию об объекте - класс объекта, иерархию элементов объекта, первые значения каждого элемента и так далее. Для этих целей используется функция str() (от structure), которая выводит каждый элемент объекта в виде вектора значений. Например, при просмотре структуры таблицы iris мы получаем класс объекта (data.frame), количество строк и столбцов, название колонок, тип элементов и первые десять значений каждой колонки: str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... При просмотре структуры списка, который в качестве одного из элементов содержит другой список, точно также отображается каждый элемент списка, его тип, в том числе и типы и элементы вложенного списка. Вложенный список дополнительно выделен точками и отступом: x &lt;- list(e1 = 1:5, e2 = letters[1:5], e3 = list(e31 = rnorm(5), e32 = runif(5))) str(x) ## List of 3 ## $ e1: int [1:5] 1 2 3 4 5 ## $ e2: chr [1:5] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ e3:List of 2 ## ..$ e31: num [1:5] 0.983 -0.622 -0.732 -0.517 -1.751 ## ..$ e32: num [1:5] 0.8106 0.5257 0.9147 0.8313 0.0458 Таблицы Таблица — это набор наблюдений по строкам и пространство признаков этих наблюдений в виде набора колонок. Базовый тип для табли в R - data.frame. На уровне структуры data.frame — это все те же списки, в которых могут храниться разные по типу объекты, однако с требованием равенства длины объектов. Важно: все значения одной колонки могут быть только одного типа (потому что это, по сути, векторы), а не как в Excel, OpenOffice или каком другом табличном процессоре. data.frame vs data.table vs dplyr Несмотря на то, что базовый тип таблиц это data.frame, в настоящее время используются варианты надстроек над этим типом: формат data.table или формат tibble из пактов data.table и dplyr соответственно. Различить их можно по элементам синтаксиса. В частности, data.frame почти всегда использует оператор $ (my_table$my_var), в data.table активно используется оператор :=, а в tibble - оператор %&gt;%. Пример создания таблицы и выбора строки по условию в data.frame: # создаем таблицу set.seed(1234) df &lt;- data.frame( var1 = sample(letters, 5), var2 = sample(1:5, 5) ) # смотрим результат print(df) ## var1 var2 ## 1 p 1 ## 2 v 5 ## 3 e 2 ## 4 l 3 ## 5 o 4 # обращаемся к значениям первой колонки df$var1 ## [1] &quot;p&quot; &quot;v&quot; &quot;e&quot; &quot;l&quot; &quot;o&quot; # выводим все строки, где в колонке var2 значения меньше или равны 3 df[df$var2 &lt;= 3, ] ## var1 var2 ## 1 p 1 ## 3 e 2 ## 4 l 3 Аналогичные операции в tibble-формате: set.seed(1234) library(dplyr) dp &lt;- tibble( var1 = sample(letters, 5), var2 = sample(1:5, 5) ) dp %&gt;% filter(var2 &lt;= 3) ## # A tibble: 3 × 2 ## var1 var2 ## &lt;chr&gt; &lt;int&gt; ## 1 p 1 ## 2 e 2 ## 3 l 3 data.table Преимущества data.table высокая скорость IO / манипуляций (бенчмарки) параллелизация вычислений по умолчанию опирается только на base R лаконичность выражений бережные апдейты забота об обратной совместимости Установка и подключение пакета # устанавливаем пакет (однократно) install.packages(&#39;data.table&#39;) # подключаем пакет (при каждой сессии) library(data.table) Создание data.table-таблиц Создать data.table можно следующим образом (синтаксис немного напоминает создание именованного списка, как и для всех форматов таблиц): # подключаем пакет, если не был подключен ранее library(data.table) ## ## Attaching package: &#39;data.table&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## between, first, last # создаем датасет dt1 &lt;- data.table( month_names = month.name, month_abb = month.abb, month_ord = seq_len(length(month.abb)), is_winter = grepl(&#39;Jan|Dec|Feb&#39;, month.abb) ) print(dt1) ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Основная формула dt-синтаксиса Общая формула data.table выглядит как dataset[выбор строк, операции над колонками, группировка]. То есть, указание, какие строки необходимо выделить, осуществляется в первой части (до первой запятой в синтаксисе data.table). Если нет необходимости выделять какие-то строки, перед первой запятой ничего не ставится. Параметр группировки (как и прочие параметры, кроме i и j - опциональны). Также можно провести параллели с синтаксисом SQL-запроса. В терминах SQL data.table-выражения выглядят как таблица[where, select, group by]. Создание data.table-таблиц Создать data.table можно следующим образом (синтаксис немного напоминает создание именованного списка, как и для всех форматов таблиц): # подключаем пакет, если не был подключен ранее library(data.table) # создаем датасет dt1 &lt;- data.table( month_names = month.name, month_abb = month.abb, month_ord = seq_len(length(month.abb)), is_winter = grepl(&#39;Jan|Dec|Feb&#39;, month.abb) ) print(dt1) ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Выбор строки Выбор строк в data.table осуществляется аналогично выбору элементов в векторе: по номеру строки или по какому-то условию. При выборе по номеру строки также можно указать вектор номеров строк, которые необходимо вернуть. При выборке строки по условию проверяется, удовлетворяет ли условию каждый элемент строки в определенной колонке, и если удовлетворяет, выделяется вся строка. # выбор по одному номеру строки dt1[1, ] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE # выбор по нескольким номерам строк # сначала создаем вектор номеров строк my_rows &lt;- c(2, 5, 8) # выводим строки, которые мы указали в векторе dt1[my_rows] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE # или, аналогично, сразу указываем, какие строки хотим выделить dt1[c(2, 5, 8)] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE Выбор по условию: мы сразу указываем название колонки, к значениям которых будем применять условие-фильтр. Писать в стиле dt1[dt1$month_ord &lt;= 3] избыточно, data.table понимает просто название колонки. # выводим все строки, в которых в колонке month_ord значения меньше или равны 3 dt1[month_ord &lt;= 3] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE Дополнительные материалы Про пакеты и их установку Получение информации об объекте Моя серия вебинаров по data.table. Есть как запись, так и конспект. На занятиях мы будем рассматривать лишь половину или треть материала вебинаров. Базовые операции одновременно в data.table и dplyr-синтаксисе. Много полезных приемов, и, в целом, наглядно. Смотрите блоки по data.table, dplyr синтаксис можно игнорировать или смотреть для общего развития (это весьма часто используемый синтаксис в академии). Перевод документации data.table от Андрея Огурцова. Полезно для понимания разных нюансов работы data.table Продвинутый data.table для желающих, много неочевидных нюансов и трюков. Экзотические возможности и ключевые слова, для совсем экстремалов. Заметка важна в первую очередь внутренними ссылками на разные релевантные и поясняющие ресурсы. Интересный сайт, где каждой конструкции в pandas дана аналогичная конструкция в data.table. Некоторые конструкции, правда, избыточны или переусложнены, но в целом сопоставление адекватное. Домашнее задание векторы Умножьте каждый элемент вектора vec &lt;- sample(10) на 2. Вычислите корень из каждого элемента вектора vec. Округлите значения до второго знака. В принципе для этого достаточно выражения длиной в 16 символов. выполните выражение paste('blabla', 1:3, letters [1:2], month.abb[1:4]). Разберитесь, почему получился такой результат. списки Код ниже создает иллюстрирует дисперсионный анализ. Прочитайте справки по iris и aov. Выполните выражения. # aov_stats &lt;- aov(Sepal.Length ~ Species, iris) aov_stats_summary &lt;- summary(aov_stats) Выведите на печать объект aov_stats_summary. Выведите на печать и проанализируйте структуру объекта. ***Выведите на печать уровень значимости (Pr(&gt;F)) таблицы. импорт данных подключите библиотеку data.table (установите, если не была установлена) скачайте файл titanic3.csv: https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv. с помощью команды titanic &lt;- fread('titanic3.csv') импортируйте файл в рабочее окружение. Прочитайте справку по функции fread() и попробуйте импортировать данные без явного сохранения на диск (не сработает с файлом в слаке). ** попробуйте написать код, в котором сначала происходит сохранение файла на диск, а потом чтение файла в рабочее окружение R (чтобы не руками сохранять, а кодом). посмотрите с помощью команды class() объекта. Если он отличается от data.table — преобразуйте в data.table с помощью функции as.data.table() работа со строками выберите случайным образом 5 строк из таблицы titanic выберите те строки, где возраст пассажира меньше 1 (младенцы) выберите те строки, где возраст пассажира в диапазоне 20 до 50 лет выберите строки по выжившим младенцам (survived) выберите пассажирок, которые имеют титул lady "],["data.table-pt1.html", "data.table pt1 Запись занятия Разбор домашней работы Основная формула dt-синтаксиса Создание data.table-таблиц Выбор строки Работа с колонками .SD (Advanced) Полезные ссылки Домашнее задание", " data.table pt1 Запись занятия Запись занятия 30 сентября: Разбор домашней работы списки Код ниже создает иллюстрирует дисперсионный анализ. Прочитайте справки по iris и aov. Выполните выражения. # aov_stats &lt;- aov(Sepal.Length ~ Species, iris) aov_stats_summary &lt;- summary(aov_stats) Выведите на печать объект aov_stats_summary. Выведите на печать и проанализируйте структуру объекта. ***Выведите на печать уровень значимости (Pr(&gt;F)) Решение. В списке aov_stat_summary неименованный подсписок. Этот подсписок является таблицей (data.frame). Соответственно, сначала нам надо обратиться к неименованному подсписку списка с помощью [[, а потом обратиться к первой строчке пятой колонки. Либо использовать то, что таблицы – это тоже списки, и обратиться к значению в синтаксисе списков, а не колонок. # смотрим структуру объекта str(aov_stats_summary) ## List of 1 ## $ :Classes &#39;anova&#39; and &#39;data.frame&#39;: 2 obs. of 5 variables: ## ..$ Df : num [1:2] 2 147 ## ..$ Sum Sq : num [1:2] 63.2 39 ## ..$ Mean Sq: num [1:2] 31.606 0.265 ## ..$ F value: num [1:2] 119 NA ## ..$ Pr(&gt;F) : num [1:2] 1.67e-31 NA ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;summary.aov&quot; &quot;listof&quot; # используем синтаксис списков aov_stats_summary[[1]]$`Pr(&gt;F)`[1] ## [1] 1.669669e-31 # используем синтаксис data.frame -- первая строка, пятая колонка aov_stats_summary[[1]][1, 5] ## [1] 1.669669e-31 # так как мы умеем работать только с data.table # конвертируем в data.table и извлекаем значение аналогично data.frame library(data.table) aov_stats &lt;- as.data.table(aov_stats_summary[[1]]) str(aov_stats) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 2 obs. of 5 variables: ## $ Df : num 2 147 ## $ Sum Sq : num 63.2 39 ## $ Mean Sq: num 31.606 0.265 ## $ F value: num 119 NA ## $ Pr(&gt;F) : num 1.67e-31 NA ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; # по номеру колонки aov_stats[1, 5] ## Pr(&gt;F) ## 1: 1.669669e-31 # по названию колонки aov_stats[1, `Pr(&gt;F)`] ## [1] 1.669669e-31 таблицы. импорт данных подключите библиотеку data.table (установите, если не была установлена) скачайте файл titanic3.csv: https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv. с помощью команды titanic &lt;- fread('titanic3.csv') импортируйте файл в рабочее окружение. Прочитайте справку по функции fread() и попробуйте импортировать данные без явного сохранения на диск (не сработает с файлом в слаке). # можно импортироватьс разу по ссылке titanic &lt;- fread(&#39;https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv&#39;) ** попробуйте написать код, в котором сначала происходит сохранение файла на диск, а потом чтение файла в рабочее окружение R (чтобы не руками сохранять, а кодом). # можно сохранить объект по ссылка на диск download.file( &#39;https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv&#39;, &#39;titanic_new.csv&#39; ) # и потом прочитать с диска titanic &lt;- fread(&#39;titanic_new.csv&#39;) посмотрите с помощью команды class() объекта. Если он отличается от data.table — преобразуйте в data.table с помощью функции as.data.table() # fread сразу читает в data.table class(titanic) ## [1] &quot;data.table&quot; &quot;data.frame&quot; работа со строками # выберите те строки, где возраст пассажира меньше 1 (младенцы) titanic[age &lt; 1] ## pclass survived name sex age sibsp ## 1: 1 1 Allison, Master. Hudson Trevor male 0.92 1 ## 2: 2 1 Caldwell, Master. Alden Gates male 0.83 0 ## 3: 2 1 Hamalainen, Master. Viljo male 0.67 1 ## 4: 2 1 Richards, Master. George Sibley male 0.83 1 ## 5: 2 1 West, Miss. Barbara J female 0.92 1 ## 6: 3 1 Aks, Master. Philip Frank male 0.83 0 ## 7: 3 1 Baclini, Miss. Eugenie female 0.75 2 ## 8: 3 1 Baclini, Miss. Helene Barbara female 0.75 2 ## 9: 3 0 Danbom, Master. Gilbert Sigvard Emanuel male 0.33 0 ## 10: 3 1 Dean, Miss. Elizabeth Gladys &quot;&quot;Millvina&quot;&quot; female 0.17 1 ## 11: 3 0 Peacock, Master. Alfred Edward male 0.75 1 ## 12: 3 1 Thomas, Master. Assad Alexander male 0.42 0 ## parch ticket fare cabin embarked boat body ## 1: 2 113781 151.5500 C22 C26 S 11 NA ## 2: 2 248738 29.0000 S 13 NA ## 3: 1 250649 14.5000 S 4 NA ## 4: 1 29106 18.7500 S 4 NA ## 5: 2 C.A. 34651 27.7500 S 10 NA ## 6: 1 392091 9.3500 S 11 NA ## 7: 1 2666 19.2583 C C NA ## 8: 1 2666 19.2583 C C NA ## 9: 2 347080 14.4000 S NA ## 10: 2 C.A. 2315 20.5750 S 10 NA ## 11: 1 SOTON/O.Q. 3101315 13.7750 S NA ## 12: 1 2625 8.5167 C 16 NA ## home.dest ## 1: Montreal, PQ / Chesterville, ON ## 2: Bangkok, Thailand / Roseville, IL ## 3: Detroit, MI ## 4: Cornwall / Akron, OH ## 5: Bournmouth, England ## 6: London, England Norfolk, VA ## 7: Syria New York, NY ## 8: Syria New York, NY ## 9: Stanton, IA ## 10: Devon, England Wichita, KS ## 11: ## 12: # выберите те строки, где возраст пассажира в диапазоне 20 до 50 лет titanic[age &gt;= 20 &amp; age &lt;= 50] ## pclass survived name sex ## 1: 1 1 Allen, Miss. Elisabeth Walton female ## 2: 1 0 Allison, Mr. Hudson Joshua Creighton male ## 3: 1 0 Allison, Mrs. Hudson J C (Bessie Waldo Daniels) female ## 4: 1 1 Anderson, Mr. Harry male ## 5: 1 0 Andrews, Mr. Thomas Jr male ## --- ## 722: 3 0 Yasbeck, Mr. Antoni male ## 723: 3 0 Youseff, Mr. Gerious male ## 724: 3 0 Zakarian, Mr. Mapriededer male ## 725: 3 0 Zakarian, Mr. Ortin male ## 726: 3 0 Zimmerman, Mr. Leo male ## age sibsp parch ticket fare cabin embarked boat body ## 1: 29.0 0 0 24160 211.3375 B5 S 2 NA ## 2: 30.0 1 2 113781 151.5500 C22 C26 S 135 ## 3: 25.0 1 2 113781 151.5500 C22 C26 S NA ## 4: 48.0 0 0 19952 26.5500 E12 S 3 NA ## 5: 39.0 0 0 112050 0.0000 A36 S NA ## --- ## 722: 27.0 1 0 2659 14.4542 C C NA ## 723: 45.5 0 0 2628 7.2250 C 312 ## 724: 26.5 0 0 2656 7.2250 C 304 ## 725: 27.0 0 0 2670 7.2250 C NA ## 726: 29.0 0 0 315082 7.8750 S NA ## home.dest ## 1: St Louis, MO ## 2: Montreal, PQ / Chesterville, ON ## 3: Montreal, PQ / Chesterville, ON ## 4: New York, NY ## 5: Belfast, NI ## --- ## 722: ## 723: ## 724: ## 725: ## 726: # выберите строки по выжившим младенцам (survived) titanic[age &lt; 1 &amp; survived == 1] ## pclass survived name sex age sibsp ## 1: 1 1 Allison, Master. Hudson Trevor male 0.92 1 ## 2: 2 1 Caldwell, Master. Alden Gates male 0.83 0 ## 3: 2 1 Hamalainen, Master. Viljo male 0.67 1 ## 4: 2 1 Richards, Master. George Sibley male 0.83 1 ## 5: 2 1 West, Miss. Barbara J female 0.92 1 ## 6: 3 1 Aks, Master. Philip Frank male 0.83 0 ## 7: 3 1 Baclini, Miss. Eugenie female 0.75 2 ## 8: 3 1 Baclini, Miss. Helene Barbara female 0.75 2 ## 9: 3 1 Dean, Miss. Elizabeth Gladys &quot;&quot;Millvina&quot;&quot; female 0.17 1 ## 10: 3 1 Thomas, Master. Assad Alexander male 0.42 0 ## parch ticket fare cabin embarked boat body ## 1: 2 113781 151.5500 C22 C26 S 11 NA ## 2: 2 248738 29.0000 S 13 NA ## 3: 1 250649 14.5000 S 4 NA ## 4: 1 29106 18.7500 S 4 NA ## 5: 2 C.A. 34651 27.7500 S 10 NA ## 6: 1 392091 9.3500 S 11 NA ## 7: 1 2666 19.2583 C C NA ## 8: 1 2666 19.2583 C C NA ## 9: 2 C.A. 2315 20.5750 S 10 NA ## 10: 1 2625 8.5167 C 16 NA ## home.dest ## 1: Montreal, PQ / Chesterville, ON ## 2: Bangkok, Thailand / Roseville, IL ## 3: Detroit, MI ## 4: Cornwall / Akron, OH ## 5: Bournmouth, England ## 6: London, England Norfolk, VA ## 7: Syria New York, NY ## 8: Syria New York, NY ## 9: Devon, England Wichita, KS ## 10: # выберите пассажирок, которые имеют титул lady titanic[grep(&#39;lady&#39;, name, ignore.case = TRUE)] ## pclass survived ## 1: 1 1 ## 2: 1 1 ## 3: 3 1 ## 4: 3 0 ## name sex ## 1: Cherry, Miss. Gladys female ## 2: Duff Gordon, Lady. (Lucille Christiana Sutherland) (&quot;&quot;Mrs Morgan&quot;&quot;) female ## 3: Dean, Miss. Elizabeth Gladys &quot;&quot;Millvina&quot;&quot; female ## 4: Sage, Miss. Constance Gladys female ## age sibsp parch ticket fare cabin embarked boat body ## 1: 30.00 0 0 110152 86.500 B77 S 8 NA ## 2: 48.00 1 0 11755 39.600 A16 C 1 NA ## 3: 0.17 1 2 C.A. 2315 20.575 S 10 NA ## 4: NA 8 2 CA. 2343 69.550 S NA ## home.dest ## 1: London, England ## 2: London / Paris ## 3: Devon, England Wichita, KS ## 4: titanic[grep(&#39;Lady&#39;, name)] ## pclass survived ## 1: 1 1 ## name sex ## 1: Duff Gordon, Lady. (Lucille Christiana Sutherland) (&quot;&quot;Mrs Morgan&quot;&quot;) female ## age sibsp parch ticket fare cabin embarked boat body home.dest ## 1: 48 1 0 11755 39.6 A16 C 1 NA London / Paris # альтернативнй вариант, когда учитываем пробел (&#39; &#39; или &#39;\\\\s&#39;) titanic[grep(&#39;\\\\slady&#39;, name, ignore.case = TRUE)] ## pclass survived ## 1: 1 1 ## name sex ## 1: Duff Gordon, Lady. (Lucille Christiana Sutherland) (&quot;&quot;Mrs Morgan&quot;&quot;) female ## age sibsp parch ticket fare cabin embarked boat body home.dest ## 1: 48 1 0 11755 39.6 A16 C 1 NA London / Paris Основная формула dt-синтаксиса Общая формула data.table выглядит как dataset[выбор строк, операции над колонками, группировка]. То есть, указание, какие строки необходимо выделить, осуществляется в первой части (до первой запятой в синтаксисе data.table). Если нет необходимости выделять какие-то строки, перед первой запятой ничего не ставится. Параметр группировки (как и прочие параметры, кроме i и j - опциональны). Также можно провести параллели с синтаксисом SQL-запроса. В терминах SQL data.table-выражения выглядят как таблица[where, select, group by]. Создание data.table-таблиц Создать data.table можно следующим образом (синтаксис немного напоминает создание именованного списка, как и для всех форматов таблиц): # подключаем пакет, если не был подключен ранее library(data.table) # создаем датасет dt1 &lt;- data.table( month_names = month.name, month_abb = month.abb, month_ord = seq_len(length(month.abb)), is_winter = grepl(&#39;Jan|Dec|Feb&#39;, month.abb) ) print(dt1) ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Выбор строки Выбор строк в data.table осуществляется аналогично выбору элементов в векторе: по номеру строки или по какому-то условию. При выборе по номеру строки также можно указать вектор номеров строк, которые необходимо вернуть. При выборке строки по условию проверяется, удовлетворяет ли условию каждый элемент строки в определенной колонке, и если удовлетворяет, выделяется вся строка. # выбор по одному номеру строки dt1[1, ] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE # выбор по нескольким номерам строк # сначала создаем вектор номеров строк my_rows &lt;- c(2, 5, 8) # выводим строки, которые мы указали в векторе dt1[my_rows] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE # или, аналогично, сразу указываем, какие строки хотим выделить dt1[c(2, 5, 8)] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE Выбор по условию: мы сразу указываем название колонки, к значениям которых будем применять условие-фильтр. Писать в стиле dt1[dt1$month_ord &lt;= 3] избыточно, data.table понимает просто название колонки. # выводим все строки, в которых в колонке month_ord значения меньше или равны 3 dt1[month_ord &lt;= 3] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE Работа с колонками Обращение к колонке В синтаксисе data.table все операции над колонками производятся после первой запятой. Выделение колонок также относится к операциям над колонками. Для выделения одной или нескольких колонок необходимо просто указать лист (список) с названиями колонки или колонок. Если указать название колонки, то будут возвращены значения из этой колонки. Если название обернуть в list(), то будет возвращена таблица, с которой будет одна эта колонка: dt1[, month_names] ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; dt1[, list(month_names)] ## month_names ## 1: January ## 2: February ## 3: March ## 4: April ## 5: May ## 6: June ## 7: July ## 8: August ## 9: September ## 10: October ## 11: November ## 12: December Если посмотреть структуру, то оба объекта будут различаться - вектор строковых значений и таблица соответственно: str(dt1[, month_names]) ## chr [1:12] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; &quot;July&quot; ... str(dt1[, list(month_names)]) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 12 obs. of 1 variable: ## $ month_names: chr &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; Выбор нескольких колонок Если мы хотим на основе большой таблицы создать новую таблицу, с какими-то определенными колонками, мы их можем также перечислить в list(): dt1[, list(month_names, month_abb)] ## month_names month_abb ## 1: January Jan ## 2: February Feb ## 3: March Mar ## 4: April Apr ## 5: May May ## 6: June Jun ## 7: July Jul ## 8: August Aug ## 9: September Sep ## 10: October Oct ## 11: November Nov ## 12: December Dec При таком выделении можно сразу переименовывать колонки. Строго говоря, создается таблица с новой колонкой с требуемым именем, в которую записывается значения колонки, которую надо переименовать. Например: # выделяем в отдельную таблицу колонку month_names, month_abb # колонку month_names переименовываем в new_m_names dt3 &lt;- dt1[, list(new_m_names = month_names, month_abb)] print(dt3) ## new_m_names month_abb ## 1: January Jan ## 2: February Feb ## 3: March Mar ## 4: April Apr ## 5: May May ## 6: June Jun ## 7: July Jul ## 8: August Aug ## 9: September Sep ## 10: October Oct ## 11: November Nov ## 12: December Dec Cоздание колонок Создать новую колонку в синтаксисе data.table можно с помощью оператора :=. Это точно такая же операция над колонками, как и все прочие, просто происходит создание новой колонки: dt1[, new_col := 12:1] dt1 ## month_names month_abb month_ord is_winter new_col ## 1: January Jan 1 TRUE 12 ## 2: February Feb 2 TRUE 11 ## 3: March Mar 3 FALSE 10 ## 4: April Apr 4 FALSE 9 ## 5: May May 5 FALSE 8 ## 6: June Jun 6 FALSE 7 ## 7: July Jul 7 FALSE 6 ## 8: August Aug 8 FALSE 5 ## 9: September Sep 9 FALSE 4 ## 10: October Oct 10 FALSE 3 ## 11: November Nov 11 FALSE 2 ## 12: December Dec 12 TRUE 1 Модификация колонок Оператор := позволяет изменять объект на месте, поэтому мы можем просто колонке присвоить новое значение. Фактически мы на основе старой колонки создаем вектор новых значений и записываем его в в колонку с тем же названием. dt1[, new_col := new_col + 5] dt1 ## month_names month_abb month_ord is_winter new_col ## 1: January Jan 1 TRUE 17 ## 2: February Feb 2 TRUE 16 ## 3: March Mar 3 FALSE 15 ## 4: April Apr 4 FALSE 14 ## 5: May May 5 FALSE 13 ## 6: June Jun 6 FALSE 12 ## 7: July Jul 7 FALSE 11 ## 8: August Aug 8 FALSE 10 ## 9: September Sep 9 FALSE 9 ## 10: October Oct 10 FALSE 8 ## 11: November Nov 11 FALSE 7 ## 12: December Dec 12 TRUE 6 Можно совмещать фильтрацию по строкам и модификацию колонок. Например, для всех строк, где в колонке month_ord значения меньше или равны 5, в колонке new_col проставляем NA: dt1[month_ord &lt;= 5, new_col := NA] dt1 ## month_names month_abb month_ord is_winter new_col ## 1: January Jan 1 TRUE NA ## 2: February Feb 2 TRUE NA ## 3: March Mar 3 FALSE NA ## 4: April Apr 4 FALSE NA ## 5: May May 5 FALSE NA ## 6: June Jun 6 FALSE 12 ## 7: July Jul 7 FALSE 11 ## 8: August Aug 8 FALSE 10 ## 9: September Sep 9 FALSE 9 ## 10: October Oct 10 FALSE 8 ## 11: November Nov 11 FALSE 7 ## 12: December Dec 12 TRUE 6 Удаление колонок Удаление колонок осуществляется схожим образом, просто колонке присваивается значение NULL ## удаление колонок dt1[, new_col := NULL] dt1 ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Вычисления по одной колонке Так как каждая колонка в табличке — это вектор, к ним можно применять все функции, которые могут быть применены к векторам: # при создании новой колонки dt1[, month_ord_sqrt := sqrt(month_ord)] dt1[, new_col_1 := rnorm(.N)] # сэмпл из стандартного нормального распределения dt1[, new_col_2 := runif(.N)] # сэмпл из равномерного распределения # просто при вычислении какого-то значения # вычисление общей длины таблицы dt1[, .N] ## [1] 12 # вычисление среднего значения по какой-то колонке dt1[, mean(new_col_2)] ## [1] 0.4108885 Группировка по нескольким полям Часто возникает необходимость вычислений сразу по нескольким полям. dt2 &lt;- dt1[, list( # всего строк n_rows = .N, # среднее по колонке new_col_1 new_col_1_mn = mean(new_col_1), # медиана по колонке new_col_2 new_col_2_md = median(new_col_2) )] # в результате получаем вторую табличку dt2 ## n_rows new_col_1_mn new_col_2_md ## 1: 12 0.388513 0.4186747 .SD (Advanced) Также можно выделить колонки таблицы data.table c помощью конструкций .SD и .SDcols. .SD служит ярлыком-указателем на колонки с которыми надо провести какое-то действие, а .SDcols - собственно вектор названий колонок или порядковых номеров колонок в таблице. Если .SDcols не указано, то подразумеваются все колонки таблицы. Оборачивать в list() конструкцию .SD не нужно. Например: # смотрим содержание таблицы dt1[1:5] ## month_names month_abb month_ord is_winter month_ord_sqrt new_col_1 ## 1: January Jan 1 TRUE 1.000000 -0.4759508 ## 2: February Feb 2 TRUE 1.414214 0.7142790 ## 3: March Mar 3 FALSE 1.732051 0.1875781 ## 4: April Apr 4 FALSE 2.000000 0.2179694 ## 5: May May 5 FALSE 2.236068 0.2879338 ## new_col_2 ## 1: 0.73270125 ## 2: 0.02771502 ## 3: 0.15143099 ## 4: 0.73404003 ## 5: 0.61062807 # выделяем первую и третью колонки датасета dt1[1:5, .SD, .SDcols = c(1, 3)] ## month_names month_ord ## 1: January 1 ## 2: February 2 ## 3: March 3 ## 4: April 4 ## 5: May 5 # выделяем эти же колонки по названиям dt1[1:5, .SD, .SDcols = c(&#39;month_names&#39;, &#39;month_abb&#39;, &#39;month_ord&#39;)] ## month_names month_abb month_ord ## 1: January Jan 1 ## 2: February Feb 2 ## 3: March Mar 3 ## 4: April Apr 4 ## 5: May May 5 # выделяем эти же колонки по названиям, но паттерном &#39;month&#39; и использованием grep dt1[1:5, .SD, .SDcols = grep(&#39;month&#39;, names(dt1))] ## month_names month_abb month_ord month_ord_sqrt ## 1: January Jan 1 1.000000 ## 2: February Feb 2 1.414214 ## 3: March Mar 3 1.732051 ## 4: April Apr 4 2.000000 ## 5: May May 5 2.236068 # выделяем эти же колонки по названиям, но паттерном &#39;month&#39; и функцией patterns из пакета data.table dt1[1:5, .SD, .SDcols = patterns(&#39;month&#39;)] ## month_names month_abb month_ord month_ord_sqrt ## 1: January Jan 1 1.000000 ## 2: February Feb 2 1.414214 ## 3: March Mar 3 1.732051 ## 4: April Apr 4 2.000000 ## 5: May May 5 2.236068 .SD используется в большом количестве операций. Например, когда надо провести какую-то одну операцию над сразу несколькими колонками. Например, если мы хотим узнать, какого типа данные лежат в указанных колонках (пример искусственный, в реальности проще воспользоваться str()): dt1[, lapply(.SD, class), .SDcols = c(&#39;month_names&#39;, &#39;month_ord&#39;, &#39;is_winter&#39;)] ## month_names month_ord is_winter ## 1: character integer logical Полезные ссылки Моя серия вебинаров по data.table. Есть как запись, так и конспект. На занятиях мы будем рассматривать лишь половину или треть материала вебинаров. Базовые операции одновременно в data.table и dplyr-синтаксисе. Много полезных приемов, и, в целом, наглядно. Смотрите блоки по data.table, dplyr синтаксис можно игнорировать или смотреть для общего развития (это весьма часто используемый синтаксис в академии). Перевод документации data.table от Андрея Огурцова. Полезно для понимания разных нюансов работы data.table Продвинутый data.table для желающих, много неочевидных нюансов и трюков. Экзотические возможности и ключевые слова, для совсем экстремалов. Заметка важна в первую очередь внутренними ссылками на разные релевантные и поясняющие ресурсы. Интересный сайт, где каждой конструкции в pandas дана аналогичная конструкция в data.table. Некоторые конструкции, правда, избыточны или переусложнены, но в целом сопоставление адекватное. Домашнее задание работа с колонками посчитайте средний возраст пассажиров в датасете titanic аналогично, посчитайте summary() по возрасту женщин выделите в отдельный датасет всех погибших пассажиров, оставьте для них только значения пола, возраста и класса билета (pclass), переменную pclass переименуйте в class ** cделайте это с помощью .SD-синтаксиса и функции setnames() в полученном датасете посчитайте количество пассажиров, их средний и медианный возраст, разброс по возрасту (sd()) *в датасете titanic попробуйте построить логистическую регрессию (lm или glm, обязательно прочитайте справку), которая бы предсказывала вероятность выживания пассажира (survived). Возьмите все переменные как предиктор (формула будет survived ~ .). До решения следующего задания не смотрите на результат. ** Попробуйте выбрать те предикторы, которые вам субъективно кажутся наиболее влияющими на вероятность выживания пассажира. Постройте регрессию по ним. Возможно, вам потребуется синтаксис формул. *** Сравните две модели – и просто по статистикам, и кодом (одна из полезных ссылок, остальные при необходимости погуглите сами) для тех, кто любит посложнее Создайте датасет: несколько пользователей по 5 сессий на каждого пользователя. поле логина, тип – дата и время (таймстамп), все логины в интервале 1-9 сентября. В юникс-формате или просто дата и время, на ваше усмотрение. для каждой сессии создайте случайную длину сессии (достаточно просто вектор длиной со всю таблицу, без учета пользователей) в секундах. Длина сессии должна варьировать в пределах 120 - 600 секунд посчитайте количество пользователей, среднее количество сессий на пользователя, среднюю длину сессий. Без учета вариативности внутри пользователя, overall по всему датасету. Подсказки: датасет лучше создавать в несколько шагов есть полезная функция expand.grid() для генерации времени поможет функция as.POSIXct(), плюс есть немного справочных материалов в учебнике: раз, два ## uid sid login_ts session_length ## 1: user_1 1 2023-09-07 23:21:30 438 ## 2: user_1 2 2023-09-05 05:16:30 424 ## 3: user_1 3 2023-09-02 00:56:55 432 ## 4: user_1 4 2023-09-04 15:10:45 412 ## 5: user_1 5 2023-09-07 21:48:33 163 ## 6: user_2 1 2023-09-07 16:01:41 226 Статистики: ## n_users total_sessions session_per_user session_length_mn ## 1: 3 15 5 303.7333 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
