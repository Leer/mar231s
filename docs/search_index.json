[["index.html", "Автоматизированный сбор больших данных в экономико-социологических исследованиях Intro", " Автоматизированный сбор больших данных в экономико-социологических исследованиях Ph.A.Upravitelev 2023-12-06 Intro "],["overview.html", "Введение Запись занятия Data culture Обо мне Contacts MM invite link Syllabus R intro Синтаксис Окружение и подсказки Дополнительные материалы Домашнее задание", " Введение Запись занятия Запись занятия 9 сентября: Data culture Проект Data Culture направлен на то, чтобы у студентов всех программ бакалавриата Высшей школы экономики появилось понимание возможностей современных технологий в области Data Science. https://www.hse.ru/dataculture/ Обо мне продуктовый аналитик в Pixonic продуктовый аналитик в GameInsight аналитик в Консультант+ аспирант СПбГУ (когнитивная психология) Contacts @konhis в https://mm.upravitelev.info/ (основное средство коммуникации) upravitelev@gmail.com (дополнительное средство коммуникации) +7-965-425-5919 (для экстренных случаев) MM invite link Все взаимодействие по курсу будем вести в Mattermost (аналог Slack), это мессенджер для команд, очень популярен в IT и среди датасаентистов. https://mm.upravitelev.info/signup_user_complete/?id=cfm9gfrwstg3jfkybb9t65eo6e Syllabus Основы синтаксиса R. Виды источников данных. Импорт данных из разных типов файлов данныx - SPSS, Excel, *.csv и прочих. Методы сбора удаленных данных. Скрапинг полуструктурированных сайтов. Изучим XPath и как извлекать данные из html-кода страницы сайтов. Попутно научимся писать циклы и функции. Удаленные базы данных и API: простейшие API — что такое, зачем, как читать документацию. Работа с API VK и погодного сервиса. Анализ и представление результатов исследования: много времени будем уделять визуализациям. R intro Short history 1976: S language 1991-1993: R language by Ross Ihaka and Robert Gentleman 2000: stable beta 2011: RStudio 2011: Oracle R Enterprise 2015: Microsoft bought Revolution R 2017: Just-in-time compilations 2018: Speed improvements R ecosystem R Foundation https://www.r-project.org/foundation/ The Comprehensive R Archive Network: https://cran.r-project.org/ RStudio &amp; Hadley Wickham community R + RStudio R: https://cran.r-project.org/ (нужно установить самым первым) RStudio: https://www.rstudio.com/products/rstudio/download/ (после установки R) Альтернативные IDE https://colab.research.google.com/#create=true&amp;language=r (создает colab-ноутбук с R-ядром) https://posit.cloud/ (онлайн-версия RStudio) Style guide http://style.tidyverse.org/index.html Синтаксис Структура выражения result &lt;- sqrt(x = 4) sqrt() - функция. sqrt - название функции, в () указываются аргументы, к которым будет применяться функция с таким названием. x - обозначение аргумента функции (в разных функциях аргументы могут называться по-разному) 4 - значение, которое мы передаем в аргумент функции (к коротому будет применена функция) &lt;- - знак присваивания result - объект, в который мы записываем результат выполнения функции. Название объектов может быть разным (лучше придерживаться style guide при нейминге) Вывод на печать Прямое указание: print(result) ## [1] 2 Можно просто вызвать сам объект: result ## [1] 2 Присваивание Оператор &lt;- - это оператор присваивания. Если до этого объект не был создан, то таким образом мы создадим объект x, в котором содержится значение 5. Если до этого объект существовал, то ему будет присвоено новое значение. x &lt;- 5 print(x) ## [1] 5 Когда значение или результат функции записываем в объект, ничего не печатается. result &lt;- sqrt(x = 4) Если нет присвоения, а только простой вызов функции, то результат будет напечатан, как если это был какой-то объект. sqrt(x = 4) ## [1] 2 Операторы присвоения &lt;- (основной оператор) = (не рекомендуется, если только очень хочется) -&gt; (существует, но использовать крайне не рекомендуется) &lt;&lt;-, -&gt;&gt; (надо понимать, когда использовать, встречаются редко, лучше использовать assign()) Арифметические операторы В R помимо оператора присвоения есть другие операторы, в частности, арифметические операторы, операторы сравнения или логического выбора. Операторы сравнения или логические операторы обычно используются при необходимости указать какие-то условия для выбора элементов вектора или таблицы, а также в конструкциях if/else. Сложение: + Вычитание: - Умножение: * Деление: / Возведение в степень: ^, ** Остаток от деления: %% (5 %% 2 дает 1) Неполное частное деления: %/% (5 %/% 2 дает 2) Операторы сравнения тождество (равенство): == не равно: != больше/меньше или равно: &gt;=, &lt;= пропущено ли: is.na() (проверяет, является ли значение пропущенным, NA) Логические операторы И: &amp;, &amp;&amp; ИЛИ: |, || НЕ (Обратно): ! (TRUE превращает в FALSE и наоборот) Комментарии и кавычки #: строка, которая идет после этого знака, считается комментарием и не выполняется. Используется для того, чтобы прокомментировать код или скрыть от выполнения часть кода. '', \"\": использутся для создания строковых объектов, можно сочетать одной строке, они не взаимозаменяемы ``:обратные апострофы, используются в редких случаях, обычно в RMarkdown, инфиксных операторах или кириллических названиях объектов. Окружение и подсказки Полезные функции для работы с окружением При работе с R: install.packages('pkg') - установить пакет pkg или список пакетов. Делается однократно при настройке R library('pkg') - подключение установленного пакета - делается при каждом новом запуске сессии, если этот пакет планируется использовать getwd() - узнать адрес рабочей папки setwd() - никогда не использовать! Это мешает при работе с несколькими коллегами, может вызвать сбои при каких-то изменениях в структуре папок, да и в целом дурной тон. Лучше использовать проекты в RStudio, которые формируют отдельную папку под каждый проект. ls() - возвращает список созданных объектов рабочего окружения rm() - удалить какой-нибудь объект rm(list = ls()) - удалить все объекты рабочего окружения. Использовать только в консоли, никогда не использовать в скриптах, которые могут быть использованы другими людьми. help help(), ? (например, ?round)или ??. Проще всего выделить функцию и нажать F1 на клавиатуре. cheatsheets: https://www.rstudio.com/resources/cheatsheets/ google it! stackoverflow Стандартные ошибки в синтаксисе пропущенная / лишняя запятая пропущенная / лишняя / другого типа скобка Object not found опечатки (пропуск буквы, удвоение буквы, разный регистр, c кириллическая) no object / file / function / package Дополнительные материалы textbook.rintro.ru – мой учебник по основам R Курсы на data.camp. Они, как и все онлайн-курсы, несколько дробные и избыточные, но базам конструкций научить могут. На русском языке есть курс на степике. Вполне нормальный, особенно в первых частях. Еще есть курс Тони Антонова, он посложнее, но в чем-то получше и поосновательнее курса Карпова и Иванчея. Мороз Г. А. , Поздняков И. С. - Наука о данных в R для программы Цифровых гуманитарных исследований Селезнёв А. - Язык R для пользователей Excel Long J., Teetor P. - R cookbook Bryan J. - STAT 545 Data wrangling, exploration, and analysis with R Почему не надо использовать setwd() Домашнее задание Организационное / MM Вся коммуникация по курсу будет идти в mattermost. Для того, чтобы войти, перейдите по ссылке: https://mm.upravitelev.info/signup_user_complete/?id=cfm9gfrwstg3jfkybb9t65eo6e Вам предложат, какую версию вы хотите, веб-версию (в браузере) или мобильное приложение. Я лично использую обе, веб как основная. После этого вам предложат форму регистрации, в которой надо будет указать имя (фио или username как в телеграме, я предпочитаю указывать его), email (на него приходят уведомления о непрочитанных сообщения) и пароль. После этого вы окажетесь в основном окне мессенджера. По умолчанию это будет канал Town Square. Вверху справа расположена кнопка редактирования профиля (картинка с первыми буквами имени). Отредактируйте профиль: необходимо указать имя и фамилию (латиницей, в виде Name Family name), по возможности поставьте свою фотографию на аватарку. Слева расположен список каналов и пользователей. Вверху слева есть форма поиска каналов, найдите канал welcome и зайдите в него. В канале welcome напишите несколько слов о себе: тему своей магистерской (если уже известна), какой опыт работы с R и вообще языками программирования, какие ожидания от курса. R Установка R и RStudio установите язык R (https://cran.r-project.org/) установите Rstudio (RStudio: https://www.rstudio.com/products/rstudio/download/) Или воспользуйтесь онлайн-вариантами (Colab / Posit Cloud) RStudio Если используете RStudio (или VS Code / Pycharm / Posit Cloud) – создайте новый проект. При желании – изучите глобальные настройки и настройки проекта в меню Tools. Создайте папку practice. В ней предлагаю хранить скрипты с домашками. В дальнейшем появятся папки seminars, data, lib и другие. Если чувствуете в себе силы, создайте папку practice с помощью кода (надо погуглить соответствующую функцию). Тем, кто использует Jupyter Notebook / Jupyter Lab рекомендую создать отдельную папку по курсу и в ней также создать папку practice. Операторы и создание векторов Задание необязательное, но настоятельно рекомендую прорешать всем, кто ни разу не сталкивался с R или давно все забыл и не уверен в своих знаниях. Если решение какого-то задания вызвало у вас сомнения, напишите мне об этом в личке в mm. При работе используйте гайд по стилю оформления кода. Старайтесь, чтобы код был максимально простым. Если каждое упражнение занимает больше одной-двух строк — скорее всего вы что-то делаете не так. В проекте создайте новый скрипт, назовите его 2023-09-12.R (RStudio предлагает назвать файл при сохранении, а расширение предлагает по умолчанию) в папке practice. Новый скрипт можно создать в меню File &gt; New script, кнопкой вверху слева, комбинацией ctrl+shift+n. Или же в панели внизу справа, где перечислены файлы проекта. Дальнейшие задачи выполняйте в этом скрипте. Создайте объект x со значением 5. Создайте объект y, который равен 3 * x. Выведите его на печать. Проверьте, что значение выражения x - y не равно 84. Запишите в объект alarm результат сравнения, больше ли x чем y. Выведите объект на печать. Симулируйте выпадение какой-либо грани двенадцатигранного кубика (одно значение). Вам потребуется функция sample(). Симулируйте выпадение десяти бросков восьмигранного кубика. Задача решается также с помощью функции sample(). Найдите длину меньшего катета прямоугольного треугольника с катетом длиной 4 и гипотенузой длиной 8, и округлите длину до третьего знака. Вам потребуются оператор возведения в степень и функции sqrt() и round(). На всякий случай напомню, квадрат гипотенузы равен сумме квадратов катетов. "],["vectors.html", "Векторы Запись занятия Векторы Выбор элемента вектора Проверка на NA Домашнее задание", " Векторы Запись занятия Запись занятия 16 сентября: Векторы Простой набор значений одного атомарного типа. Атомарные типы данных numeric (integer для целых и double как аналог numeric). Используется для числовых значений. Некоторые функций, в частности, median() на вход требуют объекты типа numeric. character. Используется для строковых значений. Любой набор знаков, заключенный в кавычки, в R воспринимается как строковое значение. logical. Значения TRUE/FALSE. Создание векторов Чаще всего векторы создаются с помощью функции c() (c от combine). Например: x &lt;- c(1, 3, 5) print(x) ## [1] 1 3 5 Простую неименованную последовательность атомарного типа можно задать также другими командами, наиболее часто используемые из них: seq() — создание последовательности значений в указанном интервале, с заданным шагом (seq от sequence). Например: x &lt;- seq(from = 10, to = 2, by = -2) print(x) ## [1] 10 8 6 4 2 Первые два аргумента задают первое и последнее значения последовательности, а аргумент by - шаг последовательности (по умолчанию равен единице). Знак - для значения аргумента by маркирует, что последовательность убывающая. : — аналог функции seq(), используется для создания последовательности целых чисел, где последующее отличается от предыдущего на 1. Так выражение 5:1 тождественно выражению seq(5, 1, -1). rep() — повтор какого-либо элемента заданное число раз. В качестве элемента может выступать практически любой объект R (в зависимости от осмысленности в целом подобного выражения). Аргументы times или each задают, какое количество раз повторять весь объект или каждый элемент объекта соответственно: x &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) rep(x, times = 2) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; rep(x, each = 2) ## [1] &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; Если значения аргументов задавать позиционно, то первый аргумент — это итерируемый объект, а второй аргумент — аргумент times: rep(x, 2) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; sample() — создание последовательности случайно выбранных значений из какого-то заданного вектора значений. Первый аргумент задает выборку, из которой необходимо извлечь подвыборку, второй аргумент (size) определяет объем извлекаемой выборки. Аргумент replace определяет, выборка извлекается с возвращением элементов или нет: sample(x = 1:5, size = 5, replace = FALSE) ## [1] 5 4 2 1 3 sample(x = 1:5, size = 5, replace = TRUE) ## [1] 5 1 5 1 2 Приведение типов R используется достаточно простая система автоматического преобразования атомарных типов по логике от “самого строгого к самому гибкому”, то есть по цепочке logical -&gt; integer -&gt; numeric -&gt; complex -&gt; character (тип raw не включается в эту систему). Такое преобразование позволяет использовать конструкции вида sum(5 == 5), потому что логический результат сравнения (TRUE) будет преобразован в целое числовое значение (1, так как TRUE преобразовывается в 1, а FALSE - в 0), и, следовательно, можно вычислить количество верных утверждений. Подобные процедуры крайне часто используются когда, например, надо посчитать количество определенных значений в векторе значений (или в колонке в таблице). Вообще, для избежания неожиданных результатов, рекомендуется избегать неявных преобразований и контролировать типы самостоятельно. Примеры приведений типов, все приводится к самому общему: # к строке c(&#39;a&#39;, 3.6, &#39;b&#39;, 5.1, TRUE) ## [1] &quot;a&quot; &quot;3.6&quot; &quot;b&quot; &quot;5.1&quot; &quot;TRUE&quot; # к numeric c(TRUE, 3.6, 2) ## [1] 1.0 3.6 2.0 Выбор элемента вектора Выбор элементов векторов указывается с помощью оператора [ по следующей схеме: x[&lt;condition&gt;]. Это читается как 'элементы вектора x, которые удовлетворяют условию &lt;condition&gt;'. В качестве условия может быть номер элемента в последовательности (индекс), так и какое-то логическое условие. При использовании оператора [ в &lt;condition&gt; может быть передан вектор значений (или логическое выражение, возвращающее вектор значений). Выбор по номеру позиции Простой вариант выбора определенных элементов последовательности - по номеру в последовательности (по индексу, индекс начинается с 1). Например, в последовательности 4, 3, 2 на третьем месте находится значение 2. В коде выбор третьего элемента этой последовательности выглядит вот так: x &lt;- c(4, 3, 2) x[3] ## [1] 2 В список номеров последовательности также можно передавать не только единичное значение, но и вектор значений номеров последовательности, который мы хотим извлечь. Например: x &lt;- c(4, 3, 2, 1) x[c(2, 4)] ## [1] 3 1 Выбор по значению Также возможен выбор элементов вектора, которые удовлетворяют условию. Например, те, которые больше 10, или все, которые равны 3, или все четные. Логика такого выделения следующая: каждый элемент последовательности сравнивается с условием, и если сравнение верное (5 == 5, TRUE), то этот элемент возвращается как подходящий под условие. Фактически метка TRUE здесь является указателем элемента, который надо вернуть, аналогично номеру позиции при выделении по номеру позиции. Например: # создаем вектор 8 случайных значений из массива от 1 до 10 x &lt;- sample(1:10, 8) x ## [1] 10 6 5 4 1 8 2 7 # сравниваем каждое значение с 5, смотрим результат сравнения x_cond &lt;- x &gt; 5 x_cond ## [1] TRUE TRUE FALSE FALSE FALSE TRUE FALSE TRUE # делаем выбор по условию, с указанием вектора, удовлетворяет элемент условию или нет x[x_cond] ## [1] 10 6 8 7 # аналогично, но без создания отдельного вектора x[x &gt; 5] ## [1] 10 6 8 7 Проверка на NA В R есть несколько инструментов для работы с пропущенными или отсутствующими значениями. NA — not avaliable. Ситуация, когда значение пропущено. Например, для какой-то строки в колонке таблицы нет значения. NaN, Inf — not a number и infinite соответственно. Появляются при некорректных с математической точки зрения операциях (например, 0/0 и `1/0’ соответственно). NULL — объект и тип, используется в редких случаях, когда надо создать пустой объект (например x &lt;- NULL, но это плохая практика, для этого есть более корректные способы). Чаще нужен, когда надо удалить колонку в табличке. Для того, чтобы проверить, есть ли пропущенные значения в векторе, используется функция is.na(). Эта функция проверяет, есть ли значение у каждого элемента вектора (является NA или нет) и отдает вектор логических значений, где TRUE означает, что у соответствующего элемента в проверяемом векторе нет значения (он пропущен). # делаем вектор с одним NA-значением x &lt;- c(1, 3, NA, 5) # проверяем каждый элемент на то, пропущен он или нет # видим, что для третьего элемента стоит TRUE, то есть пропущен is.na(x) ## [1] FALSE FALSE TRUE FALSE Функцию is.na() можно точно также использовать для ивзлечения элементов вектора. Например, если мы хотим вернуть все не-пропущенные значения, нам надо воспользоваться оператор логического отрицания !. Этот оператор превращает TRUE в FALSE и наоборот: # смотрим, как работает оператор ! !TRUE ## [1] FALSE # пробуем извлечь все непропущенные значения из x x[!is.na(x)] ## [1] 1 3 5 Домашнее задание Из вектора month.name (уже есть в базовом R, не надо создавать) извлеките пятый элемент. Из вектора month.name извлеките все элементы кроме пятого. Из вектора month.name извлеките первый, пятый и последний элементы. ** Создайте вектор vec из первых семи элементов вектора letters (уже есть в базовом R, не надо создавать), перемешанных в случайном порядке. Примените к нему функцию order(). Проинтерпретируйте результат. *** Отсортируйте вектор vec с использованием order() и без использования sort() Сравните каждый элемент вектора vec &lt;- letters[1:5] с буквой c (равен или нет) и запишите в отдельный векторindices. Выведите indices на печать. Примените indices для выбора элементов вектора vec (vec[indices]). Проинтерпретируйте результат. Из вектора month.name извлеките каждый третий элемент (вам поможет материал первого занятия). Из вектора vec &lt;- sample(10, 8) выберите все элементы, значения которых больше либо равны 5. Из вектора vec &lt;- sample(100, 8) выберите максимальное значение (элемент с максимальным значением). *** Решите предыдущее задание с помощью функции which.max(). Прочитайте справку по функции и найдите “подводный камень”, который потенциально может привести к ошибкам. Попробуйте представить ситуацию, когда может возникнуть такая ошибка (необязательно при работе с векторами, например, при работе с таблицами). Из вектора vec &lt;- sample(100, 8) выберите максимальное и минимальное значения. "],["lists.html", "Списки и таблицы Запись занятия 23 сентября Векторы Векторизованные операции Recycling Изменение элементов объектов Списки Структура объектов Таблицы data.table Создание data.table-таблиц Основная формула dt-синтаксиса Создание data.table-таблиц Выбор строки Дополнительные материалы Домашнее задание", " Списки и таблицы Запись занятия 23 сентября Векторы Поиск по вхождению в массив Нередко встречаются ситуации, когда необходимо выбрать значения вектора, которые присутствуют в другом векторе. Например, из списка группы студентов выбрать тех, кто указан в списке недопущенных к сессии. Для этого используется выражение x %in% y. Оператор %in% проверяет, встречается ли каждый элемент вектора х в векторе y. Как и в сравнении по условию, в результате получается логический вектор, который можно использовать для выделения элементов. Выделенные элементы можно записать в отдельный объект. Например: x &lt;- c(1, 5, 2) y &lt;- seq(0, 10, 2) # сравниваем элементы списков x %in% y ## [1] FALSE FALSE TRUE # выделяем те элементы списка х, которые есть в у x[x %in% y] ## [1] 2 # записываем результат в отдельный объект z &lt;- x[x %in% y] str(z) ## num 2 Поиск по строке Для поиска по строковым записям (например, найти пользователя по ФИО, когда известно только имя) используют функцию grep() или grepl(). Первая функция возвращает номера элементов (или строк), в которых нашлось искомое строковое значение. Вторая функция возвращает результат проверки кадого элемента, включает ли он в себя искомый набор символов. # вектор строковых значений month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; # ищем значения, в которых есть буква r grep(&#39;r&#39;, month.name) ## [1] 1 2 3 4 9 10 11 12 grepl(&#39;r&#39;, month.name) ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE Первый аргумент — это паттерн регулярного выражения (если не используется аргумент fixed = TRUE): vec &lt;- c(&#39;user.1&#39;, &#39;user2&#39;) # в регэкспах точка -- служебный символ, его надо экранировать двумя слэшами vec[grep(&#39;\\\\.&#39;, vec)] ## [1] &quot;user.1&quot; # или указывать, что ищем именно точку, а не регэксп vec[grep(&#39;.&#39;, vec, fixed = TRUE)] ## [1] &quot;user.1&quot; Векторизованные операции Векторизация — наверное, одна из самых примечательных и важных особенностей R как языка программирования и инструмента работы с данными. Фраза векторизованная функция означает, что операции производятся сразу над каждым элементом вектора. То есть там, где в других языках программирования (например, в Python) необходимо писать цикл или лямбда-функцию, в R можно просто передать вектор в аргументы функции. Например, функция round(), если в качестве аргумента использовать вектор значений, округлит до нужного знака каждый элемент вектора: x &lt;- rnorm(5, 0, 1) x ## [1] 0.7176518 1.1558048 0.6662155 0.3622912 0.8780642 round(x, 3) ## [1] 0.718 1.156 0.666 0.362 0.878 В какой-то мере к векторизованным операциям можно отнести и простые арифметические операции над векторами. В частности, если мы попробуем сложить или умножить векторы одинаковой длины, то произойдет попарные сумма или произведение элементов векторов: # создаем векторы x &lt;- c(1, 5) y &lt;- c(7, 9) # смотрим значения векторов x ## [1] 1 5 y ## [1] 7 9 # сумма векторов x + y ## [1] 8 14 # произведение векторов x * y ## [1] 7 45 Recycling В том случае, когда в операции используется два вектора разной длины, используется правило ресайклинга (recycling). То есть короткий вектор начинает использоваться с начала, и так до тех пор, пока длины векторов не сойдутся. Например, мы хотим перемножить два вектора разной длины: x &lt;- 1:5 x ## [1] 1 2 3 4 5 y &lt;- c(3, 5, 7) y ## [1] 3 5 7 При перемножении операция элементы каждого вектора берутся попарно. Так как в векторе y всего три элемента, а в векторе x — пять, то элементы вектора y начинают использоваться повторно начиная с самого первого: x * y ## Warning in x * y: longer object length is not a multiple of shorter object ## length ## [1] 3 10 21 12 25 При этом интерпретатор R нам выдаст предупреждение, что длины не совпадают: Warning message: In x * y : longer object length is not a multiple of shorter object length Если использовать два вектора кратной длины (например, 2 и 4 элемента), то короткий вектор будет переиспользован, но предупреждения не будет: x &lt;- c(1, 5) y &lt;- c(1, 2, 3, 4) x * y ## [1] 1 10 3 20 Если учесть, что в R нет скаляров и x &lt;- 5 это создание вектора из одного элемента (единичного вектора), то умножение вектора на какое-то значение — то же самое умножение векторов с переиспользованием короткого вектора. Изменение элементов объектов В задачах на изменение значения элемента векторов, списков или таблиц используется следующая логика - указывается элемент объекта, с которым надо произвести какое-то действие, и этому элементу присваивается новое значение. Например, у нас есть вектор из 10 значений в случайном порядке от 1 до 10, и мы хотим возвести в квадрат третий элемент: # задаем зерно для псевдослучайной генерации set.seed(1234) # создаем вектор x &lt;- sample(10) str(x) ## int [1:10] 10 6 5 4 1 8 2 7 9 3 # возводим в квадрат третий элемент: x[3] &lt;- x[3] ^ 2 str(x) ## num [1:10] 10 6 25 4 1 8 2 7 9 3 Создание новых элементов или удаление уже существующих производятся аналогично - указывается индекс элемента (или его название, если применимо), и присваивается какое-то значение. Для создания элемента - любой объект, если он не нарушает уже существующую структуру (например, в таблице на пять строк нельзя создать колонку с шестью значениями), если в векторе создавать значение иного типа, чем был, то все значения будут преобразованы к более общему по правилам преобразования. # меняем 9 элемент вектора на &#39;x&#39;, текстовый x[9] &lt;- &#39;x&#39; str(x) ## chr [1:10] &quot;10&quot; &quot;6&quot; &quot;25&quot; &quot;4&quot; &quot;1&quot; &quot;8&quot; &quot;2&quot; &quot;7&quot; &quot;x&quot; &quot;3&quot; Для удаления элемента вектора можно просто сделать переприсвоение этому объекту тех же значений, за исключением того, которое требуется удалить: # удалим 3 значение вектора x x &lt;- x[-3] str(x) ## chr [1:9] &quot;10&quot; &quot;6&quot; &quot;4&quot; &quot;1&quot; &quot;8&quot; &quot;2&quot; &quot;7&quot; &quot;x&quot; &quot;3&quot; Списки Список элементов разных типов - векторов, таблиц, атомарных типов, других листов, функций и так далее. Длина и тип объекта в списке значения не имеет. Создание списков Для создания списка используется команда list(), где в аргументах через запятую перечисляются все элементы, которые необходимо включить в лист. Например: x &lt;- seq(from = 13, to = 0, by = -3) y &lt;- rep(x = &#39;c&#39;, times = 3) z &lt;- TRUE my_list &lt;- list(x, y, z) str(my_list) ## List of 3 ## $ : num [1:5] 13 10 7 4 1 ## $ : chr [1:3] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## $ : logi TRUE Именованные списки Помимо простого объединения объектов в списки и последующим вызовом элементов по номеру в списке, можно создавать именованные списки, где каждые элементы будут иметь заданное название. Например, x &lt;- seq(from = 13, to = 0, by = -3) y &lt;- rep(x = &#39;c&#39;, times = 3) z &lt;- TRUE my_list &lt;- list(seq_example = x, rep_example = y, atomic_example = z) print(my_list) ## $seq_example ## [1] 13 10 7 4 1 ## ## $rep_example ## [1] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## ## $atomic_example ## [1] TRUE Выбор элемента списка Выбор элементов списка также использует выбор по номеру элемента. Следует учитывать, что для списков несколько различается поведение операторов [ и [[. Так, оператор [ позволяет выделить элемент списка в виде отдельного списка: # создадим список my_list &lt;- list(seq_example = seq(from = 13, to = 0, by = -3), rep_example = rep(x = &#39;c&#39;, times = 3), atomic_example = TRUE) str(my_list) ## List of 3 ## $ seq_example : num [1:5] 13 10 7 4 1 ## $ rep_example : chr [1:3] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## $ atomic_example: logi TRUE # выберем первый элемент списка first_element &lt;- my_list[1] str(first_element) ## List of 1 ## $ seq_example: num [1:5] 13 10 7 4 1 Оператор [[ позволяет вызвать значения вызываемых элементов списка. Так, my_list[[1]] вызовет не первый элемент в виде списка, а значения первого элемента в виде вектора (как они и были заданы): # выберем значения первого элемента списка first_element_values &lt;- my_list[[1]] str(first_element_values) ## num [1:5] 13 10 7 4 1 Также для именованных списков можно использовать выделение по имени элемента. Для указания элемента списка используется оператор $ и конструкция вида list_name$element_name. Например: # смотрим на список my_list ## $seq_example ## [1] 13 10 7 4 1 ## ## $rep_example ## [1] &quot;c&quot; &quot;c&quot; &quot;c&quot; ## ## $atomic_example ## [1] TRUE # выбираем элемент seq_example str(my_list$seq_example) ## num [1:5] 13 10 7 4 1 Структура объектов Нередко при работе с разными объектами необходимо получить сводную информацию об объекте - класс объекта, иерархию элементов объекта, первые значения каждого элемента и так далее. Для этих целей используется функция str() (от structure), которая выводит каждый элемент объекта в виде вектора значений. Например, при просмотре структуры таблицы iris мы получаем класс объекта (data.frame), количество строк и столбцов, название колонок, тип элементов и первые десять значений каждой колонки: str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... При просмотре структуры списка, который в качестве одного из элементов содержит другой список, точно также отображается каждый элемент списка, его тип, в том числе и типы и элементы вложенного списка. Вложенный список дополнительно выделен точками и отступом: x &lt;- list(e1 = 1:5, e2 = letters[1:5], e3 = list(e31 = rnorm(5), e32 = runif(5))) str(x) ## List of 3 ## $ e1: int [1:5] 1 2 3 4 5 ## $ e2: chr [1:5] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ e3:List of 2 ## ..$ e31: num [1:5] 0.983 -0.622 -0.732 -0.517 -1.751 ## ..$ e32: num [1:5] 0.8106 0.5257 0.9147 0.8313 0.0458 Таблицы Таблица — это набор наблюдений по строкам и пространство признаков этих наблюдений в виде набора колонок. Базовый тип для табли в R - data.frame. На уровне структуры data.frame — это все те же списки, в которых могут храниться разные по типу объекты, однако с требованием равенства длины объектов. Важно: все значения одной колонки могут быть только одного типа (потому что это, по сути, векторы), а не как в Excel, OpenOffice или каком другом табличном процессоре. data.frame vs data.table vs dplyr Несмотря на то, что базовый тип таблиц это data.frame, в настоящее время используются варианты надстроек над этим типом: формат data.table или формат tibble из пактов data.table и dplyr соответственно. Различить их можно по элементам синтаксиса. В частности, data.frame почти всегда использует оператор $ (my_table$my_var), в data.table активно используется оператор :=, а в tibble - оператор %&gt;%. Пример создания таблицы и выбора строки по условию в data.frame: # создаем таблицу set.seed(1234) df &lt;- data.frame( var1 = sample(letters, 5), var2 = sample(1:5, 5) ) # смотрим результат print(df) ## var1 var2 ## 1 p 1 ## 2 v 5 ## 3 e 2 ## 4 l 3 ## 5 o 4 # обращаемся к значениям первой колонки df$var1 ## [1] &quot;p&quot; &quot;v&quot; &quot;e&quot; &quot;l&quot; &quot;o&quot; # выводим все строки, где в колонке var2 значения меньше или равны 3 df[df$var2 &lt;= 3, ] ## var1 var2 ## 1 p 1 ## 3 e 2 ## 4 l 3 Аналогичные операции в tibble-формате: set.seed(1234) library(dplyr) dp &lt;- tibble( var1 = sample(letters, 5), var2 = sample(1:5, 5) ) dp %&gt;% filter(var2 &lt;= 3) ## # A tibble: 3 × 2 ## var1 var2 ## &lt;chr&gt; &lt;int&gt; ## 1 p 1 ## 2 e 2 ## 3 l 3 data.table Преимущества data.table высокая скорость IO / манипуляций (бенчмарки) параллелизация вычислений по умолчанию опирается только на base R лаконичность выражений бережные апдейты забота об обратной совместимости Установка и подключение пакета # устанавливаем пакет (однократно) install.packages(&#39;data.table&#39;) # подключаем пакет (при каждой сессии) library(data.table) Создание data.table-таблиц Создать data.table можно следующим образом (синтаксис немного напоминает создание именованного списка, как и для всех форматов таблиц): # подключаем пакет, если не был подключен ранее library(data.table) ## ## Attaching package: &#39;data.table&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## between, first, last # создаем датасет dt1 &lt;- data.table( month_names = month.name, month_abb = month.abb, month_ord = seq_len(length(month.abb)), is_winter = grepl(&#39;Jan|Dec|Feb&#39;, month.abb) ) print(dt1) ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Основная формула dt-синтаксиса Общая формула data.table выглядит как dataset[выбор строк, операции над колонками, группировка]. То есть, указание, какие строки необходимо выделить, осуществляется в первой части (до первой запятой в синтаксисе data.table). Если нет необходимости выделять какие-то строки, перед первой запятой ничего не ставится. Параметр группировки (как и прочие параметры, кроме i и j - опциональны). Также можно провести параллели с синтаксисом SQL-запроса. В терминах SQL data.table-выражения выглядят как таблица[where, select, group by]. Создание data.table-таблиц Создать data.table можно следующим образом (синтаксис немного напоминает создание именованного списка, как и для всех форматов таблиц): # подключаем пакет, если не был подключен ранее library(data.table) # создаем датасет dt1 &lt;- data.table( month_names = month.name, month_abb = month.abb, month_ord = seq_len(length(month.abb)), is_winter = grepl(&#39;Jan|Dec|Feb&#39;, month.abb) ) print(dt1) ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Выбор строки Выбор строк в data.table осуществляется аналогично выбору элементов в векторе: по номеру строки или по какому-то условию. При выборе по номеру строки также можно указать вектор номеров строк, которые необходимо вернуть. При выборке строки по условию проверяется, удовлетворяет ли условию каждый элемент строки в определенной колонке, и если удовлетворяет, выделяется вся строка. # выбор по одному номеру строки dt1[1, ] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE # выбор по нескольким номерам строк # сначала создаем вектор номеров строк my_rows &lt;- c(2, 5, 8) # выводим строки, которые мы указали в векторе dt1[my_rows] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE # или, аналогично, сразу указываем, какие строки хотим выделить dt1[c(2, 5, 8)] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE Выбор по условию: мы сразу указываем название колонки, к значениям которых будем применять условие-фильтр. Писать в стиле dt1[dt1$month_ord &lt;= 3] избыточно, data.table понимает просто название колонки. # выводим все строки, в которых в колонке month_ord значения меньше или равны 3 dt1[month_ord &lt;= 3] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE Дополнительные материалы Про пакеты и их установку Получение информации об объекте Моя серия вебинаров по data.table. Есть как запись, так и конспект. На занятиях мы будем рассматривать лишь половину или треть материала вебинаров. Базовые операции одновременно в data.table и dplyr-синтаксисе. Много полезных приемов, и, в целом, наглядно. Смотрите блоки по data.table, dplyr синтаксис можно игнорировать или смотреть для общего развития (это весьма часто используемый синтаксис в академии). Перевод документации data.table от Андрея Огурцова. Полезно для понимания разных нюансов работы data.table Продвинутый data.table для желающих, много неочевидных нюансов и трюков. Экзотические возможности и ключевые слова, для совсем экстремалов. Заметка важна в первую очередь внутренними ссылками на разные релевантные и поясняющие ресурсы. Интересный сайт, где каждой конструкции в pandas дана аналогичная конструкция в data.table. Некоторые конструкции, правда, избыточны или переусложнены, но в целом сопоставление адекватное. Домашнее задание векторы Умножьте каждый элемент вектора vec &lt;- sample(10) на 2. Вычислите корень из каждого элемента вектора vec. Округлите значения до второго знака. В принципе для этого достаточно выражения длиной в 16 символов. выполните выражение paste('blabla', 1:3, letters [1:2], month.abb[1:4]). Разберитесь, почему получился такой результат. списки Код ниже создает иллюстрирует дисперсионный анализ. Прочитайте справки по iris и aov. Выполните выражения. # aov_stats &lt;- aov(Sepal.Length ~ Species, iris) aov_stats_summary &lt;- summary(aov_stats) Выведите на печать объект aov_stats_summary. Выведите на печать и проанализируйте структуру объекта. ***Выведите на печать уровень значимости (Pr(&gt;F)) таблицы. импорт данных подключите библиотеку data.table (установите, если не была установлена) скачайте файл titanic3.csv: https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv. с помощью команды titanic &lt;- fread('titanic3.csv') импортируйте файл в рабочее окружение. Прочитайте справку по функции fread() и попробуйте импортировать данные без явного сохранения на диск (не сработает с файлом в слаке). ** попробуйте написать код, в котором сначала происходит сохранение файла на диск, а потом чтение файла в рабочее окружение R (чтобы не руками сохранять, а кодом). посмотрите с помощью команды class() объекта. Если он отличается от data.table — преобразуйте в data.table с помощью функции as.data.table() работа со строками выберите случайным образом 5 строк из таблицы titanic выберите те строки, где возраст пассажира меньше 1 (младенцы) выберите те строки, где возраст пассажира в диапазоне 20 до 50 лет выберите строки по выжившим младенцам (survived) выберите пассажирок, которые имеют титул lady "],["data.table-pt1.html", "data.table pt1 Запись занятия Разбор домашней работы Основная формула dt-синтаксиса Создание data.table-таблиц Выбор строки Работа с колонками .SD (Advanced) Полезные ссылки Домашнее задание", " data.table pt1 Запись занятия Запись занятия 30 сентября: Разбор домашней работы списки Код ниже создает иллюстрирует дисперсионный анализ. Прочитайте справки по iris и aov. Выполните выражения. # aov_stats &lt;- aov(Sepal.Length ~ Species, iris) aov_stats_summary &lt;- summary(aov_stats) Выведите на печать объект aov_stats_summary. Выведите на печать и проанализируйте структуру объекта. ***Выведите на печать уровень значимости (Pr(&gt;F)) Решение. В списке aov_stat_summary неименованный подсписок. Этот подсписок является таблицей (data.frame). Соответственно, сначала нам надо обратиться к неименованному подсписку списка с помощью [[, а потом обратиться к первой строчке пятой колонки. Либо использовать то, что таблицы – это тоже списки, и обратиться к значению в синтаксисе списков, а не колонок. # смотрим структуру объекта str(aov_stats_summary) ## List of 1 ## $ :Classes &#39;anova&#39; and &#39;data.frame&#39;: 2 obs. of 5 variables: ## ..$ Df : num [1:2] 2 147 ## ..$ Sum Sq : num [1:2] 63.2 39 ## ..$ Mean Sq: num [1:2] 31.606 0.265 ## ..$ F value: num [1:2] 119 NA ## ..$ Pr(&gt;F) : num [1:2] 1.67e-31 NA ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;summary.aov&quot; &quot;listof&quot; # используем синтаксис списков aov_stats_summary[[1]]$`Pr(&gt;F)`[1] ## [1] 1.669669e-31 # используем синтаксис data.frame -- первая строка, пятая колонка aov_stats_summary[[1]][1, 5] ## [1] 1.669669e-31 # так как мы умеем работать только с data.table # конвертируем в data.table и извлекаем значение аналогично data.frame library(data.table) aov_stats &lt;- as.data.table(aov_stats_summary[[1]]) str(aov_stats) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 2 obs. of 5 variables: ## $ Df : num 2 147 ## $ Sum Sq : num 63.2 39 ## $ Mean Sq: num 31.606 0.265 ## $ F value: num 119 NA ## $ Pr(&gt;F) : num 1.67e-31 NA ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; # по номеру колонки aov_stats[1, 5] ## Pr(&gt;F) ## 1: 1.669669e-31 # по названию колонки aov_stats[1, `Pr(&gt;F)`] ## [1] 1.669669e-31 таблицы. импорт данных подключите библиотеку data.table (установите, если не была установлена) скачайте файл titanic3.csv: https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv. с помощью команды titanic &lt;- fread('titanic3.csv') импортируйте файл в рабочее окружение. Прочитайте справку по функции fread() и попробуйте импортировать данные без явного сохранения на диск (не сработает с файлом в слаке). # можно импортироватьс разу по ссылке titanic &lt;- fread(&#39;https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv&#39;) ** попробуйте написать код, в котором сначала происходит сохранение файла на диск, а потом чтение файла в рабочее окружение R (чтобы не руками сохранять, а кодом). # можно сохранить объект по ссылка на диск download.file( &#39;https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv&#39;, &#39;titanic_new.csv&#39; ) # и потом прочитать с диска titanic &lt;- fread(&#39;titanic_new.csv&#39;) посмотрите с помощью команды class() объекта. Если он отличается от data.table — преобразуйте в data.table с помощью функции as.data.table() # fread сразу читает в data.table class(titanic) ## [1] &quot;data.table&quot; &quot;data.frame&quot; работа со строками # выберите те строки, где возраст пассажира меньше 1 (младенцы) titanic[age &lt; 1] ## pclass survived name sex age sibsp ## 1: 1 1 Allison, Master. Hudson Trevor male 0.92 1 ## 2: 2 1 Caldwell, Master. Alden Gates male 0.83 0 ## 3: 2 1 Hamalainen, Master. Viljo male 0.67 1 ## 4: 2 1 Richards, Master. George Sibley male 0.83 1 ## 5: 2 1 West, Miss. Barbara J female 0.92 1 ## 6: 3 1 Aks, Master. Philip Frank male 0.83 0 ## 7: 3 1 Baclini, Miss. Eugenie female 0.75 2 ## 8: 3 1 Baclini, Miss. Helene Barbara female 0.75 2 ## 9: 3 0 Danbom, Master. Gilbert Sigvard Emanuel male 0.33 0 ## 10: 3 1 Dean, Miss. Elizabeth Gladys &quot;&quot;Millvina&quot;&quot; female 0.17 1 ## 11: 3 0 Peacock, Master. Alfred Edward male 0.75 1 ## 12: 3 1 Thomas, Master. Assad Alexander male 0.42 0 ## parch ticket fare cabin embarked boat body ## 1: 2 113781 151.5500 C22 C26 S 11 NA ## 2: 2 248738 29.0000 S 13 NA ## 3: 1 250649 14.5000 S 4 NA ## 4: 1 29106 18.7500 S 4 NA ## 5: 2 C.A. 34651 27.7500 S 10 NA ## 6: 1 392091 9.3500 S 11 NA ## 7: 1 2666 19.2583 C C NA ## 8: 1 2666 19.2583 C C NA ## 9: 2 347080 14.4000 S NA ## 10: 2 C.A. 2315 20.5750 S 10 NA ## 11: 1 SOTON/O.Q. 3101315 13.7750 S NA ## 12: 1 2625 8.5167 C 16 NA ## home.dest ## 1: Montreal, PQ / Chesterville, ON ## 2: Bangkok, Thailand / Roseville, IL ## 3: Detroit, MI ## 4: Cornwall / Akron, OH ## 5: Bournmouth, England ## 6: London, England Norfolk, VA ## 7: Syria New York, NY ## 8: Syria New York, NY ## 9: Stanton, IA ## 10: Devon, England Wichita, KS ## 11: ## 12: # выберите те строки, где возраст пассажира в диапазоне 20 до 50 лет titanic[age &gt;= 20 &amp; age &lt;= 50] ## pclass survived name sex ## 1: 1 1 Allen, Miss. Elisabeth Walton female ## 2: 1 0 Allison, Mr. Hudson Joshua Creighton male ## 3: 1 0 Allison, Mrs. Hudson J C (Bessie Waldo Daniels) female ## 4: 1 1 Anderson, Mr. Harry male ## 5: 1 0 Andrews, Mr. Thomas Jr male ## --- ## 722: 3 0 Yasbeck, Mr. Antoni male ## 723: 3 0 Youseff, Mr. Gerious male ## 724: 3 0 Zakarian, Mr. Mapriededer male ## 725: 3 0 Zakarian, Mr. Ortin male ## 726: 3 0 Zimmerman, Mr. Leo male ## age sibsp parch ticket fare cabin embarked boat body ## 1: 29.0 0 0 24160 211.3375 B5 S 2 NA ## 2: 30.0 1 2 113781 151.5500 C22 C26 S 135 ## 3: 25.0 1 2 113781 151.5500 C22 C26 S NA ## 4: 48.0 0 0 19952 26.5500 E12 S 3 NA ## 5: 39.0 0 0 112050 0.0000 A36 S NA ## --- ## 722: 27.0 1 0 2659 14.4542 C C NA ## 723: 45.5 0 0 2628 7.2250 C 312 ## 724: 26.5 0 0 2656 7.2250 C 304 ## 725: 27.0 0 0 2670 7.2250 C NA ## 726: 29.0 0 0 315082 7.8750 S NA ## home.dest ## 1: St Louis, MO ## 2: Montreal, PQ / Chesterville, ON ## 3: Montreal, PQ / Chesterville, ON ## 4: New York, NY ## 5: Belfast, NI ## --- ## 722: ## 723: ## 724: ## 725: ## 726: # выберите строки по выжившим младенцам (survived) titanic[age &lt; 1 &amp; survived == 1] ## pclass survived name sex age sibsp ## 1: 1 1 Allison, Master. Hudson Trevor male 0.92 1 ## 2: 2 1 Caldwell, Master. Alden Gates male 0.83 0 ## 3: 2 1 Hamalainen, Master. Viljo male 0.67 1 ## 4: 2 1 Richards, Master. George Sibley male 0.83 1 ## 5: 2 1 West, Miss. Barbara J female 0.92 1 ## 6: 3 1 Aks, Master. Philip Frank male 0.83 0 ## 7: 3 1 Baclini, Miss. Eugenie female 0.75 2 ## 8: 3 1 Baclini, Miss. Helene Barbara female 0.75 2 ## 9: 3 1 Dean, Miss. Elizabeth Gladys &quot;&quot;Millvina&quot;&quot; female 0.17 1 ## 10: 3 1 Thomas, Master. Assad Alexander male 0.42 0 ## parch ticket fare cabin embarked boat body ## 1: 2 113781 151.5500 C22 C26 S 11 NA ## 2: 2 248738 29.0000 S 13 NA ## 3: 1 250649 14.5000 S 4 NA ## 4: 1 29106 18.7500 S 4 NA ## 5: 2 C.A. 34651 27.7500 S 10 NA ## 6: 1 392091 9.3500 S 11 NA ## 7: 1 2666 19.2583 C C NA ## 8: 1 2666 19.2583 C C NA ## 9: 2 C.A. 2315 20.5750 S 10 NA ## 10: 1 2625 8.5167 C 16 NA ## home.dest ## 1: Montreal, PQ / Chesterville, ON ## 2: Bangkok, Thailand / Roseville, IL ## 3: Detroit, MI ## 4: Cornwall / Akron, OH ## 5: Bournmouth, England ## 6: London, England Norfolk, VA ## 7: Syria New York, NY ## 8: Syria New York, NY ## 9: Devon, England Wichita, KS ## 10: # выберите пассажирок, которые имеют титул lady titanic[grep(&#39;lady&#39;, name, ignore.case = TRUE)] ## pclass survived ## 1: 1 1 ## 2: 1 1 ## 3: 3 1 ## 4: 3 0 ## name sex ## 1: Cherry, Miss. Gladys female ## 2: Duff Gordon, Lady. (Lucille Christiana Sutherland) (&quot;&quot;Mrs Morgan&quot;&quot;) female ## 3: Dean, Miss. Elizabeth Gladys &quot;&quot;Millvina&quot;&quot; female ## 4: Sage, Miss. Constance Gladys female ## age sibsp parch ticket fare cabin embarked boat body ## 1: 30.00 0 0 110152 86.500 B77 S 8 NA ## 2: 48.00 1 0 11755 39.600 A16 C 1 NA ## 3: 0.17 1 2 C.A. 2315 20.575 S 10 NA ## 4: NA 8 2 CA. 2343 69.550 S NA ## home.dest ## 1: London, England ## 2: London / Paris ## 3: Devon, England Wichita, KS ## 4: titanic[grep(&#39;Lady&#39;, name)] ## pclass survived ## 1: 1 1 ## name sex ## 1: Duff Gordon, Lady. (Lucille Christiana Sutherland) (&quot;&quot;Mrs Morgan&quot;&quot;) female ## age sibsp parch ticket fare cabin embarked boat body home.dest ## 1: 48 1 0 11755 39.6 A16 C 1 NA London / Paris # альтернативнй вариант, когда учитываем пробел (&#39; &#39; или &#39;\\\\s&#39;) titanic[grep(&#39;\\\\slady&#39;, name, ignore.case = TRUE)] ## pclass survived ## 1: 1 1 ## name sex ## 1: Duff Gordon, Lady. (Lucille Christiana Sutherland) (&quot;&quot;Mrs Morgan&quot;&quot;) female ## age sibsp parch ticket fare cabin embarked boat body home.dest ## 1: 48 1 0 11755 39.6 A16 C 1 NA London / Paris Основная формула dt-синтаксиса Общая формула data.table выглядит как dataset[выбор строк, операции над колонками, группировка]. То есть, указание, какие строки необходимо выделить, осуществляется в первой части (до первой запятой в синтаксисе data.table). Если нет необходимости выделять какие-то строки, перед первой запятой ничего не ставится. Параметр группировки (как и прочие параметры, кроме i и j - опциональны). Также можно провести параллели с синтаксисом SQL-запроса. В терминах SQL data.table-выражения выглядят как таблица[where, select, group by]. Создание data.table-таблиц Создать data.table можно следующим образом (синтаксис немного напоминает создание именованного списка, как и для всех форматов таблиц): # подключаем пакет, если не был подключен ранее library(data.table) # создаем датасет dt1 &lt;- data.table( month_names = month.name, month_abb = month.abb, month_ord = seq_len(length(month.abb)), is_winter = grepl(&#39;Jan|Dec|Feb&#39;, month.abb) ) print(dt1) ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Выбор строки Выбор строк в data.table осуществляется аналогично выбору элементов в векторе: по номеру строки или по какому-то условию. При выборе по номеру строки также можно указать вектор номеров строк, которые необходимо вернуть. При выборке строки по условию проверяется, удовлетворяет ли условию каждый элемент строки в определенной колонке, и если удовлетворяет, выделяется вся строка. # выбор по одному номеру строки dt1[1, ] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE # выбор по нескольким номерам строк # сначала создаем вектор номеров строк my_rows &lt;- c(2, 5, 8) # выводим строки, которые мы указали в векторе dt1[my_rows] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE # или, аналогично, сразу указываем, какие строки хотим выделить dt1[c(2, 5, 8)] ## month_names month_abb month_ord is_winter ## 1: February Feb 2 TRUE ## 2: May May 5 FALSE ## 3: August Aug 8 FALSE Выбор по условию: мы сразу указываем название колонки, к значениям которых будем применять условие-фильтр. Писать в стиле dt1[dt1$month_ord &lt;= 3] избыточно, data.table понимает просто название колонки. # выводим все строки, в которых в колонке month_ord значения меньше или равны 3 dt1[month_ord &lt;= 3] ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE Работа с колонками Обращение к колонке В синтаксисе data.table все операции над колонками производятся после первой запятой. Выделение колонок также относится к операциям над колонками. Для выделения одной или нескольких колонок необходимо просто указать лист (список) с названиями колонки или колонок. Если указать название колонки, то будут возвращены значения из этой колонки. Если название обернуть в list(), то будет возвращена таблица, с которой будет одна эта колонка: dt1[, month_names] ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; dt1[, list(month_names)] ## month_names ## 1: January ## 2: February ## 3: March ## 4: April ## 5: May ## 6: June ## 7: July ## 8: August ## 9: September ## 10: October ## 11: November ## 12: December Если посмотреть структуру, то оба объекта будут различаться - вектор строковых значений и таблица соответственно: str(dt1[, month_names]) ## chr [1:12] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; &quot;July&quot; ... str(dt1[, list(month_names)]) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 12 obs. of 1 variable: ## $ month_names: chr &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; Выбор нескольких колонок Если мы хотим на основе большой таблицы создать новую таблицу, с какими-то определенными колонками, мы их можем также перечислить в list(): dt1[, list(month_names, month_abb)] ## month_names month_abb ## 1: January Jan ## 2: February Feb ## 3: March Mar ## 4: April Apr ## 5: May May ## 6: June Jun ## 7: July Jul ## 8: August Aug ## 9: September Sep ## 10: October Oct ## 11: November Nov ## 12: December Dec При таком выделении можно сразу переименовывать колонки. Строго говоря, создается таблица с новой колонкой с требуемым именем, в которую записывается значения колонки, которую надо переименовать. Например: # выделяем в отдельную таблицу колонку month_names, month_abb # колонку month_names переименовываем в new_m_names dt3 &lt;- dt1[, list(new_m_names = month_names, month_abb)] print(dt3) ## new_m_names month_abb ## 1: January Jan ## 2: February Feb ## 3: March Mar ## 4: April Apr ## 5: May May ## 6: June Jun ## 7: July Jul ## 8: August Aug ## 9: September Sep ## 10: October Oct ## 11: November Nov ## 12: December Dec Cоздание колонок Создать новую колонку в синтаксисе data.table можно с помощью оператора :=. Это точно такая же операция над колонками, как и все прочие, просто происходит создание новой колонки: dt1[, new_col := 12:1] dt1 ## month_names month_abb month_ord is_winter new_col ## 1: January Jan 1 TRUE 12 ## 2: February Feb 2 TRUE 11 ## 3: March Mar 3 FALSE 10 ## 4: April Apr 4 FALSE 9 ## 5: May May 5 FALSE 8 ## 6: June Jun 6 FALSE 7 ## 7: July Jul 7 FALSE 6 ## 8: August Aug 8 FALSE 5 ## 9: September Sep 9 FALSE 4 ## 10: October Oct 10 FALSE 3 ## 11: November Nov 11 FALSE 2 ## 12: December Dec 12 TRUE 1 Модификация колонок Оператор := позволяет изменять объект на месте, поэтому мы можем просто колонке присвоить новое значение. Фактически мы на основе старой колонки создаем вектор новых значений и записываем его в в колонку с тем же названием. dt1[, new_col := new_col + 5] dt1 ## month_names month_abb month_ord is_winter new_col ## 1: January Jan 1 TRUE 17 ## 2: February Feb 2 TRUE 16 ## 3: March Mar 3 FALSE 15 ## 4: April Apr 4 FALSE 14 ## 5: May May 5 FALSE 13 ## 6: June Jun 6 FALSE 12 ## 7: July Jul 7 FALSE 11 ## 8: August Aug 8 FALSE 10 ## 9: September Sep 9 FALSE 9 ## 10: October Oct 10 FALSE 8 ## 11: November Nov 11 FALSE 7 ## 12: December Dec 12 TRUE 6 Можно совмещать фильтрацию по строкам и модификацию колонок. Например, для всех строк, где в колонке month_ord значения меньше или равны 5, в колонке new_col проставляем NA: dt1[month_ord &lt;= 5, new_col := NA] dt1 ## month_names month_abb month_ord is_winter new_col ## 1: January Jan 1 TRUE NA ## 2: February Feb 2 TRUE NA ## 3: March Mar 3 FALSE NA ## 4: April Apr 4 FALSE NA ## 5: May May 5 FALSE NA ## 6: June Jun 6 FALSE 12 ## 7: July Jul 7 FALSE 11 ## 8: August Aug 8 FALSE 10 ## 9: September Sep 9 FALSE 9 ## 10: October Oct 10 FALSE 8 ## 11: November Nov 11 FALSE 7 ## 12: December Dec 12 TRUE 6 Удаление колонок Удаление колонок осуществляется схожим образом, просто колонке присваивается значение NULL ## удаление колонок dt1[, new_col := NULL] dt1 ## month_names month_abb month_ord is_winter ## 1: January Jan 1 TRUE ## 2: February Feb 2 TRUE ## 3: March Mar 3 FALSE ## 4: April Apr 4 FALSE ## 5: May May 5 FALSE ## 6: June Jun 6 FALSE ## 7: July Jul 7 FALSE ## 8: August Aug 8 FALSE ## 9: September Sep 9 FALSE ## 10: October Oct 10 FALSE ## 11: November Nov 11 FALSE ## 12: December Dec 12 TRUE Вычисления по одной колонке Так как каждая колонка в табличке — это вектор, к ним можно применять все функции, которые могут быть применены к векторам: # при создании новой колонки dt1[, month_ord_sqrt := sqrt(month_ord)] dt1[, new_col_1 := rnorm(.N)] # сэмпл из стандартного нормального распределения dt1[, new_col_2 := runif(.N)] # сэмпл из равномерного распределения # просто при вычислении какого-то значения # вычисление общей длины таблицы dt1[, .N] ## [1] 12 # вычисление среднего значения по какой-то колонке dt1[, mean(new_col_2)] ## [1] 0.4535934 Группировка по нескольким полям Часто возникает необходимость вычислений сразу по нескольким полям. dt2 &lt;- dt1[, list( # всего строк n_rows = .N, # среднее по колонке new_col_1 new_col_1_mn = mean(new_col_1), # медиана по колонке new_col_2 new_col_2_md = median(new_col_2) )] # в результате получаем вторую табличку dt2 ## n_rows new_col_1_mn new_col_2_md ## 1: 12 0.2073841 0.4006936 .SD (Advanced) Также можно выделить колонки таблицы data.table c помощью конструкций .SD и .SDcols. .SD служит ярлыком-указателем на колонки с которыми надо провести какое-то действие, а .SDcols - собственно вектор названий колонок или порядковых номеров колонок в таблице. Если .SDcols не указано, то подразумеваются все колонки таблицы. Оборачивать в list() конструкцию .SD не нужно. Например: # смотрим содержание таблицы dt1[1:5] ## month_names month_abb month_ord is_winter month_ord_sqrt new_col_1 ## 1: January Jan 1 TRUE 1.000000 0.008867389 ## 2: February Feb 2 TRUE 1.414214 0.879013954 ## 3: March Mar 3 FALSE 1.732051 1.184190317 ## 4: April Apr 4 FALSE 2.000000 -0.377971273 ## 5: May May 5 FALSE 2.236068 0.661905254 ## new_col_2 ## 1: 0.09997129 ## 2: 0.79143496 ## 3: 0.78484964 ## 4: 0.01111225 ## 5: 0.59760540 # выделяем первую и третью колонки датасета dt1[1:5, .SD, .SDcols = c(1, 3)] ## month_names month_ord ## 1: January 1 ## 2: February 2 ## 3: March 3 ## 4: April 4 ## 5: May 5 # выделяем эти же колонки по названиям dt1[1:5, .SD, .SDcols = c(&#39;month_names&#39;, &#39;month_abb&#39;, &#39;month_ord&#39;)] ## month_names month_abb month_ord ## 1: January Jan 1 ## 2: February Feb 2 ## 3: March Mar 3 ## 4: April Apr 4 ## 5: May May 5 # выделяем эти же колонки по названиям, но паттерном &#39;month&#39; и использованием grep dt1[1:5, .SD, .SDcols = grep(&#39;month&#39;, names(dt1))] ## month_names month_abb month_ord month_ord_sqrt ## 1: January Jan 1 1.000000 ## 2: February Feb 2 1.414214 ## 3: March Mar 3 1.732051 ## 4: April Apr 4 2.000000 ## 5: May May 5 2.236068 # выделяем эти же колонки по названиям, но паттерном &#39;month&#39; и функцией patterns из пакета data.table dt1[1:5, .SD, .SDcols = patterns(&#39;month&#39;)] ## month_names month_abb month_ord month_ord_sqrt ## 1: January Jan 1 1.000000 ## 2: February Feb 2 1.414214 ## 3: March Mar 3 1.732051 ## 4: April Apr 4 2.000000 ## 5: May May 5 2.236068 .SD используется в большом количестве операций. Например, когда надо провести какую-то одну операцию над сразу несколькими колонками. Например, если мы хотим узнать, какого типа данные лежат в указанных колонках (пример искусственный, в реальности проще воспользоваться str()): dt1[, lapply(.SD, class), .SDcols = c(&#39;month_names&#39;, &#39;month_ord&#39;, &#39;is_winter&#39;)] ## month_names month_ord is_winter ## 1: character integer logical Полезные ссылки Моя серия вебинаров по data.table. Есть как запись, так и конспект. На занятиях мы будем рассматривать лишь половину или треть материала вебинаров. Базовые операции одновременно в data.table и dplyr-синтаксисе. Много полезных приемов, и, в целом, наглядно. Смотрите блоки по data.table, dplyr синтаксис можно игнорировать или смотреть для общего развития (это весьма часто используемый синтаксис в академии). Перевод документации data.table от Андрея Огурцова. Полезно для понимания разных нюансов работы data.table Продвинутый data.table для желающих, много неочевидных нюансов и трюков. Экзотические возможности и ключевые слова, для совсем экстремалов. Заметка важна в первую очередь внутренними ссылками на разные релевантные и поясняющие ресурсы. Интересный сайт, где каждой конструкции в pandas дана аналогичная конструкция в data.table. Некоторые конструкции, правда, избыточны или переусложнены, но в целом сопоставление адекватное. Домашнее задание работа с колонками посчитайте средний возраст пассажиров в датасете titanic аналогично, посчитайте summary() по возрасту женщин выделите в отдельный датасет всех погибших пассажиров, оставьте для них только значения пола, возраста и класса билета (pclass), переменную pclass переименуйте в class ** cделайте это с помощью .SD-синтаксиса и функции setnames() в полученном датасете посчитайте количество пассажиров, их средний и медианный возраст, разброс по возрасту (sd()) *в датасете titanic попробуйте построить логистическую регрессию (lm или glm, обязательно прочитайте справку), которая бы предсказывала вероятность выживания пассажира (survived). Возьмите все переменные как предиктор (формула будет survived ~ .). До решения следующего задания не смотрите на результат. ** Попробуйте выбрать те предикторы, которые вам субъективно кажутся наиболее влияющими на вероятность выживания пассажира. Постройте регрессию по ним. Возможно, вам потребуется синтаксис формул. *** Сравните две модели – и просто по статистикам, и кодом (одна из полезных ссылок, остальные при необходимости погуглите сами) для тех, кто любит посложнее Создайте датасет: несколько пользователей по 5 сессий на каждого пользователя. поле логина, тип – дата и время (таймстамп), все логины в интервале 1-9 сентября. В юникс-формате или просто дата и время, на ваше усмотрение. для каждой сессии создайте случайную длину сессии (достаточно просто вектор длиной со всю таблицу, без учета пользователей) в секундах. Длина сессии должна варьировать в пределах 120 - 600 секунд посчитайте количество пользователей, среднее количество сессий на пользователя, среднюю длину сессий. Без учета вариативности внутри пользователя, overall по всему датасету. Подсказки: датасет лучше создавать в несколько шагов есть полезная функция expand.grid() для генерации времени поможет функция as.POSIXct(), плюс есть немного справочных материалов в учебнике: раз, два ## uid sid login_ts session_length ## 1: user_1 1 2023-09-02 04:58:49 253 ## 2: user_1 2 2023-09-02 08:59:34 196 ## 3: user_1 3 2023-09-02 13:02:01 457 ## 4: user_1 4 2023-09-03 02:44:56 410 ## 5: user_1 5 2023-09-04 02:30:40 147 ## 6: user_2 1 2023-09-04 18:24:34 538 Статистики: ## n_users total_sessions session_per_user session_length_mn ## 1: 3 15 5 293.6 "],["data.table-pt2.html", "data.table pt2 Запись занятия Разбор домашней работы Применение функций Применение функций Агрегации Манипуляции с таблицами Домашнее задание", " data.table pt2 Запись занятия Запись занятия 7 октября: Разбор домашней работы работа с колонками выделите в отдельный датасет всех погибших пассажиров, оставьте для них только значения пола, возраста и класса билета (pclass), переменную pclass переименуйте в class library(data.table) titanic &lt;- fread(&#39;https://gitlab.com/hse_mar/mar221s/-/raw/master/data/titanic3.csv&#39;) titanic_not_survived &lt;- titanic[survived == 0, list(sex, age, class = pclass)] str(titanic_not_survived) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 809 obs. of 3 variables: ## $ sex : chr &quot;female&quot; &quot;male&quot; &quot;female&quot; &quot;male&quot; ... ## $ age : num 2 30 25 39 71 47 NA 24 36 25 ... ## $ class: int 1 1 1 1 1 1 1 1 1 1 ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; в полученном датасете посчитайте количество пассажиров, их средний и медианный возраст, разброс по возрасту (sd()) titanic_not_survived[, list( n_rows = .N, age_mn = mean(age, na.rm = TRUE), age_md = median(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE))] ## n_rows age_mn age_md age_sd ## 1: 809 30.54536 28 13.92255 *в датасете titanic попробуйте построить логистическую регрессию, которая бы предсказывала вероятность выживания пассажира (survived). lm_fit &lt;- glm(survived ~ sex + age + pclass + fare, data = titanic, family = &#39;binomial&#39;) summary(lm_fit) ## ## Call: ## glm(formula = survived ~ sex + age + pclass + fare, family = &quot;binomial&quot;, ## data = titanic) ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 4.5009747 0.4616310 9.750 &lt; 2e-16 *** ## sexmale -2.4899900 0.1669830 -14.912 &lt; 2e-16 *** ## age -0.0336871 0.0062977 -5.349 8.84e-08 *** ## pclass -1.1079840 0.1284987 -8.623 &lt; 2e-16 *** ## fare 0.0006614 0.0017242 0.384 0.701 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 1413.57 on 1044 degrees of freedom ## Residual deviance: 982.81 on 1040 degrees of freedom ## (264 observations deleted due to missingness) ## AIC: 992.81 ## ## Number of Fisher Scoring iterations: 4 для тех, кто любит посложнее Создайте датасет: несколько пользователей по 5 сессий на каждого пользователя. поле логина, тип – дата и время (таймстамп), все логины в интервале 1-9 сентября. В юникс-формате или просто дата и время, на ваше усмотрение. для каждой сессии создайте случайную длину сессии (достаточно просто вектор длиной со всю таблицу, без учета пользователей) в секундах. Длина сессии должна варьировать в пределах 120 - 600 секунд посчитайте количество пользователей, среднее количество сессий на пользователя, среднюю длину сессий. Без учета вариативности внутри пользователя, overall по всему датасету. Подсказки: датасет лучше создавать в несколько шагов есть полезная функция expand.grid() для генерации времени поможет функция as.POSIXct(), плюс есть немного справочных материалов в учебнике: раз, два my_dt &lt;- expand.grid( paste0(&#39;user_&#39;, 1:3), 1:5 ) my_dt &lt;- as.data.table(my_dt) setnames(my_dt, c(&#39;uid&#39;, &#39;sid&#39;)) setkey(my_dt, &#39;uid&#39;) time_seq &lt;- seq(as.POSIXct(&quot;2023-09-01 00:00:00&quot;), as.POSIXct(&quot;2023-09-09 23:59:59&quot;), by = &quot;s&quot;) my_dt[, login_ts := sort(sample(time_seq, .N))] my_dt[, session_length := sample(120:600, .N)] head(my_dt) ## uid sid login_ts session_length ## 1: user_1 1 2023-09-01 11:02:03 563 ## 2: user_1 2 2023-09-01 15:24:45 126 ## 3: user_1 3 2023-09-01 20:07:25 201 ## 4: user_1 4 2023-09-03 07:09:35 549 ## 5: user_1 5 2023-09-03 20:34:08 178 ## 6: user_2 1 2023-09-04 08:39:07 534 Применение функций dataset library(data.table) # импортируем по ссылке sw &lt;- fread(&#39;http://bit.ly/39aOUne&#39;) # смотрим структуру объекта str(sw) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 77 obs. of 6 variables: ## $ name : chr &quot;Luke Skywalker&quot; &quot;C-3PO&quot; &quot;Darth Vader&quot; &quot;Owen Lars&quot; ... ## $ height : int 172 167 202 178 165 97 183 188 163 183 ... ## $ mass : num 77 75 136 120 75 32 84 84 NA NA ... ## $ skin_color : chr &quot;fair&quot; &quot;gold&quot; &quot;white&quot; &quot;light&quot; ... ## $ gender : chr &quot;male&quot; &quot;n/a&quot; &quot;male&quot; &quot;male&quot; ... ## $ planet_name: chr &quot;Tatooine&quot; &quot;Tatooine&quot; &quot;Tatooine&quot; &quot;Tatooine&quot; ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; Применение функций Количество строк и значений: .N, uniqueN В data.table есть пара полезных функций, которые позволяет быстро и лаконично считать количество значений и количество уникальных значений. Считаем количество строк в табличке - для этого используется функция .N (в data.table есть еще несколько функций, которые начинаются с ., но мы их почти не будем касаться). sw[, .N] ## [1] 77 Функция uniqueN() считает количество уникальных значений. Аналогична сочетанию двух функций length() + unique(), просто короче и быстрее. sw[, uniqueN(planet_name)] ## [1] 48 Ветвления: ifelse / fifelse В R есть два вида ветвлений с использованием if. Первое - стандартная для многих языков конструкция if {} else{}, она используется при создании функций и т.д. Для работы с таблицами полезнее функция ifelse() или ее быстрый аналог в data.table - fifelse (f от fast). В первом аргументе функции мы указываем проверку, в результате которой можно будет сказать TRUE или FALSE. Вторым аргументом - что должно быть возвращено, если результат проверки будет TRUE (логическое утверждение из первого аргумента истинно). Третий аргумент - что должно быть возвращено, если утверждение из первого аргумента ложно. Например, мы проверяем, истинно ли, что 5 тождественно 3. Так как 5 не равно трем, результатом сравнения 5 == 3 будет FALSE (утверждение ложно), соответственно, результатом ifelse() будет 'значение если неверно'. 5 == 3 ## [1] FALSE ifelse(5 == 3, &#39;значение если верно&#39;, &#39;значение если неверно&#39;) ## [1] &quot;значение если неверно&quot; Ключевое отличие ifelse() от классического if {} else{} в том, что эта функция векторизована. То есть, если в первом аргументе сравнивать вектор с каким-то значением, то проверка будет применяться к каждому элементу вектора. Соответственно, и результатов ifelse будет столько же, сколько элементов в векторе. my_vec &lt;- c(5, 3, 9) ifelse(my_vec == 3, &#39;значение если верно&#39;, &#39;значение если неверно&#39;) ## [1] &quot;значение если неверно&quot; &quot;значение если верно&quot; &quot;значение если неверно&quot; Все это позволяет использовать ifelse/fifelse для операций над колонками - например, в примере мы проверяем с помощью функции grepl, встречается ли в значениях ячеек в колонке skin_color слово grey. И если встречается - то в новую колонку будет проставлено значение grey, а если не всречается - no grey. sw[, new := fifelse(grepl(&#39;grey&#39;, skin_color), &#39;grey&#39;, &#39;no grey&#39;)] sw[1:10, list(name, skin_color, new)] ## name skin_color new ## 1: Luke Skywalker fair no grey ## 2: C-3PO gold no grey ## 3: Darth Vader white no grey ## 4: Owen Lars light no grey ## 5: Beru Whitesun lars light no grey ## 6: R5-D4 white, red no grey ## 7: Biggs Darklighter light no grey ## 8: Anakin Skywalker fair no grey ## 9: Shmi Skywalker fair no grey ## 10: Cliegg Lars fair no grey Агрегации В синтаксисе data.table есть конструкция by, которая отвечает за примененим операций над колонками отдельно для каждой группы (общая структура выглядит следующим образом: dataset[выбор строк, операции над колонками, группировка]). Общая логика группировки стандартная - split - apply - combine. То есть, датасет разделяется на блоки по значениям группирующей переменной, к колонкам каждого сабсета применяется какое-то выражение, и результат обратно собирается в таблицу. Результатом группировки в data.table всегда будет таблица. Вычисления по одной колонке Можно использовать группировку при применении функции к таблице, но удобнее результат операции с колонкой оборачивать в list(), так как это дает возможность переименовать колонку. В примере ниже мы считаем количество уникальных значений в колонке name для каждой группы по значениям колонки gender: sw[, uniqueN(name), by = gender] ## gender V1 ## 1: male 57 ## 2: n/a 3 ## 3: female 16 ## 4: hermaphrodite 1 sw[, list(n_chars = uniqueN(name)), by = gender] ## gender n_chars ## 1: male 57 ## 2: n/a 3 ## 3: female 16 ## 4: hermaphrodite 1 Вычисления по нескольким колонкам Можно выполнять операции сразу с несколькими колонками: sw[, list( n_chars = uniqueN(name), mass_md = median(mass, na.rm = TRUE) ), by = gender] ## gender n_chars mass_md ## 1: male 57 80.0 ## 2: n/a 3 32.0 ## 3: female 16 52.5 ## 4: hermaphrodite 1 NA Группировка по нескольким полям Часто возникает необходимость группировки сразу по нескольким полям - для этого колонки групп также указываются через список. В выражении ниже мы сначала фильтруем датасет и оставляем только строки, где в колонке gender есть значения male и female, после чего в группах по полу и цвету кожи считаем количество персонажей. Результат агрегации записываем в новый объект и выводим на печать только первые 5 строк (просто чтобы сократить вывод). sw_grps &lt;- sw[gender %in% c(&#39;male&#39;, &#39;female&#39;), list(n_chars = uniqueN(name)), by = list(gender, skin_color)] sw_grps[1:5] ## gender skin_color n_chars ## 1: male fair 12 ## 2: male white 2 ## 3: male light 4 ## 4: female light 5 ## 5: female fair 3 Манипуляции с таблицами rbind() Функция rbind()(от row bind) используется для объединение двух или более таблиц по строкам. То есть, в результате получается таблица с таким же количеством колонок, но с увеличенным числом строк - по количеству строк в объединяемых таблицах. Нередко в объединяемых таблицах отсутствует какая-нибудь колонка или колонки перепутаны. В таких случаях необходимо использовать аргументы use.names = TRUE (проверка названий колонок при объединение) и fill = TRUE (создание колонки с NA-значениями). Обратите внимание, это работает только с data.table-объектами. # создаем первую таблицу dt1 &lt;- data.table(tb = &#39;table_1&#39;, col1 = sample(9, 3), col3 = &#39;only in table1&#39;, col2 = sample(letters, 3)) # создаем вторую таблицу dt2 &lt;- data.table(tb = &#39;table_2&#39;, col4 = &#39;only in table2&#39;, col1 = sample(9, 3), col2 = sample(letters, 3)) # объединяем по строкам rbind(dt1, dt2, fill = TRUE) ## tb col1 col3 col2 col4 ## 1: table_1 3 only in table1 l &lt;NA&gt; ## 2: table_1 6 only in table1 g &lt;NA&gt; ## 3: table_1 7 only in table1 q &lt;NA&gt; ## 4: table_2 7 &lt;NA&gt; p only in table2 ## 5: table_2 8 &lt;NA&gt; v only in table2 ## 6: table_2 9 &lt;NA&gt; c only in table2 cbind() Функция cbind() (от columns bind) используется для объединения нескольких векторов или таблиц равной длины. В результате получается объединённая таблица такой же длины, как каждый из объединяемых векторов. При объединении таблиц — с таким же количеством строк, как в каждой из объединяемых таблиц, и с суммарным количеством колонок. При использовании cbind() в работе с таблицами необходимо помнить, что это буквально “склейка” таблиц независимо от порядка наблюдений по строкам. В противном случае можно получить наблюдение, где часть колонок описывает характеристики этого наблюдения, а другая часть — каких-то других наблюдений. Другой нюанс, который также необходимо учитывать: при объединении таблиц названия колонок останутся прежними. Так что если в нескольких таблицах встречается, например, колонка col1, то в финальном датасете будет несколько колонок с таким названием — по количеству объединяемых таблиц, в которых она была. В свою очередь, это усложняет задачи выбора колонки по названию и мешает понять, в какой колонке какое содержание. # выведем ранее созданные таблицы print(dt1) ## tb col1 col3 col2 ## 1: table_1 3 only in table1 l ## 2: table_1 6 only in table1 g ## 3: table_1 7 only in table1 q print(dt2) ## tb col4 col1 col2 ## 1: table_2 only in table2 7 p ## 2: table_2 only in table2 8 v ## 3: table_2 only in table2 9 c # создадим колонки-номера строк dt1[, indx := 1:.N] dt2[, indx := 1:.N] # теперь отсортируем вторую таблицу по убыванию dt2 &lt;- dt2[order(-indx)] # таблица получилась, но в строках бардак cbind(dt1, dt2) ## tb col1 col3 col2 indx tb col4 col1 col2 indx ## 1: table_1 3 only in table1 l 1 table_2 only in table2 9 c 3 ## 2: table_1 6 only in table1 g 2 table_2 only in table2 8 v 2 ## 3: table_1 7 only in table1 q 3 table_2 only in table2 7 p 1 В целом, cbind() — весьма редко используемый способ объединения таблиц. Его стоит использовать только тогда, когда есть однозначная уверенность в структуре данных (одинаковое количество строк, разные названия колонок, идентичная сортировка и т. д.), в противном случае это место, в котором очень легко ошибиться, при этом эту ошибку будет очень сложно найти. Домашнее задание level 1 (IATYTD) Импортируйте данные по Star Wars, файл по ссылке: http://bit.ly/39aOUne. Посмотрите структуру объекта. Посчитайте, сколько в таблице строк. level 2 (HNTR) создайте копию колонки mass с названием mass_corrected замените все NA в колонке mass_corrected средним значением по группе, группы выделяются по полу и планете (вам потребуется создать промежуточную колонку) level 3 (HMP) изучите справку по функции ifelse() (или fifelse() в data.table) создайте копию колонки gender, назовите ее gender_2. Замените в ней все n/a и hermaphrodite на other. Посчитайте количество персонажей в зависимости от пола (gender_2): ## gender_2 N ## 1: male 57 ## 2: other 4 ## 3: female 16 выполните предыдущее задание без создания промежуточной колонки gender_2 level 4 (UV) сделайте сводную таблицу planet_chars по персонажам каждой планеты, где в колонках будет количество персонажей, их средний рост и вес (оригинальный и скорректированный). округлите значения до 1 знака после запятой Первые 5 строк результата: ## planet_name n_chars height_mn mass_mn mass_corrected_mn ## 1: Tatooine 10 169.8 85.4 85.8 ## 2: Kamino 3 208.3 83.1 83.1 ## 3: Geonosis 1 183.0 80.0 80.0 ## 4: Utapau 1 206.0 80.0 80.0 ## 5: Kashyyyk 2 231.0 124.0 124.0 level 5 (N) Создайте датасет: несколько пользователей (например, 100), должен быть отдельный параметр user_type с значениями short, medium, long от 1 до 10 сессий на каждого пользователя, случайным образом. создайте поле логина, тип – дата и время (таймстамп), все логины в интервале 1-9 сентября. В юникс-формате или просто дата и время, на ваше усмотрение. создайте колонку session_num, которая будет маркировать номер сессии пользователя для каждой сессии создайте случайную длину сессии в секундах. Длина сессии должна варьировать в пределах 120 - 600 секунд. Длина сессии зависит от параметра user_type: short: множитель к длине сессии из интервала (0, 1] (например, 0.27) medium: множитель к длине сессии из интервала (1, 3] (например, 2.51) long: множитель к длине сессии из интервала (5, 7] (например, 6.1) Посчитайте в датасете: количество пользователей среднее количество сессий на пользователя средний среднюю длину сессий средний интервал между концом одной сессии и началом другой сессии (обратите внимание на функцию shift) Расчеты в группах по user_type и total (без группировки). В итоговой таблице должно быть 4 строки и 5 колонок. "],["data.table-pt3.html", "data.table pt3 Запись занятия Разбор домашней работы Манипуляции с таблицами Соотношение list() и := в операциях над колонками. Домашнее задание", " data.table pt3 Запись занятия Запись занятия 14 октября: Разбор домашней работы level 3 (HMP) изучите справку по функции ifelse() (или fifelse() в data.table) создайте копию колонки gender, назовите ее gender_2. Замените в ней все n/a и hermaphrodite на other. Посчитайте количество персонажей в зависимости от пола (gender_2): library(data.table) sw &lt;- fread(&#39;http://bit.ly/39aOUne&#39;) sw[, gender_2 := gender] sw[gender_2 %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), gender_2 := &#39;other&#39;] sw[, .N, by = gender_2] ## gender_2 N ## 1: male 57 ## 2: other 4 ## 3: female 16 выполните предыдущее задание без создания промежуточной колонки gender_2 # два альтернативных решения # sw[gender %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), gender := &#39;other&#39;] sw[, gender := fifelse(gender %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), &#39;other&#39;, gender)] sw[, .N, by = gender] ## gender N ## 1: male 57 ## 2: other 4 ## 3: female 16 level 4 (UV) сделайте сводную таблицу planet_chars по персонажам каждой планеты, где в колонках будет количество персонажей, их средний рост и вес (оригинальный и скорректированный). округлите значения до 1 знака после запятой Первые 5 строк результата: sw[, mass_corrected := mass] sw[, mass_mean := mean(mass, na.rm = TRUE), by = list(planet_name, gender)] sw[is.na(mass), mass_corrected := mass_mean] planet_chars &lt;- sw[, list( n_chars = .N, height_mn = round(mean(height), 1), mass_mn = round(mean(mass, na.rm = TRUE), 1), mass_corrected_mn = round(mean(mass_corrected, na.rm = TRUE), 1) ), by = planet_name] planet_chars[1:5] ## planet_name n_chars height_mn mass_mn mass_corrected_mn ## 1: Tatooine 10 169.8 85.4 85.8 ## 2: Kamino 3 208.3 83.1 83.1 ## 3: Geonosis 1 183.0 80.0 80.0 ## 4: Utapau 1 206.0 80.0 80.0 ## 5: Kashyyyk 2 231.0 124.0 124.0 Манипуляции с таблицами merge() Одна из самых, наверное, важных операций при работе с таблицами - построчное слияние двух или нескольких таблиц. При использовании функции merge() каждому значению в ключевой колонке первой таблицы сопоставляется строка параметров наблюдения другой таблицы, с таким же значением в ключевой колонке, как и в первой таблице. В других языках программирования, в SQL, в частности, аналогичная функция может называться join. Несмотря на сложность формулировки, выглядит это достаточно просто: # создаем датасет 1, в синтасисе data.table dt1 &lt;- data.table(key_col = c(&#39;r1&#39;, &#39;r2&#39;, &#39;r3&#39;), col_num = seq_len(3)) # создаем датасет 2, в синтасисе data.table dt2 &lt;- data.table(key_col = c(&#39;r3&#39;, &#39;r1&#39;, &#39;r2&#39;), col_char = c(&#39;c&#39;, &#39;a&#39;, &#39;b&#39;)) # сливаем построчно по значениям в колонке key_col merge(x = dt1, y = dt2, by = &#39;key_col&#39;) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c Здесь первая таблица задается аргументом x, вторая таблица - аргументом y, а колонка (или колонки), по значениям которой происходит слияние таблиц, задается аргументом by. Если аргумент by не указан, то слияние происходит по тем колонкам, которые имеют одинаковое название в сливаемых таблицах. Притом, таблицы можно сливать по значениям колонок разными именами, тогда надо отдельно указать, по значениям каких колонок в первой и второй таблице происходит слияние, и для этого вместо общего аргумента by используют аргументы by.x и by.y для первой и второй таблицы соответственно. В первом приближении операция слияния merge() похожа на результат работы функции cbind(). Однако, из-за того, что при слиянии происходит сопоставление по значениям ключевых колонок, в результате получается решается проблема слияния колонок, в которых разный порядок строк. Сравните: cbind(dt1, dt2) ## key_col col_num key_col col_char ## 1: r1 1 r3 c ## 2: r2 2 r1 a ## 3: r3 3 r2 b merge(x = dt1, y = dt2, by = &#39;key_col&#39;) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c Второе существенное отличие от cbind() - обработка ситуаций, когда в таблицах разное количество наблюдений. Например, в первой таблице данные по первой волне опросов, а во второй - данные по тем, кто из принявших участие в первой волне, принял участие и во второй волне, а так же какие-то новые опрошенные респонденты. Разное количество наблюдений в сливаемых таблицах порождает четыре варианта слияния, все они задаются аргументом all с постфикасми. Варианты направлений слияния (мерджа) таблиц: all = FALSE. Значение аргумента по умолчанию, в результате слияния будет таблица с наблюдениями, которые есть и в первой, и во второй таблице. То есть, наблюдения из первой таблицы, которым нет сопоставления из второй таблицы, отбрасываются. В примере с волнами это будет таблица только по тем, кто принял участи и в первой, и во второй волнах опросов: # сливаем так, чтобы оставить только тех, кто был в обеих таблицах, это значение по умолчанию merge(x = dt1, y = dt2, by = &#39;key_col&#39;, all = FALSE) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c all.x = TRUE. Всем наблюдениям из первой таблицы сопоставляются значения из второй. Если во второй таблице нет соответствующих наблюдений, то пропуски заполняются NA-значениями (в нашем примере в колонке col2): merge(x = dt1, y = dt2, by = &#39;key_col&#39;, all.x = TRUE) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c all.y = TRUE. Обратная ситуация, когда всем наблюдениям из второй таблицы сопоставляются значения из первой, и пропущенные значения заполняются NA-значениями (в нашем примере в колонке co12): merge(x = dt1, y = dt2, by = &#39;key_col&#39;, all.y = TRUE) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c all = TRUE. Объединение предыдущих двух вариантов - создается таблица по всему набору уникальных значений из ключевых таблиц, по которым происходит слияние. и если в какой-то из таблиц нет соответствующих наблюдений, то пропуски также заполняются NA-значениями: merge(x = dt1, y = dt2, by = &#39;key_col&#39;, all = TRUE) ## key_col col_num col_char ## 1: r1 1 a ## 2: r2 2 b ## 3: r3 3 c При работе с несколькими таблицами можно столкнуться с ограничением, что базовая функциz merge() работает только с парами таблиц. То есть, если вдруг необходимо слить по одному ключу сразу несколько таблиц (например, не две волны опросов, а пять), то придется строить последовательные цепочки попарных слияний. Alarm! Необходимо помнить, что в ситуациях, когда одному значению ключа в первой таблице соответствует одна строка, а во второй таблице - несколько строк, то в результате слияния таблиц значения из первой таблицы размножатся по количеству строк во второй таблице: Создаем данные: # создаем датасет 1, в синтасисе data.table dt1 &lt;- data.table(key_col = c(&#39;r1&#39;, &#39;r2&#39;, &#39;r3&#39;, &#39;r4&#39;, &#39;r1&#39;), col_num = seq_len(5)) # создаем датасет 2, в синтасисе data.table dt2 &lt;- data.table(key_col = c(&#39;r3&#39;, &#39;r1&#39;, &#39;r2&#39;, &#39;r5&#39;, &#39;r1&#39;, &#39;r1&#39;), col_char = c(&#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;)) Тут мы видим, что в первой таблице есть две строки с key_col = r1, а во второй таблице – три строки. Сливаем и получаем размножение значений из первой таблицы для ключа key_col = r1, значения 1 и 5 из колонки col1 теперь встречается три раза. А значения a, e и f встречаются по два раза: merge(dt1, dt2, by = &#39;key_col&#39;, all.x = TRUE) ## key_col col_num col_char ## 1: r1 1 a ## 2: r1 1 e ## 3: r1 1 f ## 4: r1 5 a ## 5: r1 5 e ## 6: r1 5 f ## 7: r2 2 b ## 8: r3 3 c ## 9: r4 4 &lt;NA&gt; То есть три значения из второй таблицы повторились для каждого значения из первой таблицы. В результате у нас получилось шесть строк. long / wide-форматы данных Обычная форма представления данных в таблицах — когда одна строка является одним наблюдением, а в значениях колонок отражены те или иные характеристики этого наблюдения. Такой формат традиционно называется wide-форматом, потому что при увеличении количества характеристик таблица будет расти вширь, путем увеличения числа колонок. Пример таблицы в wide-формате. # создаем таблицу с идентификатором респондента, его возрастом, ростом и весом dt_wide &lt;- data.table( wave = paste0(&#39;wave_&#39;, rep(1:2, each = 2)), id = paste0(&#39;id_&#39;, rep(1:2)), age = c(45, 68, 47, 69), height = c(163, 142, 164, 140), weight = c(55, 40, 50, 47)) dt_wide ## wave id age height weight ## 1: wave_1 id_1 45 163 55 ## 2: wave_1 id_2 68 142 40 ## 3: wave_2 id_1 47 164 50 ## 4: wave_2 id_2 69 140 47 Тем не менее, нередко встречается другой формат, в котором на одно наблюдение может приходиться несколько строк (по количеству измеренных характеристик этого наблюдения). В таком случае таблица состоит из колонки, в которой содержится какой-то идентификатор объекта, одной или нескольких колонок, в которых содержатся идентификаторы характеристик объекта, и колонки, в которой содержатся значения этих характеристик. Такой формат называется длинным, long-форматом данных, потому что при увеличении количества измеряемых характеристик таблица будет расти в длину увеличением строк. # создаем таблицу с идентификатором респондента, его возрастом, ростом и весом dt_long &lt;- data.table( # две волны, по два респондента в каждой wave = paste0(&#39;wave_&#39;, rep(1:2, each = 6)), # на каждого респондента задаем три строки id = paste0(&#39;id_&#39;, rep(rep(1:2, each = 3), 2)), # три характеристики повторяем для четырех респондентов variable = rep(c(&#39;age&#39;, &#39;height&#39;, &#39;weight&#39;), 4), # задаем значения характеристик, с учетом того, как упорядочены первые две колонки value = c(45, 163, 55, 68, 142, 40, 47, 164, 50, 69, 140, 47)) dt_long ## wave id variable value ## 1: wave_1 id_1 age 45 ## 2: wave_1 id_1 height 163 ## 3: wave_1 id_1 weight 55 ## 4: wave_1 id_2 age 68 ## 5: wave_1 id_2 height 142 ## 6: wave_1 id_2 weight 40 ## 7: wave_2 id_1 age 47 ## 8: wave_2 id_1 height 164 ## 9: wave_2 id_1 weight 50 ## 10: wave_2 id_2 age 69 ## 11: wave_2 id_2 height 140 ## 12: wave_2 id_2 weight 47 dcast() Для того, чтобы трансформировать long-формат в wide-формат, используется функция dcast() пакета data.table (либо cast() пакета reshape2). Также можно использовать функцию reshape() из базового набора функций R, однако эта функция достаточно медленная по скорости работы. Для того, чтобы превратить созданную выше таблицу в long-формате в широкий формат, выражение будет выглядеть следующим образом (сама операция называется решейп): dcast(data = dt_long, formula = wave + id ~ variable, value.var = &#39;value&#39;) ## wave id age height weight ## 1: wave_1 id_1 45 163 55 ## 2: wave_1 id_2 68 142 40 ## 3: wave_2 id_1 47 164 50 ## 4: wave_2 id_2 69 140 47 Здесь аргумент data - определяет таблицу, которую мы хотим трансформировать. Аргумент formula задает, что в результирующей таблице будет задавать уникальное наблюдение, и значения какой колонки будут разделены на самостоятельные колонки. Формулу можно прочитать как строки ~ колонки в результирующей таблице. В нашем случае уникальное наблюдение мы задаем парой переменных wave и id, поэтому мы их указываем до тильды через +. Колонки же мы создаем по значениям переменной variable, после тильды. Следует отметить, что ситуация, когда строка задается несколькими переменными через оператор +, весьма частая, а вот в правой части формулы несколько переменных встречаются достаточно редко, обычно все же на колонки раскладывают по значениям одной переменной. Аргумент value.var содержит текстовое название переменной, значения которой будут отражены в результирующей таблице по колонкам для каждого наблюдения. Иногда случаются ситуации, когда необходимо провести сначала агрегацию по одной из колонок, описывающих наблюдение. Например, вычислить средние значения возраста, роста и веса для каждой волны. Это можно сделать в два этапа - сначала провести агрегацию, и потом решейп. Также можно сразу сделать решейп, и воспользоваться дополнительным аргументом fun.aggregate, который сразу, при решейпе, агрегирует данные. Например, если использовать сначала агрегацию, а потом трансформацию в wide-формат: # агрегируем наблюдения по волнам и характеристикам tmp &lt;- dt_long[, list(value = mean(value)), by = list(wave, variable)] tmp ## wave variable value ## 1: wave_1 age 56.5 ## 2: wave_1 height 152.5 ## 3: wave_1 weight 47.5 ## 4: wave_2 age 58.0 ## 5: wave_2 height 152.0 ## 6: wave_2 weight 48.5 # трансформируем в wide-формат. колонки id уже нет в таблице, поэтому удаляем из формулы dcast(data = tmp, formula = wave ~ variable, value.var = &#39;value&#39;) ## wave age height weight ## 1: wave_1 56.5 152.5 47.5 ## 2: wave_2 58.0 152.0 48.5 Аналогично, но с использованием аргумента fun.aggregate. В значения аргумента передаём название функции без кавычек и скобок, в нашем случае это fun.aggregate = mean: dcast(data = tmp, formula = wave ~ variable, value.var = &#39;value&#39;, fun.aggregate = mean) ## wave age height weight ## 1: wave_1 56.5 152.5 47.5 ## 2: wave_2 58.0 152.0 48.5 melt() Обратная трансформация также возможна, из wide-формата в long-формат. Для этого используется функция melt(): melt(data = dt_wide, id.vars = c(&#39;wave&#39;, &#39;id&#39;), measure.vars = c(&#39;age&#39;, &#39;height&#39;, &#39;weight&#39;), variable.name = &#39;variable&#39;, value.name = &#39;value&#39;) ## wave id variable value ## 1: wave_1 id_1 age 45 ## 2: wave_1 id_2 age 68 ## 3: wave_2 id_1 age 47 ## 4: wave_2 id_2 age 69 ## 5: wave_1 id_1 height 163 ## 6: wave_1 id_2 height 142 ## 7: wave_2 id_1 height 164 ## 8: wave_2 id_2 height 140 ## 9: wave_1 id_1 weight 55 ## 10: wave_1 id_2 weight 40 ## 11: wave_2 id_1 weight 50 ## 12: wave_2 id_2 weight 47 Здесь аргумент id.vars задает переменные, которые будут использоваться для уникальной идентификации наблюдения. Аргумент measure.vars определяет те колонки, которые войдут длинную таблицу как значения переменной характеристик наблюдений (когда каждая строка — отдельная характеристика наблюдения, несколько строк на одного пользователя). Аргументы variable.name и value.name задают, соответственно, названия колонок характеристик наблюдения и значений этих характеристик в финальной таблице. Соотношение list() и := в операциях над колонками. На занятии я заметил, что многие путаются в синтаксисе создания новых колонок и в выражении list(). Различие следующее: sw[, new_value := &#39;bla-bla-bla&#39;] sw[1:5] ## name height mass skin_color gender planet_name gender_2 ## 1: Luke Skywalker 172 77 fair male Tatooine male ## 2: C-3PO 167 75 gold other Tatooine other ## 3: Darth Vader 202 136 white male Tatooine male ## 4: Owen Lars 178 120 light male Tatooine male ## 5: Beru Whitesun lars 165 75 light female Tatooine female ## mass_corrected mass_mean new_value ## 1: 77 100.2 bla-bla-bla ## 2: 75 53.5 bla-bla-bla ## 3: 136 100.2 bla-bla-bla ## 4: 120 100.2 bla-bla-bla ## 5: 75 75.0 bla-bla-bla Здесь выражение sw[, new_value := 'bla-bla-bla'] можно прочитать как в таблице sw создай новую колонку new_value и запиши в нее значение 'bla-bla-bla'. Одинарное значение будет размножено по количеству строк. Вместо 'bla-bla-bla' также может быть и какая-нибудь функция, которая создает вектор такой же длины, сколько строк в таблице (если больше или меньше, то выдаст ошибку): # в таблице 77 строк, поэтому можем просто указать 77:1 sw[, new_value2 := 77:1] sw[1:5] ## name height mass skin_color gender planet_name gender_2 ## 1: Luke Skywalker 172 77 fair male Tatooine male ## 2: C-3PO 167 75 gold other Tatooine other ## 3: Darth Vader 202 136 white male Tatooine male ## 4: Owen Lars 178 120 light male Tatooine male ## 5: Beru Whitesun lars 165 75 light female Tatooine female ## mass_corrected mass_mean new_value new_value2 ## 1: 77 100.2 bla-bla-bla 77 ## 2: 75 53.5 bla-bla-bla 76 ## 3: 136 100.2 bla-bla-bla 75 ## 4: 120 100.2 bla-bla-bla 74 ## 5: 75 75.0 bla-bla-bla 73 Выражение sw[, new_value2 := 77:1] можно прочитать как в таблице sw создай новую колонку new_value2 и запиши в нее вектор, который получится в результате выполнения выражения 77:1. Конструкция с list() используется тогда, когда на основе существующей таблицы надо создать новую таблицу. Фактически это создание нового списка на основе колонок таблицы, просто в результате будет таблица и класс data.table: new_dt &lt;- sw[, list(total_users = uniqueN(name), height_mn = mean(height, na.rm = TRUE))] new_dt ## total_users height_mn ## 1: 77 176.2078 Здесь выражение new_dt &lt;- sw[, list(total_users = uniqueN(name), height_mn = mean(height, na.rm = TRUE))] можно прочитать следующим образом: на основе таблицы sw создай таблицу, в которой в колонку total_users запиши количество уникальных значений из колонки name, а в height_mn - среднее значение по колонке height Полученную таблицу запиши в объект new_dt. Надо помнить, что total_users и height_mn - это колонки, которые будут в новой таблице, в sw их нет. Соответственно, использовать := вместе с list() некорректно. Точно также использовать знак = неправильно для создания новых колонок в уже существующей таблице, интерпретатор вернет ошибку. Домашнее задание level 1 (IATYTD) Посчитайте, сколько пользователей (user_pseudo_id) в приложение, с разбивкой по платформам (platform). Датасет: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/installs.csv ## platform n_users ## 1: ANDROID 86112 ## 2: IOS 39484 Проверьте, нет ли дублей в таблице (когда несколько записей на одного пользователя). Подумайте, как можно от них избавиться. level 2 (HNTR) Посчитайте, сколько было платящих пользователей (n_payers), сколько они сделали платежей (n_purchases) и на какую сумму (gross), сколько в среднем сделал платежей каждый пользователь (purchases_per_user), средний размер платежа (purchase_mn) и сколько в среднем заплатил каждый пользователь (ARPPU). Датасет: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/payments_custom.csv ## n_payers gross n_purchases purchases_per_user purchase_mn ARPPU ## 1: 7228 291734.2 35585 4.92 8.2 40.362 level 3 (HMP) Сделайте предыдущее задание, только добавьте разбивку по платформам. Добавьте total (то есть статистику по всей выборке, без разбивки). ## platform n_payers gross n_purchases purchases_per_user purchase_mn ARPPU ## 1: ANDROID 3420 95069 12752 3.73 7.46 27.798 ## 2: IOS 3808 196665 22833 6.00 8.61 51.645 ## 3: All 7228 291734 35585 4.92 8.20 40.362 level 4 (UV) Сделайте предыдущее задание, только добавьте разбивку по полю media_source из таблицы инсталлов (для сопоставления нужен user_pseudo_id). Имейте в виду, в payments все платежи, а нам нужны только по тем пользователям, кто установил приложение (т.е. есть в таблице installs) Пропущенные значения и other в поле media_source перекодируйте в organic. Аналогично, добавьте total. ## media_source n_payers gross n_purchases purchases_per_user purchase_mn ## 1: organic 1329 60673 6742 5.07 9.00 ## 2: unityads_int 273 7783 1176 4.31 6.62 ## 3: applovin_int 1190 51544 6203 5.21 8.31 ## 4: Facebook Ads 54 1051 118 2.19 8.91 ## 5: googleadwords_int 169 5367 643 3.80 8.35 ## 6: All 3015 126418 14882 4.94 8.49 ## ARPPU ## 1: 45.653 ## 2: 28.510 ## 3: 43.314 ## 4: 19.468 ## 5: 31.756 ## 6: 41.930 level 5 (N) Возьмите пользователей, которые пришли в июне. Оставьте только те платежи, которые были сделаны в период первых 30 дней от инсталла (pay_dt - install_dt &lt; 30). Метрика количества дней от инсталла называется лайфтайм (lifetime). Создайте таблицу, в которой будет всего пользователей, установивших приложение, все из монетизационные метрика (из level 2) + доля платящих от общего числа пользователей (conversion) и средний платеж каждого пользователя когорты, независимо, платящий он или нет (ARPU). У меня в результатах почищены данные по инсталлам. ## media_source total_users n_payers gross conversion ARPU ARPPU ## 1: Facebook Ads 1297 53 884.43 0.041 0.68 16.687 ## 2: applovin_int 36714 1115 38133.02 0.030 1.04 34.200 ## 3: googleadwords_int 7767 160 4302.90 0.021 0.55 26.893 ## 4: organic 43070 1000 38867.72 0.023 0.90 38.868 ## 5: unityads_int 21932 263 6099.07 0.012 0.28 23.190 ## n_purchases purchases_per_user purchase_mn ## 1: 101 1.91 8.76 ## 2: 4529 4.06 8.42 ## 3: 509 3.18 8.45 ## 4: 4336 4.34 8.96 ## 5: 969 3.68 6.29 "],["dt-etl.html", "dt + ETL Запись занятия Разбор домашней работы ETL Дополнительная литература Домашнее задание", " dt + ETL Запись занятия Запись занятия 21 октября: Разбор домашней работы level 3 (HMP) создайте копию колонки gender, назовите ее gender_2. Замените в ней все n/a и hermaphrodite на other. Посчитайте количество персонажей в зависимости от пола (gender_2): library(data.table) sw &lt;- fread(&#39;http://bit.ly/39aOUne&#39;) sw[, gender_2 := gender] sw[gender_2 %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), gender_2 := &#39;other&#39;] выполните предыдущее задание без создания промежуточной колонки gender_2 # два альтернативных варианта # sw[gender %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), gender := &#39;other&#39;] sw[, gender := fifelse(gender %in% c(&#39;n/a&#39;, &#39;hermaphrodite&#39;), &#39;other&#39;, gender)] level 4 (UV) сделайте сводную таблицу planet_chars по персонажам каждой планеты, где в колонках будет количество персонажей, их средний рост и вес (оригинальный и скорректированный). округлите значения до 1 знака после запятой Первые 5 строк результата: sw[, mass_corrected := mass] sw[, mass_mean := mean(mass, na.rm = TRUE), by = list(planet_name, gender)] sw[is.na(mass), mass_corrected := mass_mean] planet_chars &lt;- sw[, list( n_chars = uniqueN(name), # или n_chars = .N height_mn = round(mean(height), 1), mass_mn = round(mean(mass, na.rm = TRUE), 1), mass_corrected_mn = round(mean(mass_corrected, na.rm = TRUE), 1) ), by = planet_name] planet_chars[1:5] ## planet_name n_chars height_mn mass_mn mass_corrected_mn ## 1: Tatooine 10 169.8 85.4 85.8 ## 2: Kamino 3 208.3 83.1 83.1 ## 3: Geonosis 1 183.0 80.0 80.0 ## 4: Utapau 1 206.0 80.0 80.0 ## 5: Kashyyyk 2 231.0 124.0 124.0 ETL Чтение и запись текстовых файлов В работе аналитики чаще всего сталкиваются с данными, которые хранятся в простом текстовом формате (txt, разделители строк \\n, \\r или \\n\\r ) и основанном на них табличных форматах csv (с разделителями , или ;) или tsv (\\t). Построчное чтение При работе с текстами проще всего читать файлы построчно - весь текст импортируется как вектор строковых значений, а элементы этого вектора - блоки текста, ограниченные переносами строк. Это удобно при импорте текстов, в которых есть смысловые блоки, как в художественных и поэтических текстах. Точно также построчное чтение может быть использовано для импорта файлов с ошибками или даже, в особо экзотических случаях, для чтения скриптов. Для построчного чтения обычно используется функция readLines() базового пакета или аналогичные ей. С помощью аргументов функции можно указать, сколько необходимо прочитать строк, задать кодировку и что делать, если в файле меньше строк, чем было задано. Прочитаем первые несколько строк текста песни: txt_lines &lt;- readLines(&#39;./data/oxxy_gorgorod.txt&#39;, n = 5) txt_lines ## [1] &quot;####&quot; ## [2] &quot;Незаметно поправь её&quot; ## [3] &quot;Одеяло, за это себя предавая анафеме&quot; ## [4] &quot;Она вышла из пены&quot; ## [5] &quot;Худой отпечаток плеча оставляя на кафеле&quot; Чтение текстовых файлов: read.table() и fread() Для чтения текстовых файлов, которые содержат в табличном формате, в базовом R есть функция read.table() и функции-обертки, которые обращаются к ней, но с другими значениями аргументов по умолчанию (read.csv(), read.csv2, read.delim(), read.delim2()). Табличный формат предполагает наличие строк и колонок в файле, выделенные разделителями строк и полей соответственно, при этом формат файла может быть как txt, так и csv. Несмотря на всю видимую простоту, при импорте табличных форматов можно столкнуться с очень большим количеством нетривиальных проблем. В немалой части это можно назвать следствием их широкой распространенности - практически все современные текстовые процессоры умеют работать с csv-файлами, экспорт из баз данных также нередко делается в csv. Ко всему прочему, текстовые форматы хорошо сжимаются при архивации. К наиболее частым сложностям, которые возникают при импорте текстовых файлов можно отнести следующие: неожиданные разделители (например, экспорт из MS Excel в csv создает файл с разделителем ;) лишние или пропущенные разделители строк или колонок (\\t\\t вместо \\t), что создает разное количество колонок в таблице несоответствие файла расширению или вообще отсутствие расширения нестандартные кодировки, в том числе проблемы их импорта при работе в Windows наличие embedded nuls (\\0) или метки порядка байтов (bite order marks, BOM) наличие символов \"\"\"\", //// и прочих технических символов мета-данные (запись о дате и источнике данных) в первых строках файла Большинство этих нюансов решается при настройке параметров импорта с помощью аргументов функций импорта (т.е., настройки по умолчанию не справляются). В частности, в функциях чтения таблиц можно задать разделители полей и десятичные разделители (sep и dec), кодировку файла и отображения, обработку пустых строк и т.д. Некоторые проблемы, например, импорт данных с embedded nuls постепенно решаются в новых версиях функций и пакетов. Помимо этих аргументов также очень полезны аргументы, которые позволяют прямо указать, сколько строк импортировать (или пропустить от начала), какие типы данных в колонках и какие колонки стоит пропустить, а также - надо ли конвертировать в факторы строковые значения. Из других не очень очевидных нюансов стоит отметить, что функция read.table() удобна, так как обладает большим набором аргументов, а также устойчива к некоторым ошибкам в данных. Однако импорт данных с ее помощью весьма нетороплив, что ощутимо сказывается при импорте больших таблиц. Поэтому лучше использовать аналогичные функции других пакетов, в частности, data.table::fread(), аргументы которой очень похожи на аргументы read.table(). Запись данных в текстовые файлы: write.table() и fwrite() Запись данных в текстовые форматы также может вестись как построчно, так и сразу всей таблицей. Для записи построчно обычно используется функция writeLines(). Запись таблиц происходит аналогичным образом, с помощью функции write.table() или ее аналогом в других пакетах (в частности, более быстрый вариант data.table::fwrite()). С помощью аргументов можно задать как типы разделителей (строк, полей и десятичные разделители), так и кодировку. Обычно рекомендуется выставлять аргумент row.names = FALSE, чтобы в файл не были записаны отдельной колонкой названия (номера) строк. Чтение файлов MS Excel В отличие от простых форматов типа .csv, файлы, созданные в MS Excel импортировать не так просто. Ситуация также осложняется тем, что форматы .xls и .xlsx сильно различаются по внутренней структуре. Часть пакетов, которые обеспечивают взаимодействие с Excel-файлами, требуют установки языка Java (java development kit) в систему и соответствующих R-пакетов (rJava, в частности) - самые часто используемые пакеты тут XLconnect и xlsx. Тем не менее, в большинстве случаев необходим только прочитать файл, и тут могут быть полезны пакеты пакеты openxlsx и readxl, не требующие установки jdk. Пакет openxlsx к тому же умеет еще и записывать файлы в .xlsx, как XLconnect, в том числе и с условным форматированием ячеек. Чтение файлов Пакет readxl, по наблюдениям, чуть быстрее читает файлы, чем openxlsx или пакеты, требующие Java, поэтому рассмотрим здесь его. В целом, функционал пакетов достаточно схож и то, что может readxl, практически всегда можно реализовать и в других пакетах, и наоборот. Основные функции пакета - read_xls() для чтения файлов MS Excel, созданных в версиях до MS Excel 2007, read_xlsx() - для чтения файлов, созданных в более современных версиях, также есть обобщающая функция read_excel(), которая по расширению файла определяет, какую из этих функций надо использовать. Пакет readxl принадлежит к экосистеме tideverse, поэтому импортированные таблицы имеют класс tibble и data.frame. Соответственно, если работать в data.table, необходимо их отдельно преобразовать Вот так выглядит исходный файл в MS Excel: Импортируем файл: library(readxl) # читаем файл path &lt;- &#39;./data/xls_example.xlsx&#39; xlsx_data &lt;- read_xlsx(path) str(xlsx_data) ## tibble [7 × 5] (S3: tbl_df/tbl/data.frame) ## $ company : chr [1:7] &quot;xxx&quot; &quot;xxx&quot; &quot;xxx&quot; &quot;yyy&quot; ... ## $ item_code: num [1:7] 20000559 20000779 13117 40000289 40000274 ... ## $ barcode : num [1:7] 4.60e+12 4.60e+12 4.61e+12 3.57e+12 3.57e+12 ... ## $ amount : num [1:7] 3 4 2 6 2 1 9 ## $ price : num [1:7] 480.3 26.9 353.8 207.6 174.8 ... xlsx_data ## # A tibble: 7 × 5 ## company item_code barcode amount price ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 xxx 20000559 4601026307584 3 480. ## 2 xxx 20000779 4603182002259 4 27.0 ## 3 xxx 13117 4607072020156 2 354. ## 4 yyy 40000289 3574661287522 6 208. ## 5 yyy 40000274 3574661287539 2 175. ## 6 zzz 10000581 4602196002682 1 537. ## 7 zzz 20000458 4601026308567 9 371. При импорте можно указать тип колонок. Делается это с помощью аргумента col_types, в который необходимо передать вектор такой же длины, сколько колонок, состоящий из значений logical, numeric, date, text или list. К сожалению, в отличие от схожего аргумента colClasses в функциях импорта csv/xlsx-файлов (read.table(), read.csv(), data.table::fread(), openxlsx::read.xlsx и проч.), в readxl названия типов не соответствуют названиям атомарных типов данных в R. Если для col_types указать NULL или guess, то тип будет выбран на основе анализа минимум 1000 строк (или всех строк, если датасет меньше 1000 строк). Также можно указать вектор типов длиной не по количеству колонок, а только из одного значения, то все колонки будут импортированы в этом типе. Значение skip указывает, что эту колонку не надо импортировать. # читаем файл с указанием типа text для всех колонок xlsx_data &lt;- read_xlsx(path, col_types = &#39;text&#39;) xlsx_data ## # A tibble: 7 × 5 ## company item_code barcode amount price ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 xxx 20000559 4601026307584 3 480.26 ## 2 xxx 20000779 4603182002259 4 26.95 ## 3 xxx 13117 4607072020156 2 353.76 ## 4 yyy 40000289 3574661287522 6 207.55 ## 5 yyy 40000274 3574661287539 2 174.81 ## 6 zzz 10000581 4602196002682 1 537.46 ## 7 zzz 20000458 4601026308567 9 370.7 Частичное чтение файла Большинство xlsx-файлов содержит несколько непустых листов. По умолчанию функции импорта читают только первый лист, остальные же игнорируются. Пакеты типа XLConnect могут читать весь файл в отдельный объект. Для чтения названий листов xlsx-файла можно воспользоваться функцией readxl::excel_sheets() и полученный вектор потом циклом или через lapply() передать в функцию импорта: # читаем список листов файла sheets &lt;- readxl::excel_sheets(path) sheets ## [1] &quot;Sheet1&quot; &quot;Sheet2&quot; # читаем все листы в список и смотрим структуру file_str &lt;- lapply(sheets, function(x) read_xlsx(path, sheet = x)) str(file_str) ## List of 2 ## $ : tibble [7 × 5] (S3: tbl_df/tbl/data.frame) ## ..$ company : chr [1:7] &quot;xxx&quot; &quot;xxx&quot; &quot;xxx&quot; &quot;yyy&quot; ... ## ..$ item_code: num [1:7] 20000559 20000779 13117 40000289 40000274 ... ## ..$ barcode : num [1:7] 4.60e+12 4.60e+12 4.61e+12 3.57e+12 3.57e+12 ... ## ..$ amount : num [1:7] 3 4 2 6 2 1 9 ## ..$ price : num [1:7] 480.3 26.9 353.8 207.6 174.8 ... ## $ : tibble [3 × 2] (S3: tbl_df/tbl/data.frame) ## ..$ company: chr [1:3] &quot;xxx&quot; &quot;yyy&quot; &quot;zzz&quot; ## ..$ items : num [1:3] 198 256 32 В некоторых случаях требуется импортировать только определенный диапазон ячеек со всего листа - например, когда на созданном вручную листе есть и таблица с данными, и графики, и дополнительные материалы. Для чтения определенной ячейки или диапазона ячеек используют аргумент range, в котором в строковом виде указывают диапазон ячеек в Excel-координатах (буквы для колонок и цифры для строк). К сожалению, на данный момент нельзя указать сразу несколько диапазонов. Во-вторых, в прочитанном диапазоне, если не указать обратное, первая строка будет по умолчанию интерпретироваться как строка заголовка. В результате приходится либо прямо задавать названия колонок, либо указывать, что заголовка нет: read_xlsx(path, range = &#39;A5:B6&#39;, col_names = c(&#39;company&#39;, &#39;item_code&#39;)) ## # A tibble: 2 × 2 ## company item_code ## &lt;chr&gt; &lt;dbl&gt; ## 1 yyy 40000289 ## 2 yyy 40000274 Чтение файлов SPSS Для импорта файлов SPSS (.sav) обычно используют функции какого-либо из двух пакетов - foreign::read.spss(), который идет в базовом наборе пакетов R, а так же haven::read_spss(), авторства Хэдли Викхэма. Исходный файл имеет такую структуру (скриншот из SPSS Output): Функции read_sav() и read_spss() пакета haven обладают схожим с foreign::read.spss() функционалом при меньшем количестве настроек. При этом эти функции несколько быстрее, а так же не имеют проблем с длинными строками. В результате импорта получается tibble-таблица (так как haven принадлежит экосистеме tidyverse). library(haven) spss_data &lt;- read_sav(&#39;./data/spss_example.sav&#39;) spss_data ## # A tibble: 6 × 3 ## var1 var2 var3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt; ## 1 3 4 1 [среднее] ## 2 4 5 NA ## 3 3 5 99 [отказ от ответа] ## 4 3 5 1 [среднее] ## 5 4 4 4 ## 6 3 5 999 [отказ от ответа] Функция не имеет настроек, как импортировать значения, для которых заданы метки, и в таблице представлены числовые значения. При необходимости получить значения метки переменных или значений необходимо идти в атрибуты колонок таблицы: str(spss_data) ## tibble [6 × 3] (S3: tbl_df/tbl/data.frame) ## $ var1: num [1:6] 3 4 3 3 4 3 ## ..- attr(*, &quot;label&quot;)= chr &quot;Практичный&quot; ## ..- attr(*, &quot;format.spss&quot;)= chr &quot;F8.2&quot; ## $ var2: num [1:6] 4 5 5 5 4 5 ## ..- attr(*, &quot;label&quot;)= chr &quot;Порядочный&quot; ## ..- attr(*, &quot;format.spss&quot;)= chr &quot;F8.2&quot; ## $ var3: dbl+lbl [1:6] 1, NA, 99, 1, 4, 999 ## ..@ label : chr &quot;Образование&quot; ## ..@ format.spss: chr &quot;F8.2&quot; ## ..@ labels : Named num [1:4] 1 2 99 999 ## .. ..- attr(*, &quot;names&quot;)= chr [1:4] &quot;среднее&quot; &quot;высшее&quot; &quot;отказ от ответа&quot; &quot;отказ от ответа&quot; Пакет haven импортирует данные в свой формат, однако полученный объект можно преобразовать в data.table: library(data.table) setDT(spss_data) class(spss_data) ## [1] &quot;data.table&quot; &quot;data.frame&quot; У нас есть колонка var3, для которой в SPSS были заданы метки. В полученном формате метки хранятся в атрибутах колонки — это что-то вроде мета-информации. Посмотрим все атрибуты колонки с помощью функции attributes() (иногда это проще делать через синтаксис списков и оператор $): # смотрим атрибуты вектора-колонки var3 attributes(spss_data[, var3]) ## $label ## [1] &quot;Образование&quot; ## ## $format.spss ## [1] &quot;F8.2&quot; ## ## $class ## [1] &quot;haven_labelled&quot; &quot;vctrs_vctr&quot; &quot;double&quot; ## ## $labels ## среднее высшее отказ от ответа отказ от ответа ## 1 2 99 999 # через синтаксис списков attributes(spss_data$var3) ## $label ## [1] &quot;Образование&quot; ## ## $format.spss ## [1] &quot;F8.2&quot; ## ## $class ## [1] &quot;haven_labelled&quot; &quot;vctrs_vctr&quot; &quot;double&quot; ## ## $labels ## среднее высшее отказ от ответа отказ от ответа ## 1 2 99 999 Мы видим четыре атрибута — метку переменной ($label), SPSS-формат данных ($format.spss), обозначение, что переменная в SPSS имеет метки значений ($class) и собственно вектор меток, которые используются для значений этой колонки ($labels). Для того, чтобы сохранить метки значений (а не сами значения), можно создать новую колонку и в нее записать с результат применения функции as_factor пакета haven — эта функция извлекает и сопоставляет значения и их метки. spss_data[, var4 := as_factor(var3)] spss_data ## var1 var2 var3 var4 ## 1: 3 4 1 среднее ## 2: 4 5 NA &lt;NA&gt; ## 3: 3 5 99 отказ от ответа ## 4: 3 5 1 среднее ## 5: 4 4 4 4 ## 6: 3 5 999 отказ от ответа Как мы видим, для значений 1, 99, 999 были проставлены метки, и они оказались в новой переменной, а не атрибутом. Для значения 4 метки не было, поэтому оно было записано именно значением. Дополнительная литература глава моего учебника по R, где разбираются процессы ввода/вывода данных. Домашнее задание level 1 (IATYTD) У вас есть xlsx-файл по популяции и видам пингвинов. Импортируйте данные из этого файла в R. При работе постарайтесь обойтись только средствами R, не открывая файл в Excel. Проверьте, что вы импортировали все листы. При необходимости, импортируйте оставшиеся и соберите все в одну таблицу. Проверьте класс объекта и при необходимости преобразуйте в data.table. Посчитайте количество пингвинов каждого типа (колонка Species). ## Species N ## 1: Adelie Penguin (Pygoscelis adeliae) 152 ## 2: Gentoo penguin (Pygoscelis papua) 124 ## 3: Chinstrap penguin (Pygoscelis antarctica) 68 level 2 (HNTR) У вас есть данные Tate Gallery по художникам и их произведениям. Импортируйте датасеты по художникам, ссылки на файлы ниже. А лучше воспользуйтесь функцией download.file() (не забудьте прочитать справку по функции и ее аргументам) для того, чтобы сохранить эти файлы на диск и потом загружать их уже с диска, а не из интернета. url_artwork &lt;- &#39;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-01-12/artwork.csv&#39; url_artists &lt;- &quot;https://github.com/tategallery/collection/raw/master/artist_data.csv&quot; С помощью функции setnames() пакета data.table (или names() из базового пакета, если вам так удобнее) переименуйте в файле по художникам колонки yearOfBirth в year_of_birth, колонки yearOFDeath, placeOfBirth и placeOfDeath аналогично. посчитайте, сколько художников из списка живы в настоящий момент. посчитайте, сколько среди живущих в настоящий момент художников мужчин и сколько женщин. ## [1] 1304 ## gender N ## 1: Female 297 ## 2: Male 944 ## 3: 63 level 3 (HMP) подумайте и покажите решение, как можно узнать структуру файла artwork, однако полностью импортировать вы его не можете (предположим, что он настолько большой, что повесит систему намертво). импортируйте только те колонки, которые позволят вам идентифицировать художника, название работы и ее формат (колонка medium). посчитайте, сколько в галерее работ от художников-мужчин и сколько от женщин. Отдельной колонкой выведите статистики по живущим на данный момент художникам. ## gender n_works n_works_alive ## 1: Male 2791 878 ## 2: 49 28 ## 3: Female 492 274 ## 4: &lt;NA&gt; 4 4 посчитайте, сколько работ разных форматов сделали художницы, умершие до 1800 года (каждый формат – отдельная колонка, форматы даны в колонке medium). Вам потребуется функция dcast(). ## artist Graphite and ink on paper Oil paint on canvas ## 1: Beale, Mary 0 1 ## 2: Sanders, Ann 0 0 ## 3: Spencer, Lady 1 0 ## Oil paint on paper Watercolour on paper ## 1: 2 0 ## 2: 0 1 ## 3: 0 0 level 4 (UV) Импортируйте файл txt_example.txt. Перед импортом можете скачать файл и импортировать его локально (это рекомендация, не более). ## КодПодр КодНом ## 1 69500044 ЛН-008560521 ## 2 69500044 ЛН-745621 ## 3 69500300 69506432458 ## 4 69500346 695089466518 ## 5 69500268 69504851543 ## 6 69500009 69506584554 ## 7 69500058 ЛН-86600383 ## 8 69500147 ЛН-41200521 ## 9 69500147 ЛН-05860521 ## 10 69500268 ЛН-00000927 ## Наименование ## 1 БАНЕОЦИН ПОР. 10Г ## 2 БАНЕОЦИН ПОР. 10Г ## 3 НИМЕСАН ТАБЛ. 100МГ N20 ## 4 ЦИННАРИЗИН ТАБЛ. 25МГ N50 АВЕКСИМА ## 5 ФИТОСЕДАН СБОР УСПОКОИТЕЛЬНЫЙ №2 Ф/П 2Г N20 КРАСНОГОРСК ## 6 БАНДАЖ КОМПРЕС. ПОДДЕРЖИВ. ПОЯСНИЧНО-КРЕСТЦОВЫЙ С ОВЕЧЬИМ МЕХОМ БКД-УНГА, р.6 ## 7 АЛЛОХОЛ ТАБЛ.П.О. N10 ФАРМСТАНДАРТ ## 8 БАНЕОЦИН ПОР. 10Г ## 9 БАНЕОЦИН ПОР. 10Г ## 10 КВАМАТЕЛ ТАБЛ.П.О. 20МГ N28 ## Производитель Упак Месяц ## 1 САНДОЗ ГмбХ - Австрия 4 5 ## 2 САНДОЗ ГмбХ - Австрия 4 5 ## 3 Шрея Лайф Саенсиз Пвт. Лтд 1 5 ## 4 Анжеро-Судженский ХФЗ,ООО 3 5 ## 5 КРАСНОГОРСКЛЕКСР-ВА 1 5 ## 6 ТОНУС - ЭЛАСТ 1 5 ## 7 ФАРМСТАНДАРТ 10 5 ## 8 САНДОЗ ГмбХ - Австрия 4 5 ## 9 САНДОЗ ГмбХ - Австрия 4 5 ## 10 Гедеон Рихтер 2 5 level 5 (N) Импортируйте файл extr’version.xls. Решение должно уметь импортировать не только этот конкретный файл, но и другие файлы с такими особенностями. Перед импортом надо скачать файл и импортировать его локально (read_excel не умеет импортировать по ссылке). print(x) ## Название товара ## 1: Солпадеин, тбл №12 ## 2: Соль д/ванн &quot;Доктор Сольморей&quot; с эвкалипт. пакет 500мг ## 3: Соль д/ванн 500г Противопростудная эвкалипт ## 4: Соль д/ванн Elite с пеной , 500г морская ## 5: Соль д/ванн Elite, 500г ромашка ## 6: СОЛЬ Д/ВАНН Д/ВСЕЙ СЕМЬИ ПРОТИВОПРОСТ 500ГР ## 7: Соль д/ванн Для всей семьи 500г антистресс ромашка ## 8: Соль д/ванн Мертвое море 500г натуральная ## 9: Соль д/ванн морская природная, 1кг ## 10: Соль д/ванн морская, 1кг ## 11: Соль д/ванн, 500г мелисса ## 12: Соль д/ванн, 500г розмарин ## 13: Соль морская, 1кг ## 14: Сонапакс, држ 100мг №60 ## 15: Сонапакс, држ 25мг №60 ## 16: Сонизин, капс с модиф.высвобожд.0.4мг №30 ## 17: Сонник, капс. 0.3г №36 ## 18: Сонные,тбл №30 ## 19: Сопелка наклейка на одежду при простуде и насмор №4 ## 20: Сопелка, пластырь д/инг №10 ## 21: Сопелка, пластырь №4 ## 22: Сорбифер дурулес, тбл п/о №30 ## 23: Сорбифер дурулес, тбл п/о №50 ## 24: Соска молочная латексная 2 шт. ## 25: Соска к рожку круглая (латекс) Х-отверстие ## 26: Соска к рожку круглая 0-6 мес. (латекс) ## 27: Соска к рожку круглая 6-12 мес. (латекс) смесь ## 28: Соска Курносики латекс №2 (поток средний) с 6+мес(арт 12124) ## 29: Соска Курносики силикон. большая сред.отвер №2 ## 30: Соска латекс. анатомич. д/пюре, арт.11204 ## 31: Соска латекс. мой малыш с 6-12 мес.круглая арт.11112 ## 32: Соска Мой малыш к рожку анатом. (латекс мелк.отв) 6-12 мес ## 33: Соска сил. Мой Малыш анатом 6-12м (сред.отв) 12212 ## 34: Соска сил. станд. (12032) х2 ## 35: Соска сил. станд. (12032) х2 ## 36: Соска силик. классич. для всех типов питания 6+ ## 37: Соска силик. стандартная №2 (арт. 12032) ## Название товара ## Фирма-производитель Страна ## 1: GlaxoSmithKline Dungarvan Ltd (Ирландия) Ирландия ## 2: Амида Косметик ООО Россия ## 3: Негоциант ТД Россия ## 4: Негоциант ТД Россия ## 5: Негоциант ТД Россия ## 6: НЕГОЦИАН ООО Россия ## 7: Негоциант ТД Россия ## 8: Фитокосметик ООО Россия ## 9: УралМедПром Россия ## 10: Илецксоль Россия ## 11: Линстек Инхим (г.С-Петербург) Россия ## 12: УралМедПром Россия ## 13: УралМедПром Россия ## 14: Jelfa Pharmaceutical Company S.A. Польша ## 15: Jelfa Pharmaceutical Company S.A. Польша ## 16: Gedeon Richter Румыния ## 17: ВИС ООО Россия ## 18: Леовит нутрио (г.Москва) Россия ## 19: Bouty S.p.A. Италия ## 20: Bouty S.p.A. Италия ## 21: Bouty S.p.A. Италия ## 22: Egis Pharmaceuticals Plc Венгрия ## 23: Egis Pharmaceuticals Plc Венгрия ## 24: АМТ Трейд ООО (г.Москва) Россия ## 25: Неизвестный производитель Германия ## 26: Неизвестный производитель Германия ## 27: Неизвестный производитель Германия ## 28: Yelowcare Ltd Китай ## 29: Мир детства Таиланд ## 30: NIP GmbH Германия ## 31: NIP GmbH Германия ## 32: NIP GmbH Германия ## 33: Нюрнберг Гуми, Georgensgmund Германия ## 34: Мир детства Россия ## 35: Мир детства Россия ## 36: Мир детства Таиланд ## 37: Мир детства Таиланд ## Фирма-производитель Страна ## Вид товара Поставщик Кол-во Сумма закупки с НДС ## 1: Лекарственные средства АЛЬФА-РИТМ ООО 8 882,6 ## 2: АЛЬФА-РИТМ ООО 2 66,60 ## 3: АЛЬФА-РИТМ ООО 2 54,40 ## 4: АЛЬФА-РИТМ ООО 1 29,40 ## 5: АЛЬФА-РИТМ ООО 1 66,70 ## 6: АЛЬФА-РИТМ ООО 2 54,40 ## 7: АЛЬФА-РИТМ ООО 3 81,60 ## 8: АЛЬФА-РИТМ ООО 6 244,80 ## 9: Парафармацевтика АЛЬФА-РИТМ ООО 45 1284,50 ## 10: Парафармацевтика АЛЬФА-РИТМ ООО 5 231,00 ## 11: Парафармацевтика АЛЬФА-РИТМ ООО 1 27,20 ## 12: Парафармацевтика АЛЬФА-РИТМ ООО 1 24,30 ## 13: АЛЬФА-РИТМ ООО 5 149,50 ## 14: Лекарственные средства АЛЬФА-РИТМ ООО 19 4599,20 ## 15: Лекарственные средства АЛЬФА-РИТМ ООО 26 10301,25 ## 16: Лекарственные средства АЛЬФА-РИТМ ООО 1 386,60 ## 17: Биологически активные добавки АЛЬФА-РИТМ ООО 1 266,50 ## 18: Биологически активные добавки АЛЬФА-РИТМ ООО 12 1649,00 ## 19: АЛЬФА-РИТМ ООО 3 417,60 ## 20: Изделия медицинского назначения АЛЬФА-РИТМ ООО 12 4433,90 ## 21: Изделия медицинского назначения АЛЬФА-РИТМ ООО 33 5385,60 ## 22: Лекарственные средства АЛЬФА-РИТМ ООО 18 5770,60 ## 23: Лекарственные средства АЛЬФА-РИТМ ООО 23 9764,30 ## 24: АЛЬФА-РИТМ ООО 35 485,50 ## 25: АЛЬФА-РИТМ ООО 2 61,40 ## 26: АЛЬФА-РИТМ ООО 4 101,60 ## 27: АЛЬФА-РИТМ ООО 2 50,80 ## 28: АЛЬФА-РИТМ ООО 1 66,50 ## 29: АЛЬФА-РИТМ ООО 2 127,60 ## 30: Детское питание АЛЬФА-РИТМ ООО 3 113,10 ## 31: АЛЬФА-РИТМ ООО 3 69,90 ## 32: АЛЬФА-РИТМ ООО 2 67,40 ## 33: АЛЬФА-РИТМ ООО 2 65,00 ## 34: АЛЬФА-РИТМ ООО 2 110,00 ## 35: ГК МРТК&quot; ООО 2 111.14 ## 36: АЛЬФА-РИТМ ООО 2 131,4 ## 37: АЛЬФА-РИТМ ООО 2 127,6 ## Вид товара Поставщик Кол-во Сумма закупки с НДС ## Цена закупки с НДС Сумма по продаже Цена продажи ## 1: 110,33 1164.0 145.50 ## 2: 33,30 98.0 49.00 ## 3: 27,20 80.0 40.00 ## 4: 29,40 43.0 43.00 ## 5: 66,70 97.0 97.00 ## 6: 27,20 80.0 40.00 ## 7: 27,20 120.0 40.00 ## 8: 40,80 360.0 60.00 ## 9: 28,54 1835.0 40.78 ## 10: 46,20 335.0 67.00 ## 11: 27,20 40.0 40.00 ## 12: 24,30 36.0 36.00 ## 13: 29,90 220.0 44.00 ## 14: 242,06 5383.0 283.32 ## 15: 396,20 12020.0 462.31 ## 16: 386,60 447.9 447.90 ## 17: 266,50 374.0 374.00 ## 18: 137,42 2304.0 192.00 ## 19: 139,20 606.0 202.00 ## 20: 369,49 5528.0 460.67 ## 21: 163,20 7881.0 238.82 ## 22: 320,59 7155.0 397.50 ## 23: 424,53 12236.0 532.00 ## 24: 13,87 700.0 20.00 ## 25: 30,70 92.0 46.00 ## 26: 25,40 152.0 38.00 ## 27: 25,40 76.0 38.00 ## 28: 66,50 98.0 98.00 ## 29: 63,80 188.0 94.00 ## 30: 37,70 165.0 55.00 ## 31: 23,30 105.0 35.00 ## 32: 33,70 100.0 50.00 ## 33: 32,50 96.0 48.00 ## 34: 55,00 164.0 82.00 ## 35: 55.57 164.0 82.00 ## 36: 65,7 194.0 97.00 ## 37: 63,8 188.0 94.00 ## Цена закупки с НДС Сумма по продаже Цена продажи "],["dataviz.html", "Dataviz Запись занятия Intro Инфографика Типы графиков d3 (Data-Driven Documents) Dashboards Focuses Data looks better naked Principles Misleading charts Полезные материалы", " Dataviz Запись занятия Intro Цели визуализации и, в общем виде, визуального формата хранения материалов: Record information - photographs, seismographs etc- Часть информации сложно представима в числовом виде - например, медицинские снимки, фотографии, записи датчиков и т.д. Analyze data to support reasoning - Представление данных в визуальном виде (графики и т.д.) может быть использовано как минимум в двух напарвлениях: Develop and assess hypotheses (visual exploration) - анализ и интепретация процессов. Например, интерпретация ЭЭГ/ЭКГ, или же резкие изменения в тренде. Впрочем, наивный анализ трендов так же вполне может быть основан на анализе графиков. Также подкрепление выводов, дополнительная аргументация. Find patterns and discover errors in data - нередко визуальный анализ позволяет сделать вывод о каких-то паттернах в данных, которые достаточно сложно найти, оперируя только таблицами данных. Например, лакуны в данных или паттерны пропусков в опросах. Communicate information to others (visual explanation) - презентация в понятном графическом виде результатов исследования или описания какого-то феномена через художественно представленные данные (инфографика, дата-сторителлинг) (с) cs171 Visualization Инфографика В общем виде инфографика - это это графический способ подачи информации, данных и знаний, целью которого является быстро и чётко преподносить сложную информацию (wiki) Один из подходов, в котором обычно работают исследователи, аналитики, BI, продакт-менеджеры и т.д. предполагает донесение до целевой аудитории необходимой информации максимально точно. Это минималистичный подход, в котором ценны чистота, прозрачность, семантическая насыщенность всех элементов визуализации. Обычно аналитики используют спец.пакеты и языки программирования для создания графических презентаций своих данных. Далее я буду говорить про визуализацию именно в этом ключе. Второй подход - донесение до целевой аудитории информации через сюжет, через создание привлекательных образов, иллюстративность и выразительность дизайна. Обычно в таком ключе работают дата-журналисты и дизайнеры рекламных и маркетинговых материалов. Пример такого поясняющего подхода - место простого графика двух значений, в иллюстрации создается контекст (практика использования стиральной машинки), синий цвет для “actually washing” хорошо обыгрывает идею воды в стиральной машине и доли времени. При этом, на графике нет чисел - визуального соотношения площади желтого и синего цветов достаточно, чтобы донести основную мысль. Типы графиков scatter plot Самый простой график - scatter plot, он же точечный график или, в некоторых случаях, диаграмма рассеяния. По оси OX обычно интервальные данные (степень выраженности признака), в редких случаях категории или линия времени. По OY, как правило, интервальные данные. График полезен, когда надо хотя бы бегло оценить взаимосвязь признаков (возможные группировки и скопления). Например, график связи замера бриллианта и его цены, с группировкой по качеству огранки. Даже не таком простом графике видно, что чем больше камень, тем он дороже, но и среди дорогих камней встречаются камни с неидеальной огранкой. Второй простой пример – график рассеяния, визуализация связи веса пингвинов и длины плавника, цветом выделены разные виды. line chart Линейный график - по сути, расширение точечного графика (объединение точек линиями). Обычно такие графики используют для визуализации трендов, динамики цен и прочей хронологической информации. Они более удобны, чем просто точечные графики, так как лучше позволяют видеть резкие скачки значений и т.д. bar chart Второй по популярности график - bar chart, он же столбиковая диаграмма. По оси OX обычно указывают категорию, в некоторых случаях - упорядоченные категории (этапы, года и т.д.). По оси OY, как правило, указано количество или доля. Гистограмма близкий вид графиков, с единственным отличием - в гистограмме по оси OX указываются группы интервальных значений, а не каждое значение. Притом размер группы выбирается произвольно. Гистограммы обычно используются для отображения формы распределения признака. Вариация с категориями по оси OX: grouped bar chart Вариация барчарта, в которой используется группирующая переменная — таким образом, можно сравнивать группы в рамках одной категории. Естественно, деление по группам и категориям зависит от решения аналитика и целей визуализации. payments[, list(gross = sum(gross)), keyby = list(week, offer_type)]%&gt;% plot_ly(x = ~offer_type, y = ~gross, color = ~as.character(week), type = &#39;bar&#39;) %&gt;% # plot_ly(x = ~week, y = ~gross, color = ~offer_type, type = &#39;bar&#39;) %&gt;% layout( barmode = &#39;group&#39;, title = &#39;Динамика платежей по типам&#39;, yaxis = list(rangemode = &#39;tozero&#39;)) %&gt;% config(displayModeBar = FALSE) ## Warning in RColorBrewer::brewer.pal(N, &quot;Set2&quot;): n too large, allowed maximum for palette Set2 is 8 ## Returning the palette you asked for with that many colors ## Warning in RColorBrewer::brewer.pal(N, &quot;Set2&quot;): n too large, allowed maximum for palette Set2 is 8 ## Returning the palette you asked for with that many colors stacked bar chart Вторая вариация барчарта с группировкой, только бары группы в одной категории указываются “стопкой”, одним баром с цветовым делением групп. Обычно таким образом визуализируют структуру - например, структуру прибыли по разным источникам. На русском языке иногда называют “накопительной столбиковой диаграммой” / “столбиковой диаграммой с накоплением”. area plot Это вид графика является совмещением линейного графика (таймлайна) и барчарта с группами “стопкой”. С помощью такого графика можно отслеживать изменения в структуре наблюдаемого процесса, например, в структуре прибыли или аудитории. area plot (percentiles) Area-плот можно делать не только по абсолютным значениям, но и по долям от общей суммы. Например, изменение доли заболевших с разбивкой по странам. boxplot Визуализация распределения параметра, квартили, медиана и усы - полуторный межквартильный размах. Боксплоты на данных diamonds: violin plot Расширение боксплотов, кривыми отражается еще распределение признака, а не только квартили. heatmap Тепловая карта, обычно используется в ситуациях, когда надо как-то отразить три измерения - например, количество пользователей, которые заходят на сайт в зависимости от дня недели и времени суток. Аналогично можно построить контурную карту, например, карту, куда и сколько времени смотрят пользователи при работе с сайтом (по данным айтрекера) На графике - топографическая информация о вулканах в районе Окленда. Стоит отметить, что для топологических данных контурные карты даже более подходящий тип графиков, чем тепловая карта. &lt;!– # – &gt; You now have 4 files. One of these files is a .shp file! (TM_WORLD_BORDERS_SIMPL-0.3.shp) –&gt; geo plots: leaflet map Однако можно что-то рисовать на картах и с помощью координат (широты и долготы), в таких картах в качестве подложки обычно используются карты городов, географические карты и т.д. (слои бывают весьма разные). Тут простое количество случаев коронавируса на карте Китая, с группировкой при уменьшении масштаба. d3 (Data-Driven Documents) d3 - open source технология для построения сложных интерактивных визуализаций, использует javascript. В RStudio встроены инструменты для работы с d3-визуализациями (в том числе пакет r2d3) , однако в целом это нечастый инструмент для аналитиков - как правило, они пользуются готовыми решениями типа plotly и/или highcharts. Галерея и вики проекта: https://github.com/d3/d3/wiki/Gallery Новая версия галереи: https://observablehq.com/@d3/gallery Пример d3-визуализации, Hierarchical Edge Bundling: Dashboards Дашборды - группы графиков, которые позволяют быстро отслеживать динамику ключевых показателей проекта. Дашборд Яндекса по статистике заболеваний COVID-19: https://datalens.yandex/7o7is1q6ikh23?tab=X1&amp;state=6177dceb304 Focuses Иногда мало нарисовать график, нередко требуется акцентировать внимание пользователя на какой-либо части графика. Например, на этом графике выделяется дом Таргариенов: &lt;img src=“./pics/vis_focus_bar.jpg”, width=“600px;”&gt; Data looks better naked Один из принципов Эдварта Тафта (data-ink ration) требует, чтобы на графике не было визуального мусора или другой информации, не требуемой для представления данных. the data-ink ratio Прмер очистки графика от визуального мусора (смена слайдов по клику или стрелочками): clear-off-the-table Прмер очистки таблиц: Principles Несколько базовых идей, которым следуют аналитики при подготовке визуализаций: Если график не помогает донести мысль – он не нужен Всегда надо помнить, что, кому и как мы будем доносить Меньше визуального мусора Визуализация должна быть честной Необязательно быть художником или дата-сатанистом Misleading charts Плохой дизайн Сочетание разных категорий в одном горизонтальном баре контринтуитивно и не позволяет сопоставлять года друг с другом, как и анализировать динамику показателей. Ко всему прочему, график просто некорректен - нельзя складывать и автоаварии, и смерти. Вроде как неплохая идея визуализировать рост убийств в виде увеличившихся потеков “крови” и инвертированной оси OY не читается, красный цвет воспринимается как фон. В результате получается обратный результат - у читателя создается впечатление, что после введения закона ‘Stand your ground’ количество убийств снизилось. Арифметические ошибки Классика. Еще одна распространенная ошибка - при множественных вариантах ответов выбирать пайчарт нельзя, так как сумма может быть больше 100%. Впрочем, пайчартами в целом нельзя пользоваться. Манипуляция вниманием Из-за разных интервалов по оси OX создается впечатление стремительного линейного роста. На деле же динамика была не совсем такой, и прямой линейный тренд маскирует резкий скачок в марте 2009 года. Отличный пример, как можно манипулировать восприятием графика - объемный пайчарт и так сложно корректно интерпретировать, а тут еще и перспектива выстроена так, что синий сектор немного больше зеленого и в два раза больше коричневого. Неверный масштаб Классическая ошибка/манипуляция, когда из-за неверного масштаба (ось OY начинается не от 0), различия преувиличиваются. Вок как реально выглядят значения со слайда - бар за 2017 год не на треть больше 2016, а примерно на десятую часть. То есть, рост преувеличен в три раза. Еще один пример некорректного масштаба (или даже это просто несоответствие графиков цифрам) - различие в 2% между Мегафоном и Билайном в первом квартале 2012 года чуть ли не в 4 раза больше различия в 5% между Билайном и МТС. Несоответствие графиков цифрам Иллюстрация из газеты “Правда”, которую Тафт приводит в свей книге - во-первых, площадь кругов не соответствует значениям (вряд ли в самом правом круге можно уместить 537 самых левых кругов). Во-вторых, такие значения по годам не укладываются в линейный тренд. Тут, мне кажется, коментарии просто излишни. Полезные материалы Чартомойка - “О графиках: плохих, хороших и других. От восхищения до ненависти — один chart” Датавиз-чат - ссылка-инвайт в телеграм чат тех, кто занимается инфографикой Ссылки и материалы для тех, кто проходит гарвардский курс cs171 (Visualization), хорош набором ссылок на англоязычные книги и инструменты. Графики, которые убеждают всех - книга по визуализации от ведущего канала “Чартомойка”. Буквально недавно вышла в печатном виде, есть и электронная версия. Постер для выбора графиков - приложение к книге “Графики, которые убеждают всех”. Джин Желязны “Говори на языке диаграмм” - одна из базовых книг-введений в инфографику. По ссылке более подробная аннотация, саму книгу, при желании, также можно найти. Flowingdata - один из самых известных англоязычных ресурсов, посвященных инфографике. Блог ведет Нейтан Яу, автор книги «Искусство визуализации в бизнесе» (перевод и издание МИФ). Галерея разных типов графиков. Moscow Dataviz Awards конкурс на лучшую инфографику, есть очень красивые и интересные работы. "],["ggplot2-pt1.html", "ggplot2 pt1 Запись занятий Решение домашней работы ggplot2 package Дополнительные материалы Домашнее задание", " ggplot2 pt1 Запись занятий Решение домашней работы level 1 (IATYTD) У вас есть xlsx-файл по популяции и видам пингвинов. Импортируйте данные из этого файла в R. При работе постарайтесь обойтись только средствами R, не открывая файл в Excel. Проверьте, что вы импортировали все листы. При необходимости, импортируйте оставшиеся и соберите все в одну таблицу. # подключаем data.table library(data.table) # подключаем пакет для чтения xlsx-файлов library(readxl) # файл можно скачать и сохранить на диск руками или кодом download.file(&#39;https://gitlab.com/hse_mar/mar211s/raw/main/data/pinguins.xlsx&#39;, &#39;pings.xlsx&#39;) # смотрим, какие есть листы в файле sheets &lt;- readxl::excel_sheets(&#39;pings.xlsx&#39;) sheets ## [1] &quot;adelie&quot; &quot;gentoo&quot; &quot;chinstrap&quot; Проверьте класс объекта и при необходимости преобразуйте в data.table. Посчитайте количество пингвинов каждого типа (колонка Species). # читаем листы файла и сразу же склеиваем их с помощью rbind # можно это делать с помощью промежуточных переменных: sheet1 &lt;- read_excel(&#39;pings.xlsx&#39;, sheet = sheets[1]) pings &lt;- rbind( read_excel(&#39;pings.xlsx&#39;, sheet = sheets[1]), read_excel(&#39;pings.xlsx&#39;, sheet = sheets[2]), read_excel(&#39;pings.xlsx&#39;, sheet = sheets[3]) ) # преобразовываем в data.table, два варианта можно использовать: # pings &lt;- as.data.table(pings) или такой: setDT(pings) # считаем количество строк и уникальных пингвинов в рамках каждого вида pings[, list(n_rows = .N, n_pinguins = uniqueN(`Individual ID`)), by = Species] ## Species n_rows n_pinguins ## 1: Adelie Penguin (Pygoscelis adeliae) 152 132 ## 2: Gentoo penguin (Pygoscelis papua) 124 94 ## 3: Chinstrap penguin (Pygoscelis antarctica) 68 58 level 2 (HNTR) У вас есть данные Tate Gallery по художникам и их произведениям. Импортируйте датасеты по художникам, ссылки на файлы ниже. А лучше воспользуйтесь функцией download.file() (не забудьте прочитать справку по функции и ее аргументам) для того, чтобы сохранить эти файлы на диск и потом загружать их уже с диска, а не из интернета. # создаем объект с ссылкой и используем его потом в функци импорта данных url_artwork &lt;- &#39;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-01-12/artwork.csv&#39; artwork &lt;- fread(url_artwork) url_artists &lt;- &quot;https://github.com/tategallery/collection/raw/master/artist_data.csv&quot; artists &lt;- fread(url_artists) С помощью функции setnames() пакета data.table (или names() из базового пакета, если вам так удобнее) переименуйте в файле по художникам колонки yearOfBirth в year_of_birth, колонки yearOFDeath, placeOfBirth и placeOfDeath аналогично. # используем функцию пакета setnames setnames( # указываем табличку класса data.table artists, # указываем вектор названий колонок, которые мы хотим переименовать old = c(&#39;yearOfBirth&#39;, &#39;yearOfDeath&#39;, &#39;placeOfBirth&#39;, &#39;placeOfDeath&#39;), # указыаем вектор новых названий колонок new = c(&#39;year_of_birth&#39;, &#39;year_of_death&#39;, &#39;place_of_birth&#39;, &#39;place_of_death&#39;) ) посчитайте, сколько художников из списка живы в настоящий момент. # как живущих считаем тех, у кого нет даты смерти artists[is.na(year_of_death), .N] ## [1] 1304 посчитайте, сколько среди живущих в настоящий момент художников мужчин и сколько женщин. # считаем с группировкой по полу artists[is.na(year_of_death), .N, by = gender] ## gender N ## 1: Female 297 ## 2: Male 944 ## 3: 63 level 3 (HMP) подумайте и покажите решение, как можно узнать структуру файла artwork, однако полностью импортировать вы его не можете (предположим, что он настолько большой, что повесит систему намертво). # для того, чтобы узнать структуру, можно скачать только первые несколько строк # я импортирую с диска, так как когда импортируем по ссылке, все равно происходит скачивание на диск, # только во временный файл, который потом уже импортируется через в рабочее окружение artwork_small &lt;- fread(&#39;./data/artwork.csv&#39;, nrows = 5) импортируйте только те колонки, которые позволят вам идентифицировать художника, название работы и ее формат (колонка medium). # чтобы импортировать только некоторые которые колонки, # указываем вектор их названий в атрибуте select artwork &lt;- fread(&#39;https://gitlab.com/hse_mar/mar211s/raw/main/data/artwork.csv&#39;, select = c(&#39;artist&#39;, &#39;artistId&#39;, &#39;artistRole&#39;, &#39;medium&#39;)) посчитайте, сколько в галерее работ от художников-мужчин и сколько от женщин. Отдельной колонкой выведите статистики по живущим на данный момент художникам. # склеиваем работы и их авторов, так как в одной таблице artistId, а в другой id # поэтому используем by.x и by.y. либо надо переменовать, id в artistId и использовать by artwork &lt;- merge(artwork, artists[, list(id, gender, year_of_death)], by.x = &#39;artistId&#39;, by.y = &#39;id&#39;, all.x = TRUE) artwork[, list( # считаем количество работ (это тождественно количеству строк в любой колонке) по всем художникам n_works = length(medium), # считаем количество работ только по тем художникам, у которых нет даты смерти n_works_alive = length(medium[is.na(year_of_death)])), by = gender] ## gender n_works n_works_alive ## 1: Male 65774 6883 ## 2: 694 504 ## 3: Female 2727 1381 ## 4: &lt;NA&gt; 6 6 посчитайте, сколько работ разных форматов сделали художницы, умершие до 1800 года (какждый формат – отдельная колонка, форматы даны в колонке medium). Вам потребуется функция dcast(). # делаем решейпинг dcast( # сначала фильтруем датасет, можно его в отдельную переменную отфильтровать и использовать ее artwork[gender == &#39;Female&#39; &amp; year_of_death &lt; 1800], # указываем, что должно быть по строкам, что в колонках artist ~ medium, # указываем функцию агрегации -- простое количество ячеек (что тождественно количеству работ, # если мы считаем, что нет дублей записей) fun.aggregate = length ) ## artist Graphite and ink on paper Oil paint on canvas ## 1: Beale, Mary 0 1 ## 2: Sanders, Ann 0 0 ## 3: Spencer, Lady 1 0 ## Oil paint on paper Watercolour on paper ## 1: 2 0 ## 2: 0 1 ## 3: 0 0 ggplot2 package Компоненты графика Все графики, которые можно создать с помощью пакета, могут быть разделены на несколько компонентов: данные пространство координат визуальные параметры (aesthetics) геометрическая форма представления данных (geom) статистические вычисления и трансформации (stats) параметры смещения графиков на координатной сетке (position adjustment) параметры осей (scales) фасеты (группировка, facets) Ниже представлен типовой код создания графика с помощью пакета ggplot2. На графике отражены все перечисленные структурные элементы: данные (объект mpg), координатная сетка (coord_cartesian()), параметры визуализаций (функция aes() и ее аргументы). Основная особенность синтаксиса ggplot2 - его аддитивность, когда объект графика создается путем постепенного добавления к базовому объекту новых элементов и/или параметров визуализаций. Базовый объект создается с помощью функции ggplot(), а различные слои, геометрические объекты или текстовые метки, параметры визуализаций и т.д. - другими функциями, через внутренний оператор +: ggplot() + geom_smooth(method = &#39;lm&#39;) + geom_point(data = mpg, mapping = aes(x = hwy, y = cty, color = cyl)) + coord_cartesian() + scale_color_gradient() + theme_classic() Базовые геомы geom_point() Функция geom_point() позволяет конструировать точечные диаграммы (графики рассеяния). Стандартные аргументы функций: data (таблица, данные из которой надо отрисовать), mapping - с помощью этого аргумента указываются, какие колонки таблица как именно будут использованы при отрисовке (какие будут задавать оси, какие - цвета или форму). # подключаем библиотеки library(ggplot2) library(data.table) # импорт данных # imdb_link &lt;- &#39;https://gitlab.com/hse_mar/mar221s/raw/master/data/IMDb%20movies.csv&#39; imdb_link &lt;- &#39;./data/IMDb movies.csv&#39; tg_cols &lt;- c(&quot;director&quot;, &quot;title&quot;, &quot;original_title&quot;, &quot;year&quot;, &quot;genre&quot;, &quot;duration&quot;, &quot;country&quot;, &quot;avg_vote&quot;) imdb &lt;- fread(imdb_link, select = tg_cols) imdb[, year := as.numeric(year)] ## Warning in eval(jsub, SDenv, parent.frame()): NAs introduced by coercion imdb_woody &lt;- imdb[director == &#39;Woody Allen&#39;] imdb_martin &lt;- imdb[director == &#39;Martin Scorsese&#39;] imdb_lynch &lt;- imdb[director == &#39;David Lynch&#39;] imdb_wm &lt;- rbind(imdb_woody, imdb_martin) imdb_genres &lt;- imdb[genre %in% c(&#39;Horror&#39;, &#39;Comedy&#39;, &#39;Drama&#39;)] imdb_genres_scores &lt;- imdb_genres[, list(n_titles = .N, votes = mean(avg_vote)), by = list(year, genre)] theme_set(theme_classic()) Рисуем точками фильмы, которые выпустил Дэвид Линч. Задаем базовый объект с помощью ggplot() и на него наслаиваем геом geom_point(). Получаем стандартный график, где черным цветом отрисованы точки, а названия осей взяты из названий колонок. ggplot() + geom_point(data = imdb_lynch, mapping = aes(x = year, y = avg_vote)) geom_point() aesthetics У geom_point() есть множество опций, которые позволяют задать визуальные параметры (aesthetics) точки графика. Самые часто используемые: colour: цвет края точки (названимем или rgb-кодом) fill: цвет заливки точки (названимем или rgb-кодом) shape: форма точки, можно задать номером или по названию. size: размер точки alpha: прозрачность точки Типы точек по номерам: Типы точек по названиям: Настройка визуальных параметров Визуальные параметры можно задать двумя методами. Первый - когда форма, цвет или размер точки задаются не пользователем, а берутся из значений колонки в датасете. В таком случае визуальный параметр задается в аргументе mapping. Повторим предыдущий график (фильмы Линча), и в mapping укажем, что цвет и форма точки задаются по значениям из колонки country, а размер точки берется из значений в колонке duration. ggplot() + geom_point(data = imdb_lynch, mapping = aes(x = year, y = avg_vote, color = country, shape = country, size = duration)) Второй метод настройки визуальных параметров - когда значение параметра задается прямо в коде, конкретным значением. И этот параметр будет применен ко всем точкам графика. В таком подходе параметры задаются не в аргументе mapping, а как отдельные аргументы функции геома (geom_point()). На графике ниже все точки, маркирующие фильмы Дэвида Линча, покрашены в красный цвет и сделаны ромбами, независимо от страны или еще каких-то других особенностей фильма. А вот размер точки все также зависит от значений в колонке duration: ggplot() + geom_point(data = imdb_lynch, mapping = aes(x = year, y = avg_vote), color = &#39;red&#39;, shape = &#39;diamond&#39;, size = 4) geom_line() Практически идентичный geom_point() по конструкции геом для отрисовки линий. В отличие от geom_point() предполагается, что одному значению по xсоответствует одно значение по y. Либо их может быть несколько, но тогда должна так же быть группирующая переменная, которая позволит различать, что несколько значений по y для одного x принадлежат разным линиям. Покажем динамику оценко фильмов жанра Horror: ggplot() + geom_line(data = imdb_genres_scores[genre == &#39;Horror&#39;], mapping = aes(x = year, y = votes)) Воспользуемся механизмом добавления слоев и добавим на график еще и точки: ggplot() + geom_line( data = imdb_genres_scores[genre == &#39;Horror&#39;], mapping = aes(x = year, y = votes)) + geom_point( data = imdb_genres_scores[genre == &#39;Horror&#39;], mapping = aes(x = year, y = votes)) geom_line() aesthetics Основные визуальные параметры схожи с параметрами точек, тип линии задается параметром linetype: colour: цвет линии (названием или rgb-кодом) linetype: тип линии size: толщина линии alpha: прозрачность линии Типы линий можно задать как номером, так и названием: Пунктирные линии также можно задать кодом, код должен состоять из 2, 4, 6 или 8 символов шестнадцатиричной системы счисления, где цифры обозначают количество точек. Например, код 3519 означает ‘три отрисуй, 5 пропусти, 1 отрисуй, 9 пропусти, повторяй в цикле’. В результате получается вот такой вот кастомный пунктир: ggplot() + geom_line(data = imdb_lynch, mapping = aes(x = year, y = avg_vote), linetype = &#39;3519&#39;, size = 1) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. Настройка визуальных параметров Аналогично geom_point(), можно указать конкретные значения, можно указать, что значения должны браться из определенной колонки датасета. Возьмем датасет по жанрам, чтобы можно было в зависимости от жанра указать тип и цвет линии: ggplot() + geom_line(data = imdb_genres_scores, mapping = aes(x = year, y = votes, group = genre, color = genre, linetype = genre)) Если указать эти параметры не в mapping, а задать конкретные значения, то изменены будут параметры всех линий, независимо от жанра: ggplot() + geom_line(data = imdb_genres_scores, mapping = aes(x = year, y = votes, group = genre, color = genre, linetype = genre), size = 1.5) геомы визуальных акцентов geom_vline() Простейший геом, который позволяет с помощью вертикальной линии акцентировать внимание пользователя на какой-то части кода (vline - vertical line). Точка на оси OX, из которой выводится линия, задается с помощью аргумента xintercept. Этот геом не требует обязательного указания датасета и осей, так как не особо зависит от них - главное, чтобы ось OX была такого же типа, как задается xintercept (число, строка, дата). Укажем на графике границу 2000 года, чтобы понять, какие фильмы Линч снял после 2010 года. ggplot() + geom_point( data = imdb_lynch, mapping = aes(x = year, y = avg_vote, color = country, shape = country, size = duration)) + geom_vline(xintercept = 2010) geom_hline() Аналогично geom_vline() позволяет нанести на график горизонтальную линию. Для этого надо указать yintercept - значение на оси OY, из которого будет выводиться линия, параллельная OX. Графически отметим фильмы, которые имеют avg_vote больше 0. У Дэвида Линча был один фильм (согласно датасету), у которого оценка была заметно больше 8, и тот был задолго до 2000 года: ggplot() + geom_point( data = imdb_lynch, mapping = aes(x = year, y = avg_vote, color = country, shape = country, size = duration)) + geom_vline(xintercept = 2010) + geom_hline(yintercept = 8) geom_text() Еще один инструмент расстановки акцентов на график - нанесение текстовых меток значений. В самом простом виде geom_text() аналогичен геомам точек и линий, с единственным отличием - метки задаются с помощью аргумента label в mapping. В качестве источника значений для меток указывают колонку датасета, в нашем случае это original_title: ggplot() + geom_text( data = imdb_lynch, mapping = aes(x = year, y = avg_vote, label = original_title) ) geom_text() aesthetics Для текстовых меток на графике есть ряд дополнительных параметров, помимо размера или цвета. Это семейство шрифта (sans, serif, mono) и тип выделения (обычный, жирный, курсив). Так как текстовые метки обычно приводятся для каких-то других элементов графиков (точек или линий), еще есть аргументы hjust и vjust, для сдвига по вертикали или по горизонтали относительно целевой координаты. alpha: прозрачность angle: угол (если надо разместить метку под углом к точке) colour: цвет hjust: сдвиг по вертикали vjust: сдвиг по погризонтали lineheight: межстрочный интервал size: размер family: семейство шрифта (с засечками, без засечек) fontface: тип выделения check_overlap: если TRUE, то текстовые метки размещаются без того, чтобы перекрывать друг друга Значения для family и fontface: df_fontface &lt;- data.frame(x = 1:4, fontface = c(&quot;plain&quot;, &quot;bold&quot;, &quot;italic&quot;, &quot;bold.italic&quot;)) df_family &lt;- data.frame(x = 1:3, y = 3:1, family = c(&quot;sans&quot;, &quot;serif&quot;, &quot;mono&quot;)) ggplot() + geom_text(data = df_fontface, mapping = aes(x = x, y = 0.1, label = fontface, fontface = fontface), size = 10) + geom_text(data = df_family, mapping = aes(x = x, y = 0.2, label = family, family = family), size = 10) + lims(x = c(0.5, 4.5), y = c(0, 0.3)) + theme_void() Настройка визуальных параметров Аналогично прочим геомам - можно задать параметры как констранту, можно использовать значения определенных колонок для упарвления цветом, раззмером и т.д. У geom_text() также есть ряд параметров, который не может быть связан со значениями колонок - это запрет на пересечение текстовых меток (check_overlap) и смещение по вертикали/горизонтали (hjust, vjust). Сами по себе текстовые метки не очень инетерсны, поэтому также накладываем слой точек: ggplot() + geom_point( data = imdb_lynch, mapping = aes(x = year, y = avg_vote, size = duration), color = &#39;steelblue&#39;) + geom_text( data = imdb_lynch, mapping = aes(x = year, y = avg_vote, label = original_title), check_overlap = TRUE, hjust = -0.1 ) Дополнительные материалы Документация по пакету, есть примеры. Шпаргалки - короткие и наглядные справочные материалы по основам синтаксиса и базовым геомам R cookbook - сборник примеров и кейсов, как решать наиболее часто встречающиеся задачи при работе с ggplot2. Сгруппировано по разделам. R Graphics Cookbook, 2nd edition – сборник примеров и кейсов по разным типам визуализаций в базовом R и в ggplot2. Галерея расширений пакета ggplot2. Список названий цветов Elegant Graphics for Data Analysis (Use R!) - книга автора ggplot2, с очень внятным описанием базовых идей. При желании, можно найти в сети. Домашнее задание Задание 1 С помощью пакета ggplot2 отрисуйте график рассеяния, отражающий связь таких параметров, как carat и price. Используйте уже доступный после установки ggplot2 датасет diamonds, сделайте выборку на 10000 строк (используйте set.seed(1234) для генерации зерна генератора случайных цифр). Удалите строки, в которых carat &gt; 3. Сабсет назовите diamonds_sample. Для конвертации diamonds в data.table вам поможет as.data.table() Задание 2 Повторите предыдущий график, добавьте выделение цветом бриллиантов разного качества (cut). Задание 3 Добавьте на график из задания 2 вертикальную линию (OX = 2) и горизонтальную линию (OY = 15000). Задание 4 Выделите цветами из образованных вертикальной и горизонтальной линиями секторов первый и третий секторы (счет против часовой). Используйте зеленый и красный цвета соответственно, с параметром прозрачности opacity = 0.1. Сами линии можно не рисовать. Вам потребуется погуглить и выбрать необходимый геом для решения этой задачи. Задание 5 Модифицируйте предыдущий график - сделайте точки во втором и четвертом секторах черными. "],["ggplot2-pt2.html", "ggplot2 pt2 Запись занятий Решение домашки пакеты и данные Статистические геомы Кастомизация графиков Координатная плоскость Фасеты Визуальные параметры всего графика", " ggplot2 pt2 Запись занятий Решение домашки Импорт и подготовка данных: library(data.table) library(ggplot2) # задаем тему по умолчанию theme_set(theme_classic()) diamonds_sample &lt;- as.data.table(diamonds) diamonds_sample &lt;- diamonds_sample[carat &lt; 3] diamonds_sample &lt;- diamonds_sample[sample(.N, 10000)] Решение заданий 2-5: ggplot()+ # задание 1 geom_point(data = diamonds_sample, # добавление color = cut -- решение задания 2 mapping = aes(x = carat, y = price, color = cut), shape = &#39;diamond&#39;) + # задание 3, закомментировано, так как для заданий 4-5 оно избыточно # geom_vline(xintercept = 2) + # geom_hline(yintercept = 15000) + # задание 4 geom_rect( aes(xmin = 2, xmax = Inf, ymin = 15000, ymax = Inf), fill = &#39;green&#39;, alpha = 0.1 ) + geom_rect( aes(xmin = -Inf, xmax = 2, ymin = -Inf, ymax = 15000), fill = &#39;red&#39;, alpha = 0.1 ) + # задание 5, только цвет не &#39;black&#39; geom_point(data = diamonds_sample[(carat &lt; 2 &amp; price &gt;= 15000)], mapping = aes(x = carat, y = price), color = &#39;grey80&#39;, size = 1) + geom_point(data = diamonds_sample[(carat &gt;= 2 &amp; price &lt; 15000)], mapping = aes(x = carat, y = price), color = &#39;grey80&#39;, size = 1) пакеты и данные # подключаем библиотеки library(ggplot2) library(data.table) # импорт данных # imdb_link &lt;- &#39;https://gitlab.com/hse_mar/mar221s/raw/master/data/IMDb movies.csv&#39; imdb_link &lt;- &#39;./data/IMDb movies.csv&#39; tg_cols &lt;- c(&quot;director&quot;, &quot;title&quot;, &quot;original_title&quot;, &quot;year&quot;, &quot;genre&quot;, &quot;duration&quot;, &quot;country&quot;, &quot;avg_vote&quot;) imdb &lt;- fread(imdb_link, select = tg_cols) imdb[, year := as.numeric(year)] imdb_woody &lt;- imdb[director == &#39;Woody Allen&#39;] imdb_martin &lt;- imdb[director == &#39;Martin Scorsese&#39;] imdb_lynch &lt;- imdb[director == &#39;David Lynch&#39;] imdb_wm &lt;- rbind(imdb_woody, imdb_martin) imdb_genres &lt;- imdb[genre %in% c(&#39;Horror&#39;, &#39;Comedy&#39;, &#39;Drama&#39;)] imdb_genres_scores &lt;- imdb_genres[, list(n_titles = .N, votes = mean(avg_vote)), by = list(year, genre)] Статистические геомы geom_bar() Геом используется для отрисовки столбиковых диаграмм (барчартов). При использовании геома по оси ОХ указывают переменную категорий (даты, строковые значения и проч). У геома есть, среди прочих, есть важный параметр, stat. Когда stat = 'count' (это значение по умолчанию), то ось OY указывать не надо. Так как при отрисовке графика происходит вычисление количества наблюдений (строк) на каждое значение по оси OX, и именно по этому вычисленному значению отрисовываются столбики. (предупреждение Removed 108 rows containing non-finite values (stat_count). означает, что есть пропуски в колонке title_year) ggplot(imdb[genre == &#39;Horror&#39;], aes(x = year)) + geom_bar(stat = &#39;count&#39;) Когда stat = 'identity' (это значение надо пропиcывать), то необходимо указать и по значениям какой колонки строится ось OY. Этот вариант предпочтительнее в работе - лучше сначала явно создать отдельный объект, а потом его отрисовать, чем делать неявные вычисления при отрисовке графика. Здесь у нас не таблица с сырыми данными по фильмам, а агрегат по жанрам, который мы подготовили ранее (imdb_genres_scores). # указываем год как x, а количество строк как y ggplot(imdb_genres_scores[genre == &#39;Horror&#39;], aes(x = year, y = n_titles)) + geom_bar(stat = &#39;identity&#39;) geom_bar() aesthetics Основные параметры: colour: цвет края столбика (названимем или rgb-кодом) fill: цвет заливки столбика (названимем или rgb-кодом) alpha: прозрачность заливки столбика position: если групп несколько, то как должны быть организвоаны столбики по группам - “стопкой” или “рядом” Настройка визуальных параметров Как и во всех геомах, можно использовать колонки датасета для того, чтобы задать цвет контура или заливки столбика. Обычно делается только в том случае, когда есть разные группы в датасете, и их надо выделить цветом. Во всех остальных случаях цвета контура и заливки, как правило, задаются фиксировнными значениями: ggplot(imdb_genres_scores[genre == &#39;Horror&#39;], aes(x = year, y = n_titles)) + geom_bar(stat = &#39;identity&#39;, color = &#39;darkblue&#39;, fill = &#39;steelblue&#39;, alpha = 0.1) Группировка может быть двух видов - “стопкой”, когда в столбике на одном значении OX выделены цветом группы. Это значение по умолчанию, и задается с помощью параметра position - 'stack'. Отрисуем, сколько фильмов разных жанров снимали каждый год. Цвета заливки и контура столбика задаем по значениям колонки genre (каждая страна выделяется одним цветом): ggplot(imdb_genres_scores, aes(x = year, y = n_titles)) + geom_bar( mapping = aes(color = genre, fill = genre), stat = &#39;identity&#39;, position = &#39;stack&#39; ) Тот же самый график, но с группировкой “рядом”: ggplot(imdb_genres_scores, aes(x = year, y = n_titles)) + geom_bar( mapping = aes(color = genre, fill = genre), stat = &#39;identity&#39;, position = &#39;dodge&#39; ) geom_histogram() Гистограммы во многом похожи на барчарты c stat = 'count', с единственным отличием. Барчарты строятся на дискретных значения оси OX (имя режиссера, дата и проч). А гистограммы строятся на интервальной шкале, то есть, позволяют самим выбирать, сколько значений по оси OX будет в одном столбике. Это задается параметром binwidth: Построим гистограмму по количеству фильмов с шагом пять лет: ggplot(imdb, aes(x = year)) + geom_histogram(binwidth = 5) ## Warning: Removed 1 rows containing non-finite values (`stat_bin()`). Построим гистограмму по количеству фильмов с шагом в 1 год, это должно быть идентично geom_bar(): ggplot(imdb, aes(x = year)) + geom_histogram(binwidth = 1) ## Warning: Removed 1 rows containing non-finite values (`stat_bin()`). geom_boxplot() Геом для отрисовки боксплотов, по конструкции похож на geom_bar(). Отрисуем боксплоты распределений оценок фильмов трех разных жанров: ggplot(imdb_genres_scores, aes(x = genre, y = votes)) + geom_boxplot() Укажем, чтобы цвет заливки и контура боксплота были свои для каждого режиссера. Так как заливка в чистом виде непрозрачная, необходимо отдельно указать параметр alpha, который задаст степень прозрачности заливки: ggplot(imdb_genres_scores, aes(x = genre, y = votes)) + geom_boxplot(aes(colour = genre, fill = genre), alpha = 0.1) geom_smooth() Геом задает линии тренда. Как правило, линии задаются формулой y ~ x, где значения по y - зависимая, а x - независимая, предиктор. Методов построения линии может быть несколько, не только lm и loess (линейная регрессия и локальная полиномиальная регрессия соответственно), подробнее в справке по геому в аргументе method. Построим по облаку точек фильмов из жанра Drama тренд imdb-оценок. Нарисуем сначала собственно облако точек, а потом зададим линию тренда с помощью loess и линейной регрессии. ggplot(imdb_genres_scores[genre == &#39;Drama&#39;], aes(x = year, y = votes)) + geom_point() + geom_smooth(method = &#39;glm&#39;) + geom_smooth(method = &#39;loess&#39;) ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## `geom_smooth()` using formula = &#39;y ~ x&#39; geom_smooth() aesthetics Визуальные параметры геома в первую очередь включают в себя параметры линии, а также параметры доверительного интервала: colour: цвет линии fill: цвет заливки области доверительного интервала alpha: прозрачность заливки области доверительного интервала se: если se = FALSE, то доверительный интервал скрывается ggplot(imdb_genres_scores[genre == &#39;Drama&#39;], aes(x = year, y = votes)) + geom_point() + geom_smooth(method = &#39;glm&#39;, color = &#39;blue&#39;, se = FALSE, size = 1.5) + geom_smooth(method = &#39;loess&#39;, color = &#39;red&#39;, fill = &#39;red&#39;, alpha = 0.1) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## `geom_smooth()` using formula = &#39;y ~ x&#39; Кастомизация графиков Параметры осей Оси относятся к одному из тех компонентов графиков, которые едины для всех заданных слоев. Как правило, при создании графиков в параметрах осей задают названия осей, метки, градиенты цветов (если цвет в слое указан как зависящий от какой-то третьей переменной, в aes()), трансформации осей (логарифмические, квадратным корнем, инверсией) и прочее. scale_(x|y)_* {-} Три группы функций, которые задают параметры осей OX или OY. Функции зависят от типа данных по оси: scale_(x|y)_continuous: когда данные оси интервальные scale_(x|y)_discrete: когда данные оси дискретные scale_(x|y)_date: даты Аргументы (и параметры) осей, которые можно задать: breaks: шаги деления оси labels: подписи для шагов name: название оси (аналогично слою labs()) limits: границы оси (аналогично слою lims()) trans: когда нужно трансформировать значения по оси. Варианты трансформаций: “asn”, “atanh”, “boxcox”, “exp”, “identity”, “log”, “log10”, “log1p”, “log2”, “logit”, “probability”, “probit”, “reciprocal”, “reverse”, “sqrt”. ggplot(imdb_woody, aes(x = year, y = avg_vote)) + geom_point() + scale_x_continuous(breaks = c(1970, 2000, 2010)) + scale_y_continuous(breaks = c(0, 7, 7.25, 7.5, 7.75, 8, 10)) В том случае, если в слое задано изменение цвета элементов графика в зависимости от вариативности какой-то переменной в датасете (это указывается в аргументах функции aes(), которая задает значения аргумента mapping функции геома), то по умолчанию используются оттенки синего, в диапазоне от черного к белому. Есть необходимость изменить цвета шкалы, то следует воспользоваться одной из соответствующих функций семейства scale_* -scale_(colour|fill)gradient(),scale(colour|fill)_brewer()` и проч. С помощью разных функций можно либо задать свою палитру, либо выбрать из уже сконструированных (BrBG, Accent т.д.), в том числе указать цвет средней точки градиента. Основные термины функций: colour|fill - colour применяется для графиков рассеяния, линий и прочих простых геометрических объектов. Функции с fill в названии применяются для барчартов и прочих объектов, для которых может быть вычислена площадь gradient - функции с gradient (scale_colour_gradient(), scale_fill_gradient2()) применяются для интервальных значений brewer - brewer- функции применяются для дискретных значений, в ggplot2 есть целый ряд уже созданных палитр, как дискретизированных градиентов (Blues, Greens), так и контрастных (BrBGб Set1) distiller - промежуточный вариант между brewer и gradient, который на основе данных интерполирует заданную дискретную палитру к интервальному виду. scale_color_gradient() ggplot(imdb_woody, aes(x = year, y = avg_vote)) + geom_point(aes(color = avg_vote), shape = &#39;circle&#39;, size = 4) + scale_color_gradient(low = &#39;steelblue4&#39;, high = &#39;steelblue1&#39;) scale_color_distiller() ggplot(imdb_woody, aes(x = year, y = avg_vote)) + geom_point(aes(color = avg_vote), shape = &#39;circle&#39;, size = 4) + scale_color_distiller(palette = &#39;Set1&#39;) scale_color_brewer() ggplot(imdb_woody, aes(x = year, y = avg_vote)) + geom_point(aes(color = genre), shape = &#39;circle&#39;, size = 4) + scale_color_brewer(palette = &#39;Set1&#39;) ## Warning in RColorBrewer::brewer.pal(n, pal): n too large, allowed maximum for palette Set1 is 9 ## Returning the palette you asked for with that many colors ## Warning: Removed 17 rows containing missing values (`geom_point()`). lims() Слой, который задается функцией lims(), позволяет явно ограничить график по осям. Для того, чтобы задать границы оси, надо в соответствующий аргумент передать вектор из двух значений, которые будут интерпертированы как максимальное и минимальное значения оси. ggplot(imdb_lynch, aes(x = year, y = avg_vote)) + geom_point() + lims(x = c(2000, 2010)) labs() Помимо границ оси, можно задать и названия осей, также как и название графика. Функция labs() (от labels) имеет несколько аргументов, которые и отвечают за тексты на соответствующих элементах графика. Так, title задает заголовок всего графика, аргументы x и y - названия осей. Прочие аргументы могут соответствовать параметрам геомов. Например, мы задаем цвет и размер точек в геоме geom_point(). Соответственно, названия легенд для этих параметров могут быть заданы в labs() в аргументах color и shape: ggplot(imdb_lynch, aes(x = year, y = avg_vote)) + geom_point(aes(colour = avg_vote, shape = country), size = 3) + scale_color_gradient(low = &#39;steelblue4&#39;, high = &#39;steelblue1&#39;) + labs(title = &#39;Рейтинги фильмов Дэвида Линча&#39;, x = &#39;&#39;, y = &#39;avg_vote&#39;, colour = &#39;imdb score&#39;, shape = &#39;country&#39;) Координатная плоскость Любой график немыслим без какой-то определенной системы координат. Стандартно и по умолчанию в ggplot2 используется декартова система координат. Тем не менее, доступна также и полярная система координат. Декартова система координат используется по умолчанию, однако ее можно и явно задать и явно: ggplot(imdb_genres, aes(x = genre, y = avg_vote)) + geom_boxplot(aes(color = genre)) + coord_cartesian() Несмотря на то, что, на первый взгляд, оси ОХ и ОY идентичны и взаимозаменяемы, это не так. Для достаточно большого количества типов графиков важна ориентация. Например, столбиковые диаграммы (барчарты) и боксплоты ориентированы вертикально и просто сменой осей переориентировать их горизонтально не получится. Для таких целей как раз используют отдельную функцию поворота координатной плоскости, coord_flip(): ggplot(imdb_genres, aes(x = genre, y = avg_vote)) + geom_boxplot(aes(color = genre)) + coord_flip() Фасеты Комбинация на одном графике данных по двум или нескольким градациям группирующей переменной позволяет сравнить несколько значений. Однако бывают ситуации, когда необходимо каким-то образом разделить и отдельно визуализировать данные по этим градациям - например, сравнить пробы по отдельным испытуемым, или показать графики значений и линии тренда в разные годы и тому подобное. Простое совмещение на одном графике всех данных может привести к потере читабельности - когда данных много и используются сложные комбинации слоев. В таких случаях, чтобы все нарисовать на одном графике, но раздельно, в своих блоках, используется функция facet_grid() или facet_wrap(). Функция facet_wrap() аналогична facet_grid(), только организует панели подграфиков в виде плитки, а facet_grid() - либо вертикально, либо горизонтально, либо плиткой (в случае, когда по оси OX задана одна группировка, а по оси OY - вторая). Основные аргументы функций фасет: facets: выражение вида x ~ y, когда x ~ . задает расположение панелей фасет горизонтально, по факторам переменной x, формула вида . ~ yзадает вертикальное положение фасет. Формула x ~ y используется в том случае, если данные группируются и отрисовываются по комбинациям значений факторов переменных и x, и y - в таком случае в результате получится график, с сеткой панелей-фасет субграфиков. margins: используется в тех случаях, когда надо дополнительно отрисовать панель с общим графиком по всем значениям группирующей переменной (т.е., без группировки), в качестве значения принимает название группирующей переменной scales: для ситуаций, когда необходимо закрепить (fixed) или, наоброт, задать собственный (free) масштаб шкалы для каждой панели Визуальные параметры всего графика После того, как основные содержательные и структурные элемента графика заданы, можно перейти к доводке визуального оформления. Совокупность визуальных параметров названий, линий, текстов и прочих элементов графиков, не относящихся собственно к данным, называется темой, theme. В ggplot2 есть ряд уже скомплектованных тем, и одна из них, оттенки серого, используется по умолчанию. Помимо использования уже готовы тем как из ggplot2, так и из пакетов расширений (например, ggthemes), можно самостоятельно менять оформление тех или иных элементов. Список готовых тем пакета ggplot2: theme_grey() theme_gray() theme_bw() theme_linedraw() theme_light() theme_dark() theme_minimal() theme_classic() theme_void() theme() Помимо использования уже готовы тем как из ggplot2, так и из пакетов расширений (например, ggthemes), можно самостоятельно менять оформление тех или иных элементов. Делается это с помощью функции theme(), которая вызывается после применения к объекту графика уже существующей темы. Функция theme() имеет огромное количество аргументов, все их названия построены по схеме родитель.ребенок, например, аргумент plot.background, который определяет параметры бэкграунда графика. Значения аргументов функции theme() задаются одной из четырех нижеследующих функций, в зависимости от формы объекта графика, которому надо придать какое-то оформление: element_blank(): используется в том случае, если объект не надо отрисовывать, например, надо убрать метки с оси element_rect(): задает параметры для границ и бэкграунда, как правило, цвет element_line(): задает параметры объектов-линий на графике (например, линия оси) element_text(): задает параметры объектов-текстов (например, тип или размер подписей к меткам оси) unit(): задает параметры для тех элементов, которым передаются какие-то размеры - размеры меток осей, расстояний между фасетами и проч. Можно задать различные измерения для этого параметра - дюймы, сантиметры и т.д. Также можно указать относительные размеры, в долях от размера всего графика (npc = Normalised Parent Coordinates, где точка (.5, .5) обозначает центр графика). Примеры аргументов и соответствующих элементов графика: plot.* plot.background: бэкграунд всего графика (element_rect) plot.title: название графика (element_text) plot.subtitle: подзаголовок графика (text appearance) (element_text) plot.caption: примечение под графиком (text appearance) (element_text) plot.margin: отступы вокруг графика legend.* legend.background: фон легенды (element_rect) legend.text: текст легенды (element_text) legend.title: заголовок легенды (element_text) legend.position: расположение легенды (“none”, “left”, “right”, “bottom”, “top”, or two-element numeric vector) strip.* strip.background: фон фасет (element_rect) strip.text: текст фасет (element_text) Пример кастомизации темы графика: ggplot(imdb_genres[country %in% c(&#39;USA&#39;, &#39;France&#39;, &#39;Italy&#39;, &#39;India&#39;, &#39;UK&#39;)], aes(x = genre, y = avg_vote)) + geom_boxplot(aes(color = genre)) + scale_x_discrete(labels = NULL, breaks = NULL) + facet_grid(. ~ country)+ labs(title = &#39;Пример theme()&#39;, caption = &#39;на основе theme_minimal()&#39;, x = NULL, y = &#39;imdb score&#39;) + theme_minimal() + # theme(legend.background = element_rect(color = &#39;grey80&#39;, fill = &#39;grey95&#39;), theme(legend.background = element_blank(), legend.position = &#39;top&#39;, legend.title = element_blank(), plot.title = element_text(face = &#39;bold&#39;, size = 18), plot.caption = element_text(colour = &#39;grey50&#39;, face = &#39;italic&#39;), panel.grid.major = element_line(colour = &#39;grey95&#39;), panel.grid.minor = element_line(colour = &#39;grey97&#39;), axis.title = element_text(face = &#39;italic&#39;)) "],["plotly.html", "plotly Запись занятия Пакеты и данные Компоненты графика plotly Типы графиков Группировка Визуальные параметры графиков Добавляемые слои Общие параметры графиков Совмещенные графики", " plotly Запись занятия Пакеты и данные library(ggplot2) library(plotly) library(data.table) imdb_link &lt;- &#39;https://gitlab.com/upravitelev/mar201s/raw/master/data/IMDb%20movies.csv&#39; tg_cols &lt;- c(&quot;director&quot;, &quot;title&quot;, &quot;original_title&quot;, &quot;year&quot;, &quot;genre&quot;, &quot;duration&quot;, &quot;country&quot;, &quot;avg_vote&quot;) imdb &lt;- fread(imdb_link, select = tg_cols) imdb[, year := as.numeric(year)] imdb_woody &lt;- imdb[director == &#39;Woody Allen&#39;] imdb_martin &lt;- imdb[director == &#39;Martin Scorsese&#39;] imdb_lynch &lt;- imdb[director == &#39;David Lynch&#39;] imdb_genres &lt;- imdb[genre %in% c(&#39;Horror&#39;, &#39;Comedy&#39;, &#39;Drama&#39;)] imdb_genres_scores &lt;- imdb_genres[, list(n_titles = .N, votes = mean(avg_vote)), by = list(year, genre)] Компоненты графика plotly Данные и оси Базовая функция для создания интерактивных графиков - plot_ly(). Для создания самого простого графика уже достаточно будет указать датасет, оси и тип графика. Оси задаются указанием названий колонок датасета, через оператор формулы (тильда, ~). Вообще, такая форма используется во всех местах, где идет обращение к колонкам датасета (ховеры, цвета и группировки и проч). В ggplot2 в какой-то мере аналогом такого обращения к колонкам датасета будет функция aes(). plot_ly(economics, x = ~date, y = ~uempmed, name = &quot;unemployment&quot;, marker = list(color=&quot;#264E86&quot;), type = &quot;scatter&quot;, mode = &quot;markers&quot;) Типы графиков В plotly реализованы базовые графики, в частности, линии, гистограммы и барчарты, боксплоты, тепловые карты, геокарты, а так же некоторые 3d-графики. Создавать собственные типы графиков средствами plotly, к сожалению, нельзя. Полный список графиков, реализованных в plotly, можно посмотреть на сайте библиотеки или же на странице документации. Точечный и линейный графики Тип графиков задается аргументом type функции plot_ly(). Для некоторых графиков, в частности, для диаграмм рассеяния (точек) и линий используется один type, но с разными значениям доп.аргумента mode. Например, с помощью type = 'scatter' и mode = 'markers' задается точечный график. Для того, чтобы был правильный порядок точек и линий, необходимо отсортировать таблицу (в противном случае может получиться клубок линий). # отсортируем и построим точечный график imdb_genres_scores &lt;- imdb_genres_scores[order(year, genre)] plot_ly(imdb_genres_scores[genre == &#39;Horror&#39;], x = ~year, y = ~votes, type = &#39;scatter&#39;, mode = &#39;markers&#39;) Линейный график задается с помощью type = 'scatter' и mode = 'lines': # построим линейный график plot_ly(imdb_genres_scores[genre == &#39;Horror&#39;], x = ~year, y = ~votes, type = &#39;scatter&#39;, mode = &#39;lines&#39;) Столбиковые диаграммы Для отрисовки столбиковых диаграмм используется параметр type = 'bar'. Естественно, данные должны быть соответствующей структуры. Например, посчитаем количество фильмов каждого жанра в год и отрисуем столбиками (датасет подготовили ранее): plot_ly(imdb_genres_scores[year &gt; 2010 &amp; genre == &#39;Drama&#39;], x = ~year, y = ~n_titles, type = &#39;bar&#39;) Боксплоты Поведение точно такое же, как для типа type = 'bar' - по оси y выставляем переменную, по которой хотим увидеть боксплот, а в типе пишем type = 'box': plot_ly(imdb_genres_scores, x = ~genre, y = ~votes, type = &#39;box&#39;) Группировка plotly очень дружелюбен к пользователю в тех задачах, когда есть данные в long-формате и нужно на одном графике отразить данные разных групп. Сложным решением тут была бы отрисовка графиков в цикле, однако можно просто воспользоваться аргументом color функции plot_ly(). Допустим, мы хотим отрисовать количество фильмов в год с разбивкой по жанрам. Для этого в параметр цвета передается название группирующей колонки: # считаем фильмы по режиссерам и странам plot_ly(imdb_genres_scores, x = ~year, y = ~n_titles, type = &#39;bar&#39;, color = ~genre) В том случае, когда хочется нарисовать группы не отдельными столбиками, а стопкой, то надо указать аргумент barmode = 'stack' в отдельном слое layout() (о нем ниже, он используется для управления параметрами всего графика) plot_ly(imdb_genres_scores, x = ~year, y = ~n_titles, type = &#39;bar&#39;, color = ~genre) %&gt;% layout(barmode = &#39;stack&#39;) Визуальные параметры графиков Легенда Название элементов графика задается параметром name в графике. В него можно как передать какое-то значение, так и колонку, которая задает названия. Когда одна линия, то легенда не формируется. plot_ly(imdb_woody, x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;markers+lines&#39;, name = &#39;markers+lines&#39;) Легенду можно скрыть параметром showlegend=FALSE: plot_ly(imdb_woody, x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;markers+lines&#39;, name = &#39;markers+lines&#39;, showlegend = FALSE) Параметры линий и точек Линии и точки на графиках можно изменять на свой вкус - менять типы линий, размеры элементов, цвет. Параметры элементов задают через значения аргументов marker (для точек) или line для линий. plot_ly( data = imdb_woody, x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;markers&#39;, color = ~country, marker = list( size = ~duration / 10, symbol = &#39;diamond&#39; ) ) Линии задаются также аргументом, в который надо передавать спиcок параметров, обычно это размер, тип линии или ее форма. Типы линий, которые доступны в plotly: “solid”, “dot”, “dash”, “longdash”, “dashdot”: plot_ly( data = imdb_woody, x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;lines&#39;, color = ~country, line = list( color = &#39;steelblue&#39;, size = 3, dash = &#39;dash&#39; ) ) Ховеры Ховеры, в общем виде, это разного рода эффекты (всплывающие подписи, подсказки, плавные переходы, трансформация, ротация, увеличение, смещение и пр.), которые наблюдаются при наведении на них курсора мыши. В plotly ховеры - это всплывающие подписи, которые содержат информацию о координатах (по умолчанию). При желании, можно изменить содержание ховеров. Для этого необходимо создать отдельную колонку, в которой в виде строки будут записаны все необходимые параметры, которые хочется показывать в ховере. При этом для кастомизации записи можно использовать html-теги, хотя бы тег &lt;br&gt; для разделения значений по строчкам. # создадим колонку с информацией о годе, оценке, названии и жанре фильма imdb_lynch[, my_hover := paste( &#39;year =&#39;, year, &#39;&lt;br&gt;&#39;, &#39;imdb score =&#39;, avg_vote, &#39;&lt;br&gt;&#39;, &#39;title = &#39;, original_title, &#39;&lt;br&gt;&#39;, &#39;genres =&#39;, genre)] # смотрим результат imdb_lynch[1:3, my_hover] ## [1] &quot;year = 1977 &lt;br&gt; imdb score = 7.4 &lt;br&gt; title = Eraserhead &lt;br&gt; genres = Fantasy, Horror&quot; ## [2] &quot;year = 1980 &lt;br&gt; imdb score = 8.1 &lt;br&gt; title = The Elephant Man &lt;br&gt; genres = Biography, Drama&quot; ## [3] &quot;year = 1984 &lt;br&gt; imdb score = 6.5 &lt;br&gt; title = Dune &lt;br&gt; genres = Action, Adventure, Sci-Fi&quot; Указываем созданную переменную для использования в качестве ховера: plot_ly(imdb_lynch, x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;markers&#39;, text = ~my_hover, hoverinfo = &#39;text&#39;) imdb_lynch[, my_hover := NULL] Добавляемые слои Наследование параметров plotly в немалой части следует идеологии grammar of graphics, которая реализована в ggplot2. В частности, идее слоев и сочетания разных данных и типов графиков на одном пространстве координат. Конечно, очень разные по типу графики совместить сложно или невозможно, но совмещение линий, точек и баров, линий и боксплотов, и т.д. встречается очень часто. В частности, наложение графиков используется в ситуациях, когда данные необходимо отрисовать из разных колонок. Так, в данных по занятости населения США по строкам расположены года наблюдений, а в отдельных колонка - количество населения (pop) и количестве безработных (unemployed). Можно трансформировать датасет и перевести его в long-формат, однако проще добавить к графику еще один слой (след, trace, в терминологии plotly). Для каждого трейса можно задать свое название: plot_ly(imdb_genres_scores[genre == &#39;Horror&#39;], x = ~year, y = ~votes, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% add_trace(data = imdb_genres_scores[genre == &#39;Drama&#39;], x = ~year, y = ~votes, type = &#39;scatter&#39;, mode = &#39;lines&#39;) Так же как и в ggplot2 при наложении слоев возможно наследование параметров. Например, в графике выше можно оставить только те параметры, которые определяют именно этот слой (значение по оси OY и название линии): plot_ly(imdb_genres_scores[genre == &#39;Horror&#39;], x = ~year, y = ~votes, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% add_trace(data = imdb_genres_scores[genre == &#39;Drama&#39;]) Общие параметры графиков Отдельный слой на графиках plotly - это слой общих параметров графика, таких как заголовок, тип группировки баров или боксплотов, параметры осей (заголовки, диапазоны, шрифты и проч), а так же отступы от краев графика. Все параметры задаются с помощью базовой функции layout(), которая первым аргументом принимает plotly-объект, а все прочие аргументы формируют параметры объекта. Рассмотрим параметры заголовка и осей, параметры легенд и группировки баров и боксплотов описаны в соответствующих разделах. Заголовок Заголовок на графиках формируется очень просто, с помощью аргумента title и, собственно, строки, которая должна быть заголовком графика. plot_ly(rbind(imdb_woody, imdb_lynch), x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;markers&#39;, color = ~director) %&gt;% layout(title = &#39;Woody + David&#39;) Также, как и c некоторыми другими текстовыми метками на графиках plotly (ховеры, подписи осей, лейблы), в строке заголовка можно использовать html-теги: plot_ly(rbind(imdb_woody, imdb_lynch), x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;markers&#39;, color = ~director) %&gt;% layout(title = &#39;Woody + David&lt;br&gt;используем тэг&#39;) Параметры осей Из параметров осей самые важные - это название оси (особенно важно при отрисовке совмещенных графиков), а так же диапазоны, которые должны быть отражены. Особенно это важно для оси OY, так как по умолчанию на линейных графиках ось начинается на с нуля, а с минимального значения, что несколько противоречит общепринятым нормам в визуализации данных. Параметры осей также задаются списками параметров. Название оси задается через параметр title, а диапазоны можно указать либо вектором с границами диапазона и параметром range. Параметр rangemode со значением tozero указывает что ось необходимо строить от нуля (можно также указать nonnegative, все неотрицательные). plot_ly(rbind(imdb_woody, imdb_lynch), x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;markers&#39;, color = ~director) %&gt;% layout(title = &#39;Woody + David&#39;, xaxis = list(title = &#39;&#39;), yaxis = list(rangemode = &#39;tozero&#39;)) В параметрах осей также можно задавать параметры названия оси, меток (шрифт, наклон, количество и шаг меток), цвет и ширину линий осей и координатной сетки, а так же отдельные параметры для определенных типов графиков. Все это достаточно редкие в использовании кейсы, и все следуют общей логике - параметры элемента задаются списком параметров, некоторые из которых имеют ограниченный набор значений. Подробнее в документации по функции layout(). Совмещенные графики Одна из самых частых задач, котрые возникают при работе с plotly, это совмещение нескольких графиков на одном общем графике. В ggplot2 это аналог фасет. Для совмещения графиков используется функция subplot(), в которую первыми аргументами передаются plot_ly-объекты (графики). Для указания, вертикально или горизонтально компоновать графики, аргумент nrows. По умолчанию он равен единице, то есть графики компонуются в ряд по горизонтали, противном же случае идет компоновка по вертикали. Если же графиков больше, чем заданных строк, то сначала графики компонуются построчно так, чтобы на последней указанной строке был хотя бы один график. Также в функции subplot() есть еще ряд аргументов, которые задают соотношение графиков между собой - каково должно быть расстояние, будут ли объеденены подписи осей и т.д. На практике, впрочем, эти параметры используются нечасто. Пример совмещения графиков - показываем информацию по двум режиссерам на двух отдельных графиках, а не на одном. Параметр nrows задает, в сколько строк должны быть организованы графики, если параметр не указан, то графики компонуются вертикально, на одной линии: subplot( plot_ly(imdb_woody, x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;lines&#39;), plot_ly(imdb_lynch, x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;lines&#39;), nrows = 2) Задать название графика, названия и параметры осей можно также с помощью функции layout(), которая определяет параметры всего графика. Как и в прочих наших графиках, зададим название и укажем, что оси OY начинаются от нуля. Так как на графике несколько осей OX и OY, для их определения используется численный индекс, yaxis (или yaxis1), yaxis2, yaxis3 и т.д., по порядку вызова объектов в subplot(). subplot( plot_ly(imdb_woody, x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;lines&#39;), plot_ly(imdb_lynch, x = ~year, y = ~avg_vote, type = &#39;scatter&#39;, mode = &#39;lines&#39;), nrows = 2) %&gt;% layout(title = &#39;Woody + Lynch&#39;, xaxis = list(title = &#39;&#39;), showlegend = FALSE, yaxis = list(title = &#39;Woody Allen&#39;, rangemode = &#39;tozero&#39;), yaxis2 = list(title = &#39;David Lynch&#39;, rangemode = &#39;tozero&#39;)) "],["web-скрапинг.html", "Web-скрапинг Запись занятия HTML интро rvest Навигация по дереву тегов Циклы Неявные циклы, семейство *pply Скрапинг сайта журнала Получение списка ссылок с страницы рубрики Дополнительные материалы Домашнее задание level 1 (IATYTD) level 2 (HNTR) level 3 (HMP) level 4 (UV) level 5 (N)", " Web-скрапинг Запись занятия HTML интро Web-сервер При попытке открыть каrую-нибудь html-страницу (сайт) происходит запрос к web-серверу, на котором размещена эта страница. Если не возникает ошибок, то сервер возвращает сообщение с кодом страницы (html + javascript). Соответственно, когда браузер получает сообщение, он обрабатывает и выполняет код, “отрисовывает страницу” для пользователя. Инструменты скрапинга (rvest, в частности), аналогично запрашивают web-сервер, однако результат не отрисовывают, а хранят в виде объекта в памяти. Структура html-страницы Все страницы сайтов - это текст, форматированный с помощью языка разметки html. Это значит, что все элементы страницы - тексты, картинки, гиперссылки, заголовки и проч. имеют свою метку, иначе говоря, тэг. Тэги - ключевые слова, обернутые в угловые скобки &lt;tag_name&gt;. Тэги всегда представлены в паре открывающий (&lt;tag_name&gt;) и закрывающий тэги (&lt;/tag_name&gt;). Между ними как раз и размещается материал страницы - текст, картинка и проч. Стандартная html-страница имеет вид иерархического дерева тэгов, где корневой тэг - html. Ниже дан простейший пример кода страницы,в которой есть заголовок и список. Список формируется из общего тэга &lt;ol&gt;&lt;/ol&gt; (ordered list) и элементов списка внутри тэга, каждый в собственной парке тэгов &lt;li&gt;&lt;/li&gt;. У тэгов есть атрибуты - как правило, это либо дополнительная информация (адрес гиперссылки, адрес картинки), либо класс, который используется в таблицах стилей, чтобы к разным тегам применять разные визуальные эффекты (о таблице стилей ниже). Например, чтобы текст во всех тэгах с классом my_class был синего, а с классом my_class2 - зеленым. Атрибуты тэгов пишутся сразу после названия открывающего тэга, в угловых скобках: &lt;div class=\"my_class1\"&gt;&lt;/div&gt;. Пример кода страницы: &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./data/my_css.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Правда о лосях&lt;/h2&gt; &lt;ol&gt; &lt;li style=&#39;color:red&#39;&gt;Лось — животное хитрое&lt;/li&gt; &lt;li class=&#39;my_class&#39;&gt;...и коварное!&lt;/li&gt; &lt;li class=&#39;my_class2&#39;&gt;а вот &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D1%81%D0%B8&quot;&gt;ссылка&lt;/a&gt; на страницу в вики&lt;/li&gt; &lt;/ol&gt; &lt;h2&gt;Второй заголовок уровня h2&lt;/h2&gt; &lt;p class=&#39;my_class&#39;&gt; Ло́с] (лат. Alces) — род парнокопытных млекопитающих, самые крупные представители семейства оленевх]. Включает 2 вида: европейский лось (лат. Alces alces) и американский лось (лат. Alces americanus), которые имеют разное число хромосом (68 и 70, соответственно)&lt;/p&gt; &lt;h2&gt;а это просто пример таблицы&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;cell&lt;/th&gt; &lt;th&gt;colour&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1st&lt;/td&gt; &lt;td&gt;white&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2nd&lt;/td&gt;&lt;td&gt;red&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;3rd&lt;/td&gt;&lt;td&gt;black&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;4th&lt;/td&gt;&lt;td class=&quot;my_class2&quot;&gt;green&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; Вот так выглядит эта страница в том виде, как ее присылает веб-сервер: &lt;pre&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./data/my_css.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Правда о лосях&lt;/h2&gt;&lt;ol&gt;&lt;li style=&#39;color:red&#39;&gt;Лось — животное хитрое&lt;/li&gt;&lt;li class=&#39;my_class&#39;&gt;...и коварное!&lt;/li&gt;&lt;li class=&#39;my_class2&#39;&gt;а вот &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D1%81%D0%B8&quot;&gt;ссылка&lt;/a&gt; на страницу в вики&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;Второй заголовок уровня h2&lt;/h2&gt;&lt;p class=&#39;my_class&#39;&gt;Ло́с] (лат. Alces) — род парнокопытных млекопитающих, самые крупные представители семейства оленевх]. Включает 2 вида: европейский лось (лат. Alces alces) и американский лось (лат. Alces americanus), которые имеют разное число хромосом (68 и 70, соответственно)&lt;/p&gt;&lt;h2&gt;а это просто пример таблицы&lt;/h2&gt;&lt;table&gt;&lt;tr&gt;&lt;th&gt;cell&lt;/th&gt;&lt;th&gt;colour&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1st&lt;/td&gt;&lt;td&gt;white&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2nd&lt;/td&gt;&lt;td&gt;red&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3rd&lt;/td&gt;&lt;td&gt;black&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4th&lt;/td&gt;&lt;td class=&quot;my_class2&quot;&gt;green&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&lt;/pre&gt; Вот так выглядит эта страница в браузере: Правда о лосяхЛось — животное хитрое...и коварное!а вот ссылка на страницу в викиВторой заголовок уровня h2Ло́с] (лат. Alces) — род парнокопытных млекопитающих, самые крупные представители семейства оленевх]. Включает 2 вида: европейский лось (лат. Alces alces) и американский лось (лат. Alces americanus), которые имеют разное число хромосом (68 и 70, соответственно)а это просто пример таблицыcellcolour1stwhite2ndred3rdblack4thgreen css Если посмотреть внимательно, то в разделе есть подключение css-файла. Это так называемый файл стилей, который позволяет задавать визуальные параметры содержимого тэга не в инлайн-атрибутах (например, style='color:red'), а отдельно. И, соответственно, применять эти стили в самым разным тэгам, при необходимости. В примере выше заголовки все желтого цвета, а параграф и элемент упорядоченного списка с class=\"my_class\" – синего. Заголовок h2 закомментирован, чтобы не покрасить выбранным цветом все h2-заголовки на странице (в том числе и заголовки конспекта). Содержимое файла my_css.css: .my_class { color: blue; font-size: 20; } .my_class2 { color: green; } rvest Общая последовательность Последовательность действий при скрапинге данных с помощью rvest такова: с помощью функции read_html() в рабочее окружение импортируется заданая страница (web-адрес) или XML-документ визуально по структуре или визуально в средствах web-разработчика (в частности, SelectorGadget и нативные инструменты браузеров для web-разрботчиков), а так же функциями html_children(), html_attrs() анализируется структура дерева элементов документа (тэгов и атрибутов) с помощью функций html_element() и html_elements() указывается, какой элемент (элементы) структуры необходимо выбрать из выбранного элемента с помощью функций html_text(), html_table и html_attr() извлекаются значения при необходмости во время сбора данных с html-страниц процесс масштабируется на прочие схожие разделы сайта или осуществляется в регулярном формате (краулинг) импорт страницы Установка и подключение пакета стандартные. На *nix/MacOS-системах могут потребоваться дополнительные библиотеки. Для импорта таблицы требуется read_html(), при импорте может быть необходимо указать кодировку. library(data.table) # install.packages(&#39;rvest&#39;) library(rvest) # импорт страницы url &lt;- read_html(&#39;./data/tmp.html&#39;, encoding = &#39;UTF-8&#39;) Выбор узлов и их значений Для того, чтобы извлечь значение из какого-то тэга, необходимо указать путь к этому тэгу в дереве тэгов страницы. Выбор тэгов осуществляется с помощью функции html_element(), где первым аргументом указывают импортированную страницу, а в аргументе xpath - путь к тэгу на языке XPath. В тэгах может быть разная информация - текст или таблица, в некоторых случаях важно не содержание тэга, а его атрибут. После того, как выделяется из дерева тэг, необходимо извлечь его содержание. Это делается с помощью функций: html_text() если в тэге хранится текстовое значение. По сути, используется всегда, когда в тэге не табличка и не картинка. # извлекаем текстовое значение - заголовок html_element(url, xpath = &#39;//h2&#39;) %&gt;% html_text() ## [1] &quot;Правда о лосях&quot; - html_table() если в тэге хранится таблица (&lt;table&gt;). # извлекаем таблицу html_element(url, xpath = &#39;//table&#39;) %&gt;% html_table() ## # A tibble: 4 × 2 ## cell colour ## &lt;chr&gt; &lt;chr&gt; ## 1 1st white ## 2 2nd red ## 3 3rd black ## 4 4th green - html_attr('attr_name') - используется для случаев, когда надо извлечь атрибут тэга. Атрибуты тэга можно узнать, применив к выделенному с помощью html_element() тэгу функцию html_attrs(). # смотрим атрибуты тэга &lt;a&gt; html_element(url, xpath = &#39;//a&#39;) %&gt;% html_attrs() ## href ## &quot;https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D1%81%D0%B8&quot; # извлекаем значение атрибута href html_element(url, xpath = &#39;//a&#39;) %&gt;% html_attr(&#39;href&#39;) ## [1] &quot;https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D1%81%D0%B8&quot; # извлекаем не атрибут, а значение тэга, # то есть, каким текстом видит эту ссылку пользователь html_element(url, xpath = &#39;//a&#39;) %&gt;% html_text() ## [1] &quot;ссылка&quot; Навигация по дереву тегов Ключевые элементы языка XPath: %tag_name%: название тэга %tag_name% /: Иcпользуется для указания прямого пути к элементу от корневого/родительского тега. Если весь xpath-путь начинается с /, то это абсолютный путь от корня дерева. Вот так можно выбрать тэг (ноду, узел) заголовка страницы. # длинный путь, от корня через все поколения родителей к тэгу h2 html_element(url, xpath = &#39;/html/body/h2&#39;) %&gt;% html_text() ## [1] &quot;Правда о лосях&quot; //: Выбирает теги независимо от места их расположения, при этом может использоваться как в начале пути, так и в середине: # короткий путь, &quot;пропусти все до первого тэга h2&quot; html_element(url, xpath = &#39;//h2&#39;) %&gt;% html_text() ## [1] &quot;Правда о лосях&quot; @: выбор атрибута узла. Если необходимо использовать атрибут тэга в пути, то атрибут указывается как @attr_name. Если указать путь к атрибуту тэга с использованием @, то можно не использовать функцию html_attr(), а обойтись общей html_text(): html_element(url, xpath = &#39;//a/@href&#39;) %&gt;% html_text() ## [1] &quot;https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D1%81%D0%B8&quot; [x]: фильтрация тэга с помощью номера места в списке тэгов-сиблингов (на одном уровне в иерархии) или по наличию какого-либо атрибута. В целом, очень похоже на фильтрацию таблиц по номеру строки или логическому условию. ### выбираем по номеру тэга в списке # первый заголовок h2 html_element(url, xpath = &#39;//h2[1]&#39;) %&gt;% html_text() ## [1] &quot;Правда о лосях&quot; # третий заголовок h3 html_element(url, xpath = &#39;//h2[3]&#39;) %&gt;% html_text() ## [1] &quot;а это просто пример таблицы&quot; ### выбираем по содержанию определенного атрибута # выбираем значение тэга &lt;p&gt;, у которого есть атрибут класса class=&quot;my_class&quot; html_element(url, xpath = &#39;//p[@class=&quot;my_class&quot;]&#39;) %&gt;% html_text() ## [1] &quot;\\n Ло́с] (лат. Alces) — род парнокопытных млекопитающих, самые крупные представители семейства оленевх]. Включает 2 вида: европейский лось (лат. Alces alces) и американский лось (лат. Alces americanus), которые имеют разное число хромосом (68 и 70, соответственно)&quot; # выбираем значение тэга &lt;p&gt;, у которого есть атрибут класса class=&quot;my_class&quot; # и используем html_text2(), чтобы убрать нечитаемые символы html_element(url, xpath = &#39;//p[@class=&quot;my_class&quot;]&#39;) %&gt;% html_text2() ## [1] &quot;Ло́с] (лат. Alces) — род парнокопытных млекопитающих, самые крупные представители семейства оленевх]. Включает 2 вида: европейский лось (лат. Alces alces) и американский лось (лат. Alces americanus), которые имеют разное число хромосом (68 и 70, соответственно)&quot; *: знак подстановки, “на этом месте может быть что угодно” - используется, когда надо пропустить какой-то длинный кусок дерева тэгов, или точно неизвестно, какой тэг или атрибут используется: # не знаем тэг, знаем атрибут класс, вместо тэга пишем * html_element(url, xpath = &#39;//*[@class=&quot;my_class&quot;]&#39;) %&gt;% html_text() ## [1] &quot;...и коварное!&quot; # знаем тэг, но не знаем, какой атрибут со значением &quot;my_class&quot; html_element(url, xpath = &#39;//p[@*=&quot;my_class&quot;]&#39;) %&gt;% html_text() ## [1] &quot;\\n Ло́с] (лат. Alces) — род парнокопытных млекопитающих, самые крупные представители семейства оленевх]. Включает 2 вида: европейский лось (лат. Alces alces) и американский лось (лат. Alces americanus), которые имеют разное число хромосом (68 и 70, соответственно)&quot; Циклы Наряду с условными операторами, циклы в R аналогичны циклы в других языках программирования. Три основных вида циклов - for, while и repeat. Циклы задаются с помощью оператора цикла, последовательности или условия, ограничивающих работу цикла и, собственно, выполняемого выражения. Если это одна строка, то выражение можно не заключать в фигурные скобки, во всех прочих случаях фигурные скобки необходимы. Циклы традиционно редко используются в R, в немалой части это вызвано спецификой использования памяти во время выполнения выражений в цикле, точнее, не очень эффективным кодом. Для циклов существуют альтернативы - векторизованные вычисления и неявные циклы, а так же, собственно оптимизация кода путем преаллокации памяти или параллелизации. for Цикл for, который используется чаще прочих, использует заданную последовательность, по которой и итерируется. Последовательностью может быть как численный ряд, так и строковый вектор, например, названий файлов при импорте и обработке большого количества файлов в одном цикле. После выполнения цикла используемый итератор имеет значение последнего элемента цикла. В том же случае, если последовательность нулевой длины, то цикл не отрабатывает. for (i in letters[1:3]) { cat(&#39;letter&#39;, i, &#39;\\n&#39;) } ## letter a ## letter b ## letter c cat(&#39;i =&#39;, i) ## i = c while (Advanced) Циклы while и repeat используются намного реже. Если в цикле for количество циклов определяется длиной заданной последовательности, то в while количество циклов может быть бесконечным, до тех пор, пока поставленное условие будет верным. Для цикла надо задать начальное значение счетчика циклов, задать условие для этого счетчика и не забыть дополнить тело цикла увеличением счетчика при каждой итерации. Либо же добавить любое другое изменение значения счетчика, которое может привести срабатыванию условия. Второй вариант цикла while - это сначала создать объект с логическим значением TRUE и его поставить у условие, а потом прописать в теле цикла, что при определенных условиях значение сменится на FALSE, что и приведет к остановке цикла. Выведем первые три элемента вектора letters с помощью цикла while. i &lt;- 1 while (i &lt; 4) { my_l &lt;- letters[i] cat(&#39;letter&#39;, my_l, &#39;\\n&#39;) i &lt;- i + 1 } ## letter a ## letter b ## letter c cat(&#39;i =&#39;, i) ## i = 4 Как правило, while нужен тогда, когда надо подсчитать количество попыток до какого-то результата, либо же неизвестно, сколько попыток модет потребоваться. Самый показательный пример - сбор данных с POST-запросом, когда сервер может не отвечать, соединение может рваться, и так далее. repeat (Advanced) Цикл repeat схож с циклом while, только он выполняется до тех пор, пока пока при выполнении выражения не будет достигнут желаемый результат и не будет вызвана команда прерывания цикла. На том же примере с буквами: i &lt;- 1 repeat { my_l &lt;- letters[i] if (i == 4) { break() } else { cat(&#39;letter&#39;, my_l, &#39;\\n&#39;) i &lt;- i + 1 } } ## letter a ## letter b ## letter c cat(&#39;i =&#39;, i) ## i = 4 Прерывание циклов (Advanced) В какие-то моменты возникает необходимость прервать цикл или же пропустить последующеи действия и начать новую итерацию цикла. Для этих целей используют функции break() и next(). Выше в цикле repeat мы уже использовали break(), вот еще один пример цикла с прерыванием: for (i in letters[1:10]) { cat(i, &#39;\\n&#39;) if (i == &#39;c&#39;) break() } ## a ## b ## c Эффективнее всего функции прерывания в вложенных циклах - если прервать выполнение вложенного цикла, то родительский цикл не будет прерван и продолжит итерироваться. Неявные циклы, семейство *pply Циклами в их привычном большинству программистов виде в R пользуются не очень часто. Как правило, это ситуации, когда неизвестно количество возможных циклов или, наоборот, их ничтожное количество (несколько названий файлов). В большинстве же случаев пользуются так называемыми неявными циклами — функциями семейства *pply. Самая распространённая и покрывающая большинство задач функция семейства — это lapply(). Первый аргумент функции — набор элементов, над которыми должно быть произведено какое-то действие. Буква l в названии маркирует, что функция обычно применяется к спискам (l = list), однако на практике используются и векторы, и списки и т. д. Фактически первый аргумент в функции lapply() схож с итератором в цикле for. Второй аргумент — это собственно функция, которая должна быть применена к элементам вектора/списка из первого аргумента. В качестве результата работы функция lapply() возвращает список, где каждый элемент — результат применения указанной во втором аргументе функции к каждому элементу первого аргумента. В этом заключается одно из отличий от классических циклов, в которых тело цикла всего лишь повторяется определённое количество раз. То есть в классических циклах, в отличие от lapply(), нет возможности создать объект с результатами цикла, и надо изменять созданный за пределами цикла объект. res &lt;- lapply(1:5, sqrt) str(res) ## List of 5 ## $ : num 1 ## $ : num 1.41 ## $ : num 1.73 ## $ : num 2 ## $ : num 2.24 unlist(res) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 Если же у функции, используемой в lapply(), есть дополнительные аргументы, то они идут последующими аргументами, так как в списке аргументов lapply() заданы ..., дополнительные аргументы. # создадим список из векторов my_list &lt;- list(el1 = c(1, 2, 3, 4), el2 = c(1, 2, NA, 4)) # вычислим среднее и укажем, что NA надо пропускать lapply(my_list, mean, na.rm = TRUE) ## $el1 ## [1] 2.5 ## ## $el2 ## [1] 2.333333 Несмотря на определённую гибкость и возможность указывать аргументы функции, чаще всего в lapply() используются анонимные функции, в которые в качестве аргумента при выполнении передаётся значения объекта, переданного в первый аргумент (по которому осуществляется итерирование). res &lt;- lapply(1:5, function(x) { z &lt;- x * 2 z &lt;- sqrt(z) z }) str(res) ## List of 5 ## $ : num 1.41 ## $ : num 2 ## $ : num 2.45 ## $ : num 2.83 ## $ : num 3.16 unlist(res) ## [1] 1.414214 2.000000 2.449490 2.828427 3.162278 Семейство *pply-функций достаточно велико, вот наиболее часто используемые функции (тут я ориентируюсь на список С. Мастицкого): lapply(): l в названии означает list, список. Используется в случаях, когда необходимо применить какую-либо функцию к каждому элементу списка и получить результат также в виде списка. На деле обычно служит более удобным аналогом цикла for. sapply(): s в названии означает simplify, упрощение. Работает как lapply(), только в результате отдаёт именованный вектор. apply(): используется в случаях, когда необходимо применить какую-либо функцию ко всем строкам или столбцам матрицы (или массивов большей размерности). vapply(): v в названии означает velocity, скорость. Аналогична lapply() и sapply(), однако в качестве ещё одного аргумента требует указать тип данных, которые должны быть получены в результате. Это несколько ускоряет работу функции, что и привело к такому названию. mapply(): m в названии означает multivariate, многомерный. Используется в случаях, когда необходимо поэлементно применить какую-либо функцию одновременно к нескольким объектам (например, получить сумму первых элементов векторов, затему сумму вторых элементов векторов и т. д.). rapply(): r в названии означает recursively, рекурсивно. Используется в случаях, когда необходимо применить какую-либо функцию к компонентам вложенного списка. В настоящее время желательно использовать аналоги *pply-функций базового пакета из пакет purrr. Они чуть удобнее и чуть требовательнее к данным. Этот материал за пределами курса, но освоить рекомендую. Некоторые пакеты имеют свои реализации неявных циклов, например, parallel::mcmapply(), которая часто используется для параллелизации кода. Скрапинг сайта журнала Получение информации о статье и авторе Анализируем дерево тэгов на странице статьи, и указываем xpath-пути для получения той или иной информации. Сразу все оборачиваем в табличный вид. page_url &lt;- &#39;https://ecsoc.hse.ru/2023-24-5/876469050.html&#39; page &lt;- read_html(page_url) article_info &lt;- data.table( url = page_url, autor = html_element(page, xpath = &#39;//h3/i&#39;) %&gt;% html_text(), title = html_element(page, xpath = &#39;//h2[@class=&quot;article-header&quot;]&#39;) %&gt;% html_text(), annotation = html_element(page, xpath = &#39;//div[@class=&quot;annot&quot;]&#39;) %&gt;% html_text2(), keywords = html_element(page, xpath = &#39;//div[@class=&quot;keywords&quot;]&#39;) %&gt;% html_text2(), doi = html_element(page, xpath = &#39;//div[@class=&quot;keywords&quot;][2]&#39;) %&gt;% html_text2(), volume = html_element(page, xpath = &#39;//div[@class=&quot;centercolumn&quot;]/div&#39;) %&gt;% html_text2() ) Получение списка ссылок с страницы рубрики Мы видим, что на странице статьей рубрики дано до 10 ссылок на статьи, всего таких страниц более 15. Внимательный анализ DOM-дерева тэгов позволяет нам считать, что все ссылки находятся в интервале 3-12 div-тэги. # страница рубрики rubric_url &lt;- &#39;https://ecsoc.hse.ru/rubric/26590246.html&#39; rubric_page &lt;- read_html(rubric_url) # первая статья на странице html_element(rubric_page, xpath = &#39;//div[@class=&quot;centercolumn&quot;]/div[3]/small/a[2]&#39;) %&gt;% html_attr(&#39;href&#39;) ## [1] &quot;https://ecsoc.hse.ru/2023-24-5/876469050.html&quot; # последняя статья на странице html_element(rubric_page, xpath = &#39;//div[@class=&quot;centercolumn&quot;]/div[12]/small/a[2]&#39;) %&gt;% html_attr(&#39;href&#39;) ## [1] &quot;https://ecsoc.hse.ru/2022-23-3/638089235.html&quot; Пишем короткий цикл, чтобы получить ссылки: # for-цикл, работа в глобальном окружении page_urls &lt;- NULL for (i in 3:12) { art_xpath &lt;- paste(&#39;//div[@class=&quot;centercolumn&quot;]/div[&#39;, i, &#39;]/small/a[2]&#39;, sep = &#39;&#39;) tmp_page_url &lt;- html_element(rubric_page, xpath = art_xpath) %&gt;% html_attr(&#39;href&#39;) page_urls &lt;- c(page_urls, tmp_page_url) } print(page_urls[1:3]) ## [1] &quot;https://ecsoc.hse.ru/2023-24-5/876469050.html&quot; ## [2] &quot;https://ecsoc.hse.ru/2023-24-4/861891244.html&quot; ## [3] &quot;https://ecsoc.hse.ru/2023-24-4/861891738.html&quot; # lapply-цикл res &lt;- lapply(3:12, function(x) { art_xpath &lt;- paste(&#39;//div[@class=&quot;centercolumn&quot;]/div[&#39;, x, &#39;]/small/a[2]&#39;, sep = &#39;&#39;) tmp_page_url &lt;- html_element(rubric_page, xpath = art_xpath) %&gt;% html_attr(&#39;href&#39;) return(tmp_page_url) }) print(res[1:3]) ## [[1]] ## [1] &quot;https://ecsoc.hse.ru/2023-24-5/876469050.html&quot; ## ## [[2]] ## [1] &quot;https://ecsoc.hse.ru/2023-24-4/861891244.html&quot; ## ## [[3]] ## [1] &quot;https://ecsoc.hse.ru/2023-24-4/861891738.html&quot; Добавляем в цикл сбор данных по статье: res &lt;- lapply(3:12, function(x) { art_xpath &lt;- paste(&#39;//div[@class=&quot;centercolumn&quot;]/div[&#39;, x, &#39;]/small/a[2]&#39;, sep = &#39;&#39;) page_url &lt;- html_element(rubric_page, xpath = art_xpath) %&gt;% html_attr(&#39;href&#39;) page &lt;- read_html(page_url) article_info &lt;- data.table( url = page_url, autor = html_element(page, xpath = &#39;//h3/i&#39;) %&gt;% html_text(), title = html_element(page, xpath = &#39;//h2[@class=&quot;article-header&quot;]&#39;) %&gt;% html_text(), annotation = html_element(page, xpath = &#39;//div[@class=&quot;annot&quot;]&#39;) %&gt;% html_text2(), keywords = html_element(page, xpath = &#39;//div[@class=&quot;keywords&quot;]&#39;) %&gt;% html_text2(), doi = html_element(page, xpath = &#39;//div[@class=&quot;keywords&quot;][2]&#39;) %&gt;% html_text2(), volume = html_element(page, xpath = &#39;//div[@class=&quot;centercolumn&quot;]/div&#39;) %&gt;% html_text2() ) return(article_info) }) print(res[[1]]) ## url autor ## 1: https://ecsoc.hse.ru/2023-24-5/876469050.html Шевчук А. В. ## title ## 1: Теоретизируя цифровые платформы: концептуальная схема для гиг-экономики ## annotation ## 1: Современная социология труда уделяет большое внимание изучению трудового опыта работников, занятых через цифровые платформы. Однако для более глубокого понимания проблем гиг-экономики этот подход необходимо дополнить анализом самих цифровых платформ как организационных структур и социальных акторов. В статье предлагается концептуальная схема подобного анализа, опирающаяся на теоретические наработки в области экономической социологии, институционализма и политэкономии.\\nРоль цифровых платформ проблем атизируется с помощью пяти основных категорий (организационная инновация, фирма-медиатор, инфраструктура рынков, частный регулятор, институциональный предприниматель), которые последовательно включаются в анализ. Цифровые платформы представляют собой радикальную организационную инновацию, построенную на технологиях, способных эффективно координировать деятельность рассредоточенных агентов, не требуя их пространственного, темпорального и организационного соприсутствия. Это способствует развитию бизнеса, получающего выгоду от координации внешних по отношению к фирме работников и ресурсов. Предоставляемые платформами средства связи между экономическими агентами постепенно приобретают системный инфраструктурный характер, формируя базовые условия функционирования рынков. Имея возможность в одностороннем порядке устанавливать «правила игры» и осуществлять алгоритмическое управление, платформы превращаются в частных регуляторов рынков, конкурируя с государством. Чтобы укрепить и легитимировать свою власть, платформы активно вовлекаются в политический процесс с целью социальной реорганизации рынков и общей институциональной перестройки. На этом этапе концептуальная схема закольцовывается, возвращаясь к тому, что платформы представляют собой инновацию, в процессе диффузии которой должны быть разрешены наиболее острые социальные противоречия, связанные с бизнес-моделью фирмы-медиатора, её ролью как инфраструктуры, частного регулятора и институционального предпринимателя.\\nВ статье продемонстрировано, как предложенные категории могут применяться к анализу различных проблем гиг-экономики. ## keywords doi ## 1: Ключевые слова: цифровая экономика DOI: 10.17323/1726-3247-2023-5-11-53 ## volume ## 1: 2023. Т. 24. № 5. С. 11–53 [содержание номера] Дополнительные материалы Один из лучших справочников и туториалов по HTML. Есть примеры написания и использования тэгов. Тэги описаны по функционалу, есть список тэгов Справочник и туториалы, как и w3s, но с некоторыми изменениями/дополнениями и на русском языке. Короткое введение в XPath. Сайт выглядит страшненько, да и примеры все на xml (хотя разница с html минимальна). Скорее, для тех, кто хочет глубже разобраться в особенностях XPath, так как содержит много излишне детальной информации. Страница пакета purrr (для тех, кто хочет использовать современные функции для неявных циклов) Оптимизация циклов в R или “как надо правильно использовать for-циклы” Домашнее задание level 1 (IATYTD) прочитайте дополнительные материалы. разберите код получения информации о статьях с первой страницы рубрики level 2 (HNTR) научитесь получать, сколько страниц-списков статей есть в рубрике (список 12345…N внизу каждой страницы рубрики, нам нужно вот это N) level 3 (HMP) Прочитайте справку по функции list.files() и/или list.dirs(). Импортируйте названия файлов в какой-нибудь из ваших папок (или названия подпапок). В цикле выведите на печать первые пять названий. Например: ## [1] &quot;aggressive_actions.xlsx&quot; ## [1] &quot;artists.csv&quot; ## [1] &quot;artwork.csv&quot; ## [1] &quot;character-predictions_pose.csv&quot; ## [1] &quot;coronavirus_dt.csv&quot; level 4 (UV) Найдите максимальное значение по каждой колонке в таблице mtcars. Для каждой колонки выведите строку ‘Максимальное значение по колонке xxx: zzz’, где xxx и zzz - название колонки и максимальное значение соответственно. Для пятой задачи вам потребуются вот такие конструкции: library(data.table) mtcars &lt;- as.data.table(mtcars) names(mtcars) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; # вариант 1. обращение к колонке по номеру mtcars[1:3, 1] ## mpg ## 1: 21.0 ## 2: 21.0 ## 3: 22.8 # вариант 2. обращение к колонке по ее названию, которое хранится в другом объекте i &lt;- &#39;mpg&#39; mtcars[1:3, get(i)] ## [1] 21.0 21.0 22.8 level 5 (N) Решите получение информации о десяти статьях с первой страницы рубрики с помощью for-списка (у нас в решении используется lapply). Постарайтесь сделать это решение оптимальным с точки зрения использования памяти. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
