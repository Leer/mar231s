# Векторы {-#vectors}


## Запись занятия {-}

Запись занятия 21 января:

<iframe width="560" height="315" src="https://www.youtube.com/embed/hft-gODv9jE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<br>

## Векторы {-}

### Приведение типов {-}
 R используется достаточно простая система автоматического преобразования атомарных типов по логике от "самого строгого к самому гибкому", то есть по цепочке `logical` -> `integer` -> `numeric` -> `complex` -> `character` (тип `raw` не включается в эту систему). Такое преобразование позволяет использовать конструкции вида `sum(5 == 5)`, потому что логический результат сравнения (`TRUE`) будет преобразован в целое числовое значение (`1`, так как `TRUE` преобразовывается в `1`, а FALSE - в `0`), и, следовательно, можно вычислить количество верных утверждений. 
 
Подобные процедуры крайне часто используются когда, например, надо посчитать количество определенных значений в векторе значений (или в колонке в таблице). Вообще, для избежания неожиданных результатов, рекомендуется избегать неявных преобразований и контролировать типы самостоятельно.

Примеры приведений типов, все приводится к самому общему:
```{r}
# к строке
c('a', 3.6, 'b', 5.1, TRUE)

# к numeric
c(TRUE, 3.6, 2)
```


<br>

## Выбор элемента вектора {-}
Выбор элементов векторов указывается с помощью оператора `[` по следующей схеме: `x[<condition>]`. Это читается как `'элементы вектора x, которые удовлетворяют условию <condition>'`. 

В качестве условия может быть номер элемента в последовательности (индекс), так и какое-то логическое условие. При использовании оператора `[` в `<condition>` может быть передан вектор значений (или логическое выражение, возвращающее вектор значений).

<br>

### Выбор по номеру позиции {-}
Простой вариант выбора определенных элементов последовательности - по номеру в последовательности (по индексу, индекс начинается с 1). Например, в последовательности `4, 3, 2` на третьем месте находится значение `2`. В коде выбор третьего элемента этой последовательности выглядит вот так:
```{r}
x <- c(4, 3, 2)
x[3]
```

В список номеров последовательности также можно передавать не только единичное значение, но и вектор значений номеров последовательности, который мы хотим извлечь. Например:
```{r}
x <- c(4, 3, 2, 1)
x[c(2, 4)]
```

<br>

### Выбор по значению {-}
Также возможен выбор элементов вектора, которые удовлетворяют условию. Например, те, которые больше 10, или все, которые равны 3, или все четные. Логика такого выделения следующая: каждый элемент последовательности сравнивается с условием, и если сравнение верное (`5 == 5`, `TRUE`), то этот элемент возвращается как подходящий под условие. Фактически метка `TRUE` здесь является указателем элемента, который надо вернуть, аналогично номеру позиции при выделении по номеру позиции.

```{r, echo = FALSE}
set.seed(1234)
```

Например:
```{r}
# создаем вектор 8 случайных значений из массива от 1 до 10
x <- sample(1:10, 8)
x

# сравниваем каждое значение с 5, смотрим результат сравнения
x_cond <- x > 5
x_cond

# делаем выбор по условию, с указанием вектора, удовлетворяет элемент условию или нет
x[x_cond]

# аналогично, но без создания отдельного вектора
x[x > 5]
```

<br>

### Поиск по вхождению в массив {-}

Нередко встречаются ситуации, когда необходимо выбрать значения вектора, которые присутствуют в другом векторе. Например, из списка группы студентов выбрать тех, кто указан в списке недопущенных к сессии. Для этого используется выражение `x %in% y`. Оператор `%in%` проверяет, встречается ли каждый элемент вектора `х` в векторе `y`. Как и в сравнении по условию, в результате получается логический вектор, который можно использовать для выделения элементов. Выделенные элементы можно записать в отдельный объект. 

Например:
```{r}
x <- c('aaa', 'abc', 'bgs', 'gtr', 'ant', 'cer')
y <- c('tue', 'bgs', 'mtw', 'cer', 'lka')

# сравниваем элементы списков
x %in% y

# выделяем те элементы списка х, которые есть в у
x[x %in% y]

# записываем результат в отдельный объект
z <- x[x %in% y]
str(z)
```

<br>

### Проверка на NA {-}
 
В R есть несколько инструментов для работы с пропущенными или отсутствующими значениями.

 - `NA` --- `not avaliable`. Ситуация, когда значение пропущено. Например, для какой-то строки в колонке таблицы нет значения.
 - `NaN`, `Inf` --- `not a number` и `infinite` соответственно. Появляются при некорректных с математической точки зрения операциях (например, `0/0` и `1/0' соответственно).
 - NULL --- объект и тип, используется в редких случаях, когда надо создать пустой объект (например `x <- NULL`, но это плохая практика, для этого есть более корректные способы). Чаще нужен, когда надо удалить колонку в табличке.

Для того, чтобы проверить, есть ли пропущенные значения в векторе, используется функция `is.na()`. Эта функция проверяет, есть ли значение у каждого элемента вектора (является `NA` или нет) и отдает вектор логических значений, где `TRUE` означает, что у соответствующего элемента в проверяемом векторе нет значения (он пропущен).

```{r}
# делаем вектор с одним NA-значением
x <- c(1, 3, NA, 5)

# проверяем каждый элемент на то, пропущен он или нет
# видим, что для третьего элемента стоит TRUE, то есть пропущен
is.na(x)
```

Функцию `is.na()` можно точно также использовать для ивзлечения элементов вектора. Например, если мы хотим вернуть все не-пропущенные значения, нам надо воспользоваться оператор логического отрицания `!`. Этот оператор превращает `TRUE` в `FALSE` и наоборот:
```{r}
# смотрим, как работает оператор !
!TRUE

# пробуем извлечь все непропущенные значения из x
x[!is.na(x)]
```


<br>

## Изменение элементов объектов {-}
В задачах на изменение значения элемента векторов, списков или таблиц используется следующая логика - указывается элемент объекта, с которым надо произвести какое-то действие, и этому элементу присваивается новое значение. Например, у нас есть вектор из 10 значений в случайном порядке от 1 до 10, и мы хотим возвести в квадрат третий элемент:

```{r}
# задаем зерно для псевдослучайной генерации
set.seed(1234)

# создаем вектор
x <- sample(10)
str(x)
```

```{r}
# возводим в квадрат третий элемент:
x[3] <- x[3] ^ 2
str(x)
```

Создание новых элементов или удаление уже существующих производятся аналогично - указывается индекс элемента (или его название, если применимо), и присваивается какое-то значение. Для создания элемента - любой объект, если он не нарушает уже существующую структуру (например, в таблице на пять строк нельзя создать колонку с шестью значениями), если в векторе создавать значение иного типа, чем был, то все значения будут преобразованы к более общему по правилам преобразования. 
```{r}
# меняем 9 элемент вектора на 'x', текстовый
x[9] <- 'x'
str(x)
```

Для удаления элемента вектора можно просто сделать переприсвоение этому объекту тех же значений, за исключением того, которое требуется удалить:
```{r}
# удалим 3 значение вектора x
x <- x[-3]
str(x)
```


## Домашнее задание {-}

 - Из вектора `month.name` (уже есть в базовом R, не надо создавать) извлеките пятый элемент.
 - Из вектора `month.name` извлеките все элементы кроме пятого.
 - Из вектора `month.name` извлеките первый, пятый и последний элементы.
 - ** Создайте вектор `vec` из первых семи элементов вектора `letters` (уже есть в базовом R, не надо создавать), перемешанных в случайном порядке. Примените к нему функцию `order()`. Проинтерпретируйте результат.
 - *** Отсортируйте вектор `vec` с использованием `order()` и без использования `sort()`
 - Сравните каждый элемент вектора `vec <- letters[1:5]` с буквой `c` (равен или нет) и запишите в отдельный вектор`indices`. Выведите `indices` на печать. Примените `indices` для выбора элементов вектора `vec` (`vec[indices]`). Проинтерпретируйте результат.
 - Из вектора `month.name` извлеките каждый третий элемент.
 - Из вектора `vec <- sample(10, 8)` выберите все элементы, значения которых больше либо равны 5.
 - Из вектора `vec <- sample(100, 8)` выберите максимальное значение (элемент с максимальным значением). 
 - *** Решите предыдущее задание с помощью функции `which.max()`. Прочитайте справку по функции и найдите "подводный  камень", который потенциально может привести к ошибкам. Попробуйте представить ситуацию, когда может возникнуть такая ошибка (необязательно при работе с векторами, например, при работе с таблицами).
 - Из вектора `vec <- sample(100, 8)` выберите максимальное и минимальное значения.
 - Проверьте, встречаются ли значения вектора `x <- c(1, 3, 5, 6)` в векторе `y <- sample(10, 8)`.
 - Верните все элементы вектора `x`, которые встречаются в векторе `y`.
 - Верните все элементы вектора `x`, которые не встречаются в векторе `y`.
